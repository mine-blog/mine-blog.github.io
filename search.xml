<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件安全高级内存访问</title>
      <link href="/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/"/>
      <url>/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全SQL注入</title>
      <link href="/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入和数组越界访问漏洞"><a href="#SQL注入和数组越界访问漏洞" class="headerlink" title="SQL注入和数组越界访问漏洞"></a>SQL注入和数组越界访问漏洞</h2><p><strong>大致内容</strong></p><ul><li>SQL注入漏洞<ul><li>实现原理及后果</li><li>现有的相关应对措施</li></ul></li><li>数组越界访问漏洞</li></ul><h3 id="实现原理及后果"><a href="#实现原理及后果" class="headerlink" title="实现原理及后果"></a>实现原理及后果</h3><p><strong>B/S（浏览器和服务器）架构</strong></p><p>B/S是WEB兴起后的一种网络架构模式</p><ul><li>采用浏览器统一了客户端，将系统功能实现的核心部分集中到服务器上。</li><li>客户端使用浏览器，通过Web Server与数据库进行数据交互。</li></ul><p>B/S架构优势—-瘦客户端，胖服务端</p><ul><li>将系统实现的核心部分集中在服务端，简化系统的开发。</li><li>客户端载荷降低，减轻系统维护和升级成本。</li></ul><p><strong>数据库与SQL简介</strong></p><p>数据库：大型软件系统的关键基础设施。</p><ol><li>有结构的、有组织（集成）的、可共享的统一管理的数据集合。</li><li>具有尽可能小的冗余度、较高的数据独立性和易扩展性。</li><li>应用场景 — Web后台数据、企业级联机事务处理。</li></ol><p>结构化查询语言(Structured Query Language, SQL)，用户存取数据、查询、更新和管理关系数据库系统。注意：独立于数据库本身、硬件、网络以及操作系统。</p><ol><li>特殊目的编程语言。</li><li>数据库查询+程序设计语言。</li><li>屏蔽底层细节的高级数据库操作语言。</li></ol><p>SQL语言核心结构。</p><ul><li>做什么事情。</li><li>要找哪个对象做。</li><li>怎么做这件事情。</li><li>怎么找到这个对象（约束条件）。</li></ul><p>SQL注入出现原因：程序员的水平及经验也参差不齐，相当大一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。</p><p>SQL注入过程：把SQL命令插入到web表单递交或输入域名或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。<strong>SQL命令伪装成数据。</strong></p><p><strong>SQL注入原理</strong><br><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8SQL%E6%B3%A8%E5%85%A5/1.jpg"></p><p><strong>SQL注入过程</strong></p><ol><li>寻找可能存在SQL注入漏洞的链接</li><li>测试该网站是否有SQL注入漏洞</li><li>猜管理员帐号表</li><li>猜测管理员表中的字段</li><li>猜测用户名和密码的长度</li><li>猜测用户名</li><li>猜测密码</li></ol><p><strong>初级的注入</strong></p><ul><li>判断是否存在注入<br>对于可能存在SQL注入的动态网页，只要该网页带有参数且此网页访问了数据库，则有可能存在注入<br><code>http://xxx.xxx.xxx/abcd.php?id=XX</code><br>给参数赋值单引号，查看页面变化（单引号不匹配而报错，则表示执行了SQL）<br><code>http://xxx.xxx.xxx/abcd.php?id=XX’</code><br>若未报错，可能做了单引号过滤，使用判断语句进行注入测试（SQL注入漏洞分为数字型和字符型）</li><li>数字型漏洞<br><code>http://xxx.xxx.xxx/abcd.php?id=XX</code><br>若XX为数字类型，例如页码、ID等，存在注入时则为数字类型的注入。<br>给参数赋值为and 1=1，页面正常。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX and 1=1</code><br>接着给参数赋值为and 1=2，页面报错。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX and 1=2</code></li><li>字符型漏洞<br><code>http://xxx.xxx.xxx/abcd.php?id=XX</code><br>若XX为字符串，注入测试需使用单引号来闭合。<br>给参数赋值为and 1=1，页面正常。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX ‘and ’1‘=’1</code><br>接着给参数赋值为and 1=2，页面报错。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX ‘and ’1‘=’2</code></li><li>猜管理员账号表<br>在末尾加上：<code>and exists (select * from admin)</code><br>我们的意思是猜测他有个admin表段。页面返回正常，我们猜对了。当然也可能错误返回，这时就要看猜测的本事了。</li><li>猜测管理员表表中的字段<br>我们再来猜他的管理员表中是否有一个ID段，在末尾加上：<code>and exists (select id from admin)</code><br>页面返回正常,说明他的admin表中有个id的字段。<br>我们继续： <code>and exists (select username from admin)</code>。这里的意思是看看他的admin表中是否有username字段，页面返回正常,说明在admin中有一个username字段<br>我们继续猜他放密码的字段： <code>and exists (select password from admin)</code>。返回正常的页面,说明他的admin表中有个password字段。<br>到此可以知道admin表中至少有如下三个字段：id,username,password，这种命名方式与普通程序员的命名方法一致。</li><li>猜测用户名和密码的长度<br>首先猜他的管理员的id值： <code>and exists (select id from admin where id=1)</code>，意思是看看他的admin表中是否有一个id=1的值。<br>返回了正常的页面,说明我们猜对了。<br>接着猜ID为1的用户名长度： <code>and exists (select id from admin where len(username)&lt;6 and id=1)</code><br>这里我们猜他的管理员长度小于6,返回了正常的页面,还好,名字不是太长,我们一个个来实验好了。<br><code>and exists (select id from admin where len(username)=5 and id=1)</code>，返回了正常的页面,说明用户名的长度我们已经猜出了为5。<br>用同样的方法，我们猜出了密码的长度是10，要添加的语句是：<code> and exists (select id from admin where len(password)=10 and id=1)</code><br>到此，用户名和密码的长度都已经猜出来了，下面要做的是猜出它们的每一位分别是多少。<br>方法是在后面加上： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,1,1))&lt;100)</code><br>我们这里做的意思是，猜测他的用户名的第一个字的ascii码值小于100。<blockquote><p>其中，asc函数的功能是将字符转换成ASCII码，mid函数的功能是截取username字段值的字串，从第1位开始，截取的长度是1</p></blockquote></li></ul><p>返回了正常页面，说明的确如我们所料，接着： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,1,1))&lt;50)</code><br>返回错误信息，说明：50&lt;=第一个字的ascii码值&lt;100。接下来，我们用折半查找的思想： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,1,1))&lt;75)</code><br>接下来我们猜测第二位： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,2,1))&lt;100)</code><br>用折半查找的思想，采取上述方式，很快就能找到密码。</p><blockquote><p>注意：网站上密码多是以杂凑值处理，需要专用的哈希函数破解。尽管哈希函数是单向的，然而用户的密码是有限长度的，可以预先存储计算匹配，而非反向破解。</p></blockquote><p><strong>高级的注入</strong></p><ol><li>大小写绕过。</li><li>双写绕过。</li><li>等效语言表达绕过。</li><li>科学计数法、括号绕过。</li><li>浮点数、括号绕过。</li><li>内联注释绕过。</li><li>子查询、join联合绕过。</li></ol><h3 id="现有相关应对措施"><a href="#现有相关应对措施" class="headerlink" title="现有相关应对措施"></a>现有相关应对措施</h3><ol><li>对SQL请求的动态解析树，采用SQL引擎预先对SQL语法进行分析，生成该SQL语句的语法树。对客户端输入的参数中的SQL命令解析为字符串字面值参数，进而不会执行。</li><li>对用户输入的参数进行严格的匹配以及过滤。</li><li>设置用户操作数据库的权限。</li></ol><h2 id="数组越界访问漏洞"><a href="#数组越界访问漏洞" class="headerlink" title="数组越界访问漏洞"></a>数组越界访问漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>溢出与越界不完全相等</p><ul><li>数组越界分为读/写两种情况，而溢出漏洞属于越界写入。</li><li>一些溢出漏洞的本质是数组越界。</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#123;      int x[10];        cout &lt;&lt; x[10]; &#125;&#x2F;&#x2F;直观的数组越界可以在编译时较容易地检查出来，但是……&#123;      int i, x[10];        &#x2F;&#x2F;对i进行算术运算      cout &lt;&lt; x[i]; &#125;&#x2F;&#x2F;用法是允许的，存在越界的可能，但编译器无法指出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="举例与分析"><a href="#举例与分析" class="headerlink" title="举例与分析"></a>举例与分析</h3><p>CVE-2014-0160“OpenSSL数组越界访问漏洞”(Heartbleed心脏滴血) 。</p><p>成因–处理heartbeat response时没有检查包长度的合法性，直接分配相应大小的内存。</p><p>TLS和DTLS在处理心跳请求包逻辑中，从堆空间上申请的内存大小由type、length、request的数据长度和payload四个部分组成，其中type,length,payload字段分为占1byte，2byte，16byte，所以response的数据总是比request的多出来19byte。</p><p>length（心跳包的长度）是用户可控的，而payload（也是储存长度）是也是用户可控的，那么当payload长度大于心跳包的长度，那么就可以读取内存中心跳包后面的数据了。</p><p><strong>C语言的数组越界为何难以检查？</strong></p><ul><li>性能⟺安全。</li><li>指向数组元素的指针和数组本身是完全独立的。</li><li>指针运算的可行性。</li><li>用指针表示范围，不仅需要指针本身存在且可用，还需要指针指向的内存可用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全其他溢出漏洞</title>
      <link href="/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="本文大致内容"><a href="#本文大致内容" class="headerlink" title="本文大致内容"></a>本文大致内容</h2><ul><li>整数溢出<ul><li>数值计算的基本原理</li><li>整数溢出及其可能的后果</li></ul></li><li>格式化字符串漏洞<ul><li>类printf函数簇实现原理</li><li>格式化字符串攻击原理及潜在后果</li></ul></li></ul><p>在这一章节似乎只是在计算机中实现，更偏向于怎么将漏洞在计算机上实现，对于一些常见的编程中出现的漏洞，也似乎不能叫出现的漏洞吧，应该是编译器的漏洞。对一些边界问题的规定是否规范，还是任由编译器自己决定，决定着这个漏洞是否可以被实现。通过打印出一些内存中具体的值，为后来的其他溢出做了铺垫。</p><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><h3 id="数值计算的基本原理"><a href="#数值计算的基本原理" class="headerlink" title="数值计算的基本原理"></a>数值计算的基本原理</h3><ul><li>整数的表示</li></ul><p><strong>64位</strong><br>类型：short（16bit）、int（32bit）、long（64bit），8字节<br>带符号：-2^（n-1)-2^（n-1）-1、不带符号：0-2^n-1<br><strong>32位</strong><br>long（32bit），4字节</p><ul><li>带符号整数格式中的补码</li></ul><ol><li>带符号的正护士统一用补码表示（正整数和负整数都是）。</li><li>意义：符号位和数值域统一，加法和减法统一。</li></ol><blockquote><p>对于正数原码、反码以及补码是其本身。负数的原码是其本身，反码是对原码除符号位之外的各位取反，补码则是反码加1。</p></blockquote><ul><li>整数的加减法</li></ul><p><strong>CF是无符号数溢出标志，OF是有符号数溢出标志。</strong></p><p>CF/OF=1，则表示计算结果溢出。</p><ol><li>CF的判断<ul><li>加法<br>十进制角度，如果两个无符号数相加，结果大于阈值，则CF=1，否则CF=0。<br>二进制角度，如果两无符号数相加，最高位向前进位，则CF=1，否则CF=0。</li><li>减法<br>十进制角度，两无符号数相减，减数大于被减数，则CF=1，否则CF=0。<br>二进制角度，如果两无符号数相减，最高位向前有借位，则CF=1，否则CF=0。</li></ul></li><li>OF判断<ul><li>加法<br>十进制角度，两有符号数相加，结果不在范围内，则OF=1，否则OF=0。<br>二进制角度，如果两有符号数同号，得到的结果异号，则OF=1，否则OF=0。</li><li>减法<br>十进制角度，两有符号数相减，结果不在范围内，则OF=1，否则OF=0。<br>二进制角度，如果两有符号数异号，得到的结果与被减数符号相反，则OF=1，否则OF=0。</li></ul></li></ol><p>整数溢出的例子中需要注意</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int atoi(const char *nptr);&#x2F;&#x2F;用法：将字符串里的数字字符转化为整形数。返回整形值。&#x2F;&#x2F;注意：转化时跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(&#39;&#x2F;0&#39;)才结束转换，并将结果返回。void *memcpy(void *destin, const void *src, size_t n);&#x2F;*由src指向地址为起始地址的连续n个字节的数据复制到以destin指向地址为起始地址的空间内。　　函数返回一个指向destin的指针。说明    1. source和destin所指内存区域不能重叠，函数返回指向destin的指针。    2. 与strcpy相比，memcpy并不是遇到&#39;\0&#39;就结束，而是一定会拷贝完n个字节。    3. 如果目标数组destin本身已有数据，执行memcpy（）后，将覆盖原有数据（最多覆盖n）。如果要追加数据，则每次执行memcpy后，要将目标数组地址增加到你要追加数据的地址。注意，source和destin都不一定是数组，任意的可读写的空间均可。*&#x2F;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在C语言中的表示</li></ul><p>在C/C++语言中，char变量为一个字节，8位，signed char表示的范围：-128-127【-128在内存中的二进制表示为1000 0000，127在内存中的表示为0111 1111】；unsign char表示的范围：0000 0000-1111 1111，即0-255；<br>默认是signed还是unsigned取决于编译器。</p><p>因为size是字节数，所以要*8，这样unsigned取模刚好是对它的表示范围取模。<br>左边是无符号型全1，是最大值+1=0<br>右边是0111 1111 = 127，也是最大值，+1=128，实际上溢出了，超出了表示范围。1 000 0000=-128</p><blockquote><p>C语言中的表示不是很一样，如果取无符号，则只表示之前范围的非负数的那部分。</p></blockquote><h3 id="整数溢出及其可能的后果"><a href="#整数溢出及其可能的后果" class="headerlink" title="整数溢出及其可能的后果"></a>整数溢出及其可能的后果</h3><p><strong>例如</strong></p><ol><li>举例1</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/1.jpg"></p><p>若将MAX_LEN设置为32767，同时，假设buf的值总为2，实际结果：当len==32766时，line 6 造成len的值变为-32768，程序死循环</p><p>32767是signed short上限，len=32766时，+2溢出，如果不规定处理方式则变为最小值-32768。程序无法跳出循环。</p><ol start="2"><li>举例2</li></ol><p>又如：abs(-2147483648) &lt; 0</p><p>函数abs的功能 — 对于输入参数为正，返回其本身，否则返回其相反数。<br>然而，对于-2147483648（int类型的最大负数值），函数abs返回的是其本身。</p><p>可见，整数溢出至少可能产生以下一些后果</p><ul><li>产生逻辑谬误，造成程序在执行中卡死或者出错</li><li>为后续的缓冲区溢出充当引信</li></ul><p>一些防范整数溢出的编程习惯</p><ul><li>对整数溢出的检查必须出现在可能溢出的位置之前，否则就有可能不起作用</li><li>注意类型强制转换（或者说，注意指针的使用）</li><li>同等地重视上溢和下溢，两者都需要预先检查</li></ul><p><strong>整数溢出的防护</strong></p><ol><li>IntScope — 检测整数溢出本身</li></ol><p>利用符号执行、动态污点跟踪等分析运行时数据流，寻找异常。</p><ol start="2"><li>IntPatch — 检测并修复后续的缓冲区溢出漏洞</li></ol><p>针对：整数溢出到缓冲区溢出（IO2BO）</p><h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><h3 id="类printf函数簇实现原理"><a href="#类printf函数簇实现原理" class="headerlink" title="类printf函数簇实现原理"></a>类printf函数簇实现原理</h3><ul><li>类printf函数簇的第一个可利用点：参数不匹配时难以发现。<ul><li>printf()是一个参数长度可变函数，仅仅看参数数量无法发现问题。</li><li>为了查出不匹配，编译器需要了解printf()的运行机制，然而编译器通常不做这类分析。</li><li>若格式字符串在程序运行期间生成(如用户输入)，则编译器无法发现不匹配。</li></ul></li></ul><h3 id="格式化字符串攻击原理及潜在后果"><a href="#格式化字符串攻击原理及潜在后果" class="headerlink" title="格式化字符串攻击原理及潜在后果"></a>格式化字符串攻击原理及潜在后果</h3><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2.jpg"></p><blockquote><p>当printf在输出格式化字符串的时候，会维护一个内部指针，当printf逐步将格式化字符串的字符打印到屏幕，当遇到%的时候，printf会期望它后面跟着一个格式字符串，因此会递增内部字符串以抓取格式控制符的输入值。这就是问题所在，printf无法知道栈上是否放置了正确数量的变量供它操作，如果没有足够的变量可供操作，而指针按正常情况下递增，就会产生越界访问。甚至由于%n的问题，可导致任意地址读写。</p></blockquote><ol><li>举例1</li></ol><p>如果让str=“%x”，则会发生什么？<br>%x是printf规定的一种输出类型，unsigned int，输出无符号16进制数。<br>结果：通过构造异常字符串，可以实现对程序栈结构的任意读取。</p><p><strong>为什么程序员写的是错误的呢？</strong></p><p>他传入了一个他想要逐字打印的字符串。实际上该字符串被printf函数解释为一个格式化字符（formatstring），printf就会根据该字符串来决定printf函数中省略号参数表中参数的格式和类型，如果这个程序员想要打印的字符串中刚好有“%d”,“%x”之类的格式化字符，那么一个变量的参数值就从堆栈中取出。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char* argv[])&#123;    if(argc !&#x3D; 2)        return 0;    printf(argv[1]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当./a.out “hello world”时一切正常，但是当./a.out “%x”时，就会有莫名其妙的数字被打印出来了。因为后面没跟参数，但printf以为后面有个参数，就会把当前堆栈对应的4字节（应该是高地址）以%x打印。通过特定设计，可以打印特定位置内存信息。<br>很明显，攻击者至少可以通过打印出堆栈中的这些值来偷看程序的内存。但是有些事情就不那么明显了，这个简单的错误允许向运行中程序的内存里写入任意值。</p><ol start="2"><li>举例2</li></ol><p><strong>更进一步</strong><br>%s，printf规定的另一种输出类型，char <em>/wchar_t</em>，输出字符串。</p><p>结果：通过构造异常字符串，还有可能实现对任意内存的（大面积）读取。</p><ol start="3"><li>举例3</li></ol><p><strong>再进一步</strong><br>%n，特殊printf输出类型，int*，将此前已输出的串长度写入指针所指位置。</p><p>结果：通过构造异常字符串，可以实现对任意内存的任意改写。</p><blockquote><p>%n:该符号前输入的字符数量会被存储到对应的参数中去。<br>int i; printf (“12345%n”, &amp;i);<br>数字5（%n前的字符数量）将会被写入i中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对晨晨说的话</title>
      <link href="/2021/06/22/%E5%AF%B9%E6%99%A8%E6%99%A8%E8%AF%B4%E7%9A%84%E8%AF%9D/"/>
      <url>/2021/06/22/%E5%AF%B9%E6%99%A8%E6%99%A8%E8%AF%B4%E7%9A%84%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="对晨晨说的话"><a href="#对晨晨说的话" class="headerlink" title="对晨晨说的话"></a>对晨晨说的话</h2><p><img src="../%E5%AF%B9%E6%99%A8%E6%99%A8%E8%AF%B4%E7%9A%84%E8%AF%9D/1.JPG"></p><p>今天是星期三，我很想知道什么事情，这件事情在我的心里憋了很久，我一直提醒自己不要忘记，不要记起，不要回想。不要去追寻。在多少年前，我是过着什么样的生活，在大概十年前，我知道自己在做什么吗，十年前的这个时候，我可能现在早已经进入梦乡，或者是在做其他的事，具体什么事，也是在幻想生活的改变。</p><p>我期待明天，我期待每天的早晨，现在不是如此吗？现在也是，在早上我是不会有任何烦心的事情，我总能想起梦里的事情，梦里我怎么做，怎么说，我梦到了谁，昨晚梦到了谁，今晚我要梦到谁，做怎么样的梦。我的生活是由无数人的生活促就的，他们做的改变，他们的呼吸，他们的欢笑和哭泣，让远方的我有了如此的生活。</p><p>在这一天，我遇到了这个人。我很认定我自己是对的，因为我心动了，在自己经历过如此多的事情之后，我发现自己喜欢的是什么，讨厌的是什么，不屑的是什么，甚至追求的是什么都已经模糊。在我遇到她之前，我早上是八点十分起床的，我早上吃肉夹馍，中午吃快餐，晚上吃烩面。我有时还会打游戏，在虚拟世界里沉迷一小刻，我便开始幻想，为什么我自己不能有自己的幸福。为什么爱情要如此令我受折磨，在一个孤独的冰冷的世界遨游，我要归往的是哪里，我是会要做一个没有经历过青春的人吗？还是要在无数个不愿意睁开眼，知道世界上的某个角落的某个人仍旧孤孤零零寻找我的味道呢？</p><p>我遇到你，我想要对你说过许多话，但有很多是不足够表达我的心的。我想，我听，我思考。我最爱这样子，这样就可以慢慢规划以后的事情，我拒绝做一个精英，我想不断陪伴一个人成长。不是要面谈生意，我不愿牺牲爱情，我不愿在自己的心中磨灭对爱情的美妙的想象。你喜欢什么颜色，爱吃什么食物，喜欢冬天还是夏天，今天的天气如何，你的心情如何，有没有不舒服，有没有饿到肚子，有没有吃了不对胃口的饮食。这些问题困扰着我，我也不会知道，我不知道今天你在一棵树前停留许久，是在想，是在听，还是在发呆。想要一个人的依靠，想要一个人的照顾。</p><p>我不希望自己成为他人的迷茫点，在无数个夜晚，我都是怎么在想你，想你做什么，我怕失去你，也怕错过你。我总该想，要多和你说几句话，说有趣的事，吃可口的食物，吹凉飒的晚风，走在平常的街道，听夏日的蝉鸣。我又想在午后，吃完最后一口米饭，一起将碗筷收进厨房，看到时间还早，我不过是想靠你近一点，用纸巾擦去你嘴巴上的油。</p><p>生活如此，我梦想，幻想，还是想象。你存在吗？我不敢相信自己，我从来不会觉得自己有着足够的幸运遇到你，我知道过无数的人，无数的事。知道他们过着怎么样的生活，却没曾想终于愿意沉下心来为自己做打算，为我们的之后做安排。</p><p>夜没深，我也没有醒，希望我在梦里不会醒，你也不会从梦里走出来，在梦里，我很喜欢。喜欢你的发梢，你的脸庞，你的呼吸，你的心跳，最喜欢你无处不在的可爱。</p><p>你要吃掉我的心吗，晨晨，生活是美好的，就算眼前困惑。你要相信我。</p><p>–SS</p>]]></content>
      
      
      <categories>
          
          <category> 胜胜的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胜胜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全期末</title>
      <link href="/2021/06/22/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/"/>
      <url>/2021/06/22/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/</url>
      
        <content type="html"><![CDATA[<p>这篇文章也是花了很久的时间才能说半抄半理解结束，其中有一些内容到现在还是不清楚，但愿自己慢慢思考。</p><span id="more"></span><ul><li><p>堆的构造与维护原理</p><ul><li>堆的场地和块</li><li>隐式/显示链表与堆的维护</li></ul></li><li><p>堆溢出</p><ul><li>linux系统典型堆溢出原理</li><li>现有应对策略和技术</li></ul></li></ul><h2 id="堆的工作原理"><a href="#堆的工作原理" class="headerlink" title="堆的工作原理"></a>堆的工作原理</h2><ul><li>堆与栈的区别<ul><li>栈：硬件支持；存储数据+控制流信息。</li><li>堆：操作系统的库函数支持；存储数据。</li></ul></li></ul><p>堆的创建和维护通过malloc实现。</p><p>堆内存是移动[Program Break]的位置产生的（通过brk中断），实际产生的堆比申请的堆还要大，这个连续的对区域被称为[arena]。被主进程创建的，因此称为[main arena]。接下来申请会分配到这个arena的多余申请空间的部分。分配完毕后，它可以通过继续移动Program Break的位置扩容。扩容后，top chunk的大小也随之调整，将这块新增的空间圈进去。相应地，arena也可以在top chunk过大时缩小。top chunk是一个 arena位于最顶层的chunk。</p><blockquote><p>注意：非直接返还给系统，由malloc库函数管理，将其添加到bin。当用户再次调用，首先从bins查找是否有满足的，若没有才向操作系统申请新的堆空间，以提高整个效率。</p></blockquote><p>堆在栈创造之前便存在了，是程序运行便开始调用栈，而堆需要使用malloc函数才行。</p><h3 id="堆内存的建立"><a href="#堆内存的建立" class="headerlink" title="堆内存的建立"></a>堆内存的建立</h3><p>堆内存是使用mmap系统调用产生的，而非同主线程一样使用sbrk系统调用。用户请求的空间中略大（申请100kb，但实际映射到地址空间的有1Mb），只有132kb空间有读写权限，并成为该线程的堆内存。称之为[thread areana]。</p><p>当用户请求超过128kb，并且arena中没有足够的空间来满足用户的请求，内存将通过mmap系统调用分配（不再是sbrk），而不论请求是发自main arena还是thread arena。</p><h3 id="堆的工作原理-1"><a href="#堆的工作原理-1" class="headerlink" title="堆的工作原理"></a>堆的工作原理</h3><p>arena数量</p><ul><li>32位系统=2*内核数+1</li><li>64位系统=8*内核数+1</li></ul><p>单核32位系统，运行多线程程序–1个主线程+3个用户线程，malloc如何令4个线程共享3个arena？</p><p>主线程分配主arena,线程1、2分别分配arena，那么线程3需要重复使用已分配好的arena.glibc malloc循环遍历所有可用的场地，如果lock成功（该 场地当前对应的线程并未使用堆内存），则将该场地供线程3使用。</p><p>如果没有找到可用的area，则将线程3的malloc操作阻塞，直到找到可用的为止。</p><ul><li><p>在[glibc malloc]中主要有3种数据结构：</p><ul><li><p>heap_info ——Heap Header—— 一个 thread arena 可以维护多个堆。每个堆都有自己的堆 Header（注：也即头部元数据）。什么时候 Thread Arena 会维护多个堆呢？ 一般情况下，每个 thread arena 都只维护一个堆，但是当这个堆的空间耗尽时，新的堆（而非连续内存区域）就会被 mmap 到这个 aerna 里；</p></li><li><p>malloc_state ——Arena header—— 一个 thread arena 可以维护多个堆，这些堆另外共享同一个 arena header。Arena header 描述的信息包括：bins、top chunk、last remainder chunk 等；</p></li><li><p>malloc_chunk ——Chunk header—— 根据用户请求，每个堆被分为若干 chunk。每个 chunk 都有自己的 chunk header；</p></li><li><p>Main arena 无需维护多个堆，因此也无需heap_info。当空间耗尽时，与 thread arena 不同，main arena 可以通过 sbrk 拓展堆段，直至堆段[碰]到内存映射段；</p></li><li><p>与 thread arena 不同，main arena 的 arena header 不是保存在通过 sbrk 申请的堆段里，而是作为一个全局变量，可以在 libc.so 的数据段中找到。</p></li></ul></li></ul><p>thread arena只含有一个malloc_state(即arena header)，却有两个heap_info(即heap header)。由于两个heap segments是通过mmap分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，libc malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了malloc_state，这样就构成了一个单链表，方便后续管理。</p><p><strong>堆块进化史</strong></p><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/1.jpg"></p><p>左上是allocated chunk格式，左下是free chunk格式，右边是整个堆内存组织成一个连续的已分配或未分配chunk序列。</p><p>堆内存中要求每个chunk的大小必须为8的整数倍，因此chunk size的后3位是无效的，为了充分利用内存，堆管理器将这3个比特位用作chunk的标志位，典型的就是将第0比特位用于标记该chunk是否已经被分配。</p><blockquote><p>这样的设计很巧妙，因为我们只要获取了一个指向chunk size的指针，就能知道该chunk的大小，即确定了此chunk的边界，且利用chunk size的第0比特位还能知道该chunk是否已经分配，这样就成功地将各个chunk区分开来。注意在allocated chunk中padding部分主要是用于地址对齐的(也可用于对付外部碎片)，即让整个chunk的大小为8的整数倍。</p></blockquote><p>上面的这种结构就叫做<strong>隐式链表</strong>。该链表隐式地由每个chunk的size字段链接起来，在进行分配操作的时候，堆内存管理器可以通过遍历整个堆内存的chunk，分析每个chunk的size字段，进而找到合适的chunk。</p><p>缺点：这种隐式链表效率其实是相当低的，特别是在内存回收方面，它难以进行相邻多个free chunk的合并操作。我们知道，如果只对free chunk进行分割，而不进行合并的话，就会产生大量小的、无法继续使用的内部碎片，直至整个内存消耗殆尽。因此堆内存管理器设计了带边界标记的chunk合并技术。</p><p><strong>出现问题</strong></p><ol><li>向前合并</li></ol><p>假设我们要释放的chunk为P，它紧邻的前一个chunk为FD，紧邻的后一个chunk为BK，且BK与FD都为free chunk。将P于BK合并在一起是很容易的，因为可以通过P的size字段轻松定位到BK的开始位置，进而获取BK的size等等，但是将P于FD合并却很难，我们必须从头遍历整个堆，找到FD，然后加以合并，这就意味着每次进行chunk释放操作消耗的时间与堆的大小成线性关系。</p><p>为了解决这个问题，Knuth提出了一种聪明而通用的技术——边界标记。</p><p>Knuth在每个chunk的最后添加了一个脚部(Footer)，它就是该chunk 头部(header)的一个副本，我们称之为边界标记。显然每个chunk的脚部都在其相邻的下一个chunk的头部的前4个字节处。通过这个脚部，堆内存管理器就可以很容易地得到前一个chunk的起始位置和分配状态，进而加以合并了。</p><p>但是，边界标记同时带来了一个问题：它要求每个块都包含一个头部和脚部，如果应用程序频繁地进行小内存的申请和释放操作的话(比如1，2个字节)，就会造成很大的性能损耗。</p><p>同时，考虑到只有在对free chunk进行合并的时候才需要脚部，也就是说对于allocated chunk而言它并不需要脚部，因此我们可以对这个脚部加以优化——将前一个chunk的已分配/空闲标记位存储在当前chunk的size字段的第1，或2比特位上，这样如果我们通过当前chunk的size字段知道了前一个chunk为free chunk，<em>那么就可得出结论</em>：当前chunk地址之前的4个字节为前一个free chunk的脚部，我们可以通过该脚部获取前一个chunk的起始位置；如果当前chunk的size字段的标记位表明前一个chunk是allocated chunk的话，<em>那么就可得出另一个结论</em>：前一个chunk没有脚部，即当前chunk地址之前的4个字节为前一个allocated chunk的payload或padding的最后部分。</p><ol start="2"><li>多线程时标志位不够</li></ol><p>随着技术的发展，特别是堆内存管理器添加对多线程的支持，前述的chunk格式已经难以满足需求，比如，我们需要标志位来标记当前chunk是否属于非主线程即thread arena，以及该chunk由mmap得来还是通过brk实现等等。但此时chunk size只剩下一个比特位未使用了，怎么办呢？这需要对chunk格式进行大手术！</p><p>首先思考：是否有必要同时保存当前chunk和前一个chunk的已分配/空闲标记位？</p><p>答案是否定的，因为我们只需要保存前一个chunk的分配标志位就可以了，至于当前chunk的分配标志位，可以通过查询下一个chunk的size字段得到。那么size字段中剩下的两个比特位就可以用于满足多线程的标志需求了。</p><p>PREV_INUSE(P): 表示前一个chunk是否为allocated。<br>IS_MMAPPED(M)：表示当前chunk是否是通过mmap系统调用产生的。  NON_MAIN_ARENA(N)：表示当前chunk是否是thread arena。</p><p><strong>当前的堆块的形态</strong></p><p>没必要保存chunk size的副本，也就是说Footer的作用并不大，但是如果前一个chunk是free的话，在合并的时候我们又需要知道前一个chunk的大小，怎么办呢？</p><p>将Footer从尾部移到首部，同时其不再保存当前chunk的size，而是前一个free chunk的size不就行了。同样的，为了提高内存利用率，如果前一个chunk是allocated chunk的话，这个Footer就作为allocated chunk的payload或padding的一部分。</p><p><strong>隐式/显式（bin）链表结构</strong></p><p>该结构体通过每个chunk的prev_size和size构成了隐式链表，而后续的fd, bk等指针并不是作用于隐式链表的，而是用于加快内存分配和释放效率的显示链表bin(还记得bin么？用于记录同一类型free chunk的链表)，并且这些指针跟prev_size一样只在free chunk中存在。</p><p><strong>bin的分类</strong></p><ul><li>fastbinsY，16-80字节，记录所有fastbins的数组。</li><li>bins，记录除了fastbins之外所有的bins。<ul><li>unsorted bin。</li><li>small bin。</li><li>large bin。</li></ul></li></ul><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/2.jpg"></p><p>在所有的 bins 中，fast bins 路径享有最快的内存分配及释放速度。</p><p><strong>堆的工作原理</strong></p><p>每个 fast bin 都维护着一条 free chunk 的单链表，采用单链表是因为链表中所有 chunk 的大小相等，增删 chunk 发生在链表顶端即可；—— LIFO。添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。需要注意的是，为了实现LIFO算法，fastbinsY数组中每个fastbin元素均指向了该链表的rear end（尾结点），而尾结点通过其fd指针指向前一个结点，依次类推。<br>chunk 大小：8 字节递增。 fast bins 由一系列所维护 chunk 大小以 8 字节递增的 bins 组成。也即，fast bin[0] 维护大小为 16 字节的 chunk、fast bin[1] 维护大小为 24 字节的 chunk。依此类推……  指定 fast bin 中所有 chunk 大小相同；</p><p>在 malloc 初始化过程中，最大的 fast bin 的大小被设置为 64 而非 80 字节。因为默认情况下只有大小 16 ~ 64 的 chunk 被归为 fast chunk 。</p><p>无需合并 —— 两个相邻 chunk 不会被合并。虽然这可能会加剧内存碎片化，但也大大加速了内存释放的速度！</p><p>malloc(fast chunk) ：初始情况下 fast chunck 最大尺寸以及 fast bin 相应数据结构均未初始化，因此即使用户请求内存大小落在 fast chunk 相应区间，服务用户请求的也将是 small bin 路径而非 fast bin 路径；初始化后，将在计算 fast bin 索引后检索相应 bin；</p><p>相应 bin 中被检索的第一个 chunk 将被摘除并返回给用户。<br>free(fast chunk) ：计算 fast bin 索引以索引相应 bin；free 掉的 chunk 将被添加到上述 bin 的顶端。  </p><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中(为什么，在什么情况下会发生这种事情呢？详情见后文)，系统就将这些chunk添加到unsorted bin中。为什么要这么做呢？这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。</p><p><strong>Unsorted bin的特性如下</strong></p><ul><li><p>unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。</p></li><li><p>Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。这就是前言说的特例了，不过特例并非仅仅这一个，后文会介绍。</p></li><li><p>小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。每个small bin也是一个由对应free chunk组成的循环双链表。第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 61*8 = 508字节。</p></li><li><p>大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。</p></li><li><p>鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行从大到小的排列：最大的chunk放在链表的front end，最小的chunk放在rear end。</p></li></ul><p><strong>top chunk</strong></p><p>当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。该chunk并不属于任何bin，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。</p><p>如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：</p><ol><li>用户请求的chunk；</li><li>剩余的部分成为新的top chunk。<br>否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</li></ol><p><strong>顶块的作用：救火队员</strong></p><ol><li>不属于任何bin</li><li>当前所有空闲块(无论那种bin)全都尺寸不合时，由顶块应急</li><li>顶块比请求尺寸大 — 分割供给使用，剩余部分为新顶块</li><li>顶块比请求尺寸小 — 全堆无适合块，扩展堆/分配新堆</li></ol><p>对于Last remainder chunk，我们主要有两个问题：<br>1)它是怎么产生的；<br>2)它的作用是什么？</p><ul><li><p>当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。</p></li><li><p>此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</p></li></ul><h4 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h4><p><strong>与栈溢出的区别</strong></p><ol><li>堆溢出方向=堆增长方向。</li><li>首先破坏（虚拟地址意义上的）下一个堆块的构造。</li></ol><p><strong>linux典型的堆溢出利用方式</strong></p><ol><li>攻击fast bin。</li><li>攻击unlink。</li></ol><p><strong>攻击fastbin</strong></p><p>攻击原理是在chunk被分配时，从队尾删除，并将当前chunk的fd写入到fastbin。下次分配就分配这个fd对应地址的chunk。<br>具体用法是chunk0写入溢出，覆盖相邻的chunk1的fd。当chunk1被分配时，被篡改的chunk1中的fd被写入fastbin。在chunk2被分配时就分配攻击者想攻击的内存地址。因为被分配的内存空间可写，攻击者因此实现对指定地址写入数据的目的。</p><p>可能是在内存有连续空间时，快速分配释放，使得buf0 buf1空间连续，这样在写入溢出时，就可以覆盖到相邻的未分配的buf1里面的fd地址。</p><p><strong>攻击unlink</strong></p><p>一旦涉及到free内存（非mmaped的chunks的回收机制），那么就意味着有新的chunk由allocated状态变成了free状态，此时glibc malloc就需要进行合并操作——向前以及(或)向后合并。</p><p>将previous free chunk合并到当前free chunk，叫做向后合并；将后面的free chunk合并到当前free chunk，叫做向前合并</p><p><strong>向后合并操作</strong></p><p>首先检测previous chunk是否为free，这可以通过检测当前free chunk的PREV_INUSE(P)比特位获得。</p><p><strong>如果为free的话，那么就进行向后合并</strong></p><p>将前一个chunk占用的内存合并到当前chunk。<br>修改指向当前chunk的指针，改为指向前一个chunk。<br>使用unlink宏，将前一个free chunk从双向循环链表中移除。</p><p><strong>向前合并操作</strong></p><p>首先检测next chunk是否为free。那么如何检测呢？通过查询next chunk之后的chunk的PREV_INUSE (P)。</p><p><strong>即可如果为free的话，那么就进行向前合并</strong></p><p>本质是将next chunk从双向链表中移除，合并到当前chunk。<br>在glibc malloc中，会将合并后的chunk(或因为不满足合并条件而没合并的chunk) ，放到unsorted bin中。</p><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/3.jpg"></p><ol><li><p>在代码3中存在一个堆溢出漏洞：如果用户输入的argv1的大小比first变量的666字节更大的话，那么输入的数据就有可能覆盖掉下一个chunk的chunk header——这可以导致任意代码执行。而攻击的核心思路就是利用glibc malloc的unlink机制。</p></li><li><p>程序在[4]处调用free(first)后，执行：</p><ul><li><p>向后合并：鉴于first的前一个chunk非free的，所以不会发生向后合并操作。</p></li><li><p>向前合并：先判断后一个chunk是否为free，若free则合并。</p></li></ul></li><li><p>prev_size =一个偶数，这样其PREV_INUSE位就是0了，即表示前一个chunk为free。</p><ul><li>size = -4</li><li>fd = free函数的got表地址address – 12；(简称为“free addr – 12”)。</li><li>bk = shellcode的地址Bitmap Flipping攻击。</li></ul></li><li><p>  nextchunk + nextsize计算得到指向下下一个chunk的指针，然后判断下下个chunk的size的PREV_INUSE标记位（判断是否为free）。    + nextsize=-4,进而导致next chunk的prev_size字段看做是next-next chunk的size字段。    + next chunk的prev_size字段设置为了一个偶数，低位为0进而判断next chunk为free。</p></li></ol><p><strong>注意</strong></p><p>既然next chunk为free，那么就需要进行向前合并，所以就会调用unlink(nextchunk, bck, fwd)函数。真正的重点就是这个unlink函数！</p><p><strong>上一段中描述的”前一个“与”后一个“chunk，是指的由chunk的prev_size与size字段隐式连接的chunk，即它们在内存中是连续、相邻的！而不是通过chunk中的fd与bk字段组成的bin(双向链表)中的前一个与后一个chunk，切记！</strong></p><p>fd = free函数的got表地址address – 12；(简称为“free addr – 12”)<br>bk = shellcode的地址。</p><p>调用unlink(nextchunk, bck, fwd)合并。</p><p>FD = nextchunk-&gt;fd = free addr– 12;<br>BK = nextchunk-&gt;bk = shellcode起始地址;<br>BK赋值给FD-&gt;bk，即（free add– 12）-&gt;bk = shellcode起始地址；<br>FD赋值给BK-&gt;fd，即(shellcode起始地址)-&gt;fd = free addr– 12;</p><p>最终，free add指向shellcode add,当程序在代码[5]处再次执行free的时候，就会转而执行shellcode。达到攻击效果</p><p><strong>Windows堆溢出攻击的主要形式</strong></p><ul><li>利用向量化异常处理（VEH）</li><li>利用系统默认异常处理函数（UEF）</li><li>Heap spray</li><li>Bitmap Flipping攻击</li><li>Bitmap XOR攻击</li><li>Heap Cache攻击</li></ul><h4 id="堆溢出的防御"><a href="#堆溢出的防御" class="headerlink" title="堆溢出的防御"></a>堆溢出的防御</h4><p>相比栈溢出，针对堆溢出的防御措施更易实用化<br>堆依靠系统库实现其维护，故堆保护=系统库升级</p><p><strong>针对unlink的保护</strong></p><ol><li><p>Double Free检测:该机制不允许释放已经处于free状态的chunk。因此，当攻击者将second chunk的size设置为-4的时候，就意味着该size的PREV_INUSE位为0，也就是说second chunk之前的first chunk(我们需要free的chunk)已经处于free状态，那么再free就报出double free错误。</p></li><li><p>next size非法检测: 检测next size是否在8到当前arena的整个系统内存大小之间。因此当检测到next size为-4的时候，就会报出invalid next size错误。</p></li><li><p>双链表冲突检测:执行unlink操作的时候检测链表中前一个chunk的fd与后一个chunk的bk是否都指向当前需要unlink的chunk。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等待爱情</title>
      <link href="/2021/06/20/CC%E7%9A%84%E5%BF%AB%E4%B9%90/"/>
      <url>/2021/06/20/CC%E7%9A%84%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<h2 id="晨晨的快乐"><a href="#晨晨的快乐" class="headerlink" title="晨晨的快乐"></a>晨晨的快乐</h2><p><img src="../CC%E7%9A%84%E5%BF%AB%E4%B9%90/0.JPG"></p><p> 这一周和弟弟的联系感觉没有上一周多了，原因呢大概就是我忙着找工作弟弟忙着准备期末考试呢，不知道为什么每次到这种环节我的心底就会泛起涟漪，想着我们的联系变少了以后会不会更少了，想着我们的联系变少了感情会不会没有之前热烈了，想着我们的联系变少了会不会没有以前那么亲密无间了，这些想法一直在我脑海中徘徊挥之不去，一空闲下来就会在想他在干嘛呢，不知道是不是在忙，早上是在背单词吗，背完有记得吃早饭再去学习吗。中午想的是他要不要休息会不然等会子下午学习会想打瞌睡的等等。</p><p>有时候看我这边的天气的时候，也会点开他那边的天气看一下，想知道和我的是否一样，想知道那个他有没有受凉或者中暑，晚上睡觉时想和他说完晚安一起睡，还有挂电话想等他挂这都是我的小心思呢，觉得这样会很甜！</p><p>再说回自己我这个人其实对要什么不是很清楚，但是等事情来了我就知道我要的是不是他，我的第一天工作总体来说说不上满意也说不上不满意，只要是第一天没啥事情可做我有点闲不住，其次就是这个岗位据我观察目前就是一个话务员的职位，我想做的是资料员所以目前不是特别满意之后跟那个负责人沟通一下叭，但是这不是一个长久的岗位只是一个过度而已，我的志愿目前是考公务员，虽然不知道我能不能考的上但是我会尽自己的努力加油的！</p><p>想安安稳稳的和弟弟生活下去，希望一切顺遂。</p><p>–LC</p>]]></content>
      
      
      <categories>
          
          <category> 晨晨的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 晨晨 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的错误</title>
      <link href="/2021/06/18/python%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/18/python%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>犯了一个错误，以后慢慢改吧！</p><pre class="line-numbers language-none"><code class="language-none">from torch.utils.data import DataLoader, random_splitfrom torchvision import transforms, datasets, modelsimport torch.nn as nnfrom torch.optim import SGDimport torchimport os#print(torch.cuda.is_available())#使用GPUdevice &#x3D; torch.device(&#39;cuda:0&#39;)#自定义数据集data_transform &#x3D; transforms.Compose([    transforms.Resize((224, 224)),    transforms.RandomHorizontalFlip(),    transforms.ToTensor(),    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])full_datasets &#x3D; datasets.ImageFolder(root &#x3D; &#39;.&#x2F;dataset&#39;, transform &#x3D; data_transform)#分为训练集和测试集train_size &#x3D; 1000test_size &#x3D; len(full_datasets) - train_sizetrain_datasets, test_datasets &#x3D; random_split(full_datasets, [train_size, test_size])#载入训练集和测试集batch_size_num &#x3D; 16load_train_datasets &#x3D; DataLoader(dataset &#x3D; train_datasets, batch_size&#x3D; batch_size_num, shuffle &#x3D; True)load_test_datasets &#x3D; DataLoader(dataset &#x3D; test_datasets, batch_size &#x3D; batch_size_num, shuffle &#x3D; True)#使用googlenet算法cnn &#x3D; models.googlenet(pretrained &#x3D; True)#将分类层的参数改为2features &#x3D; cnn.fc.in_featurescnn.fc &#x3D; nn.Linear(features, 2)#模型放入GPU中cnn &#x3D; cnn.to(device)#loss设置和梯度下降法lr_num &#x3D; 0.001loss_function &#x3D; nn.CrossEntropyLoss()optimizer &#x3D; SGD(cnn.parameters(), lr &#x3D; lr_num, momentum &#x3D; 0.9)#scheduler &#x3D; lr_scheduler.StepLR(optimizer &#x3D; optimizer, step_size &#x3D; 100, gamma &#x3D; 0.5)epochs &#x3D; 5for epoch in range(epochs):    loss_value &#x3D; 0.0    #scheduler.step()    #启用 BatchNormalization 和 Dropout    cnn.train()    for i, (datas_train, labels_train) in enumerate(load_train_datasets):        datas_train &#x3D; datas_train.to(device)        labels_train &#x3D; labels_train.to(device)                #优化器优化        optimizer.zero_grad()        outputs &#x3D; cnn(datas_train)        loss &#x3D; loss_function(outputs, labels_train)        loss.backward()        optimizer.step()        loss_value +&#x3D; loss.cpu().item()        correct &#x3D; 0    #每一个batch的loss求和除以batch的数量，就是该次epoch的平均loss    loss_value &#x3D; loss_value * batch_size_num &#x2F; train_size    cnn.eval()    #预测    for datas_test, labels_test in load_test_datasets:        datas_test &#x3D; datas_test.to(device)        labels_test &#x3D; labels_test.to(device)            outputs_test &#x3D; cnn(datas_test)        prediction &#x3D; torch.max(outputs_test, 1)[1]        #同样的计算该次epoch的acc        acc +&#x3D; (torch.sum((prediction &#x3D;&#x3D; labels_test))).cpu().to(torch.float32)    print(&#39;epochs: &#123;&#125; |loss &#x3D; &#123;:.5f&#125; |accurcay &#x3D; &#123;:.5f&#125;&#39;.format(epoch + 1, loss_value, acc &#x2F; test_size))print(&#39;学习率:&#39;, lr_num, &#39;|Epochs:&#39;, epochs, &#39;|batch_size:&#39;, batch_size_num)os.system(&quot;pause&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 进步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的规划</title>
      <link href="/2021/06/18/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92/"/>
      <url>/2021/06/18/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="大学生职业与发展规划书"><a href="#大学生职业与发展规划书" class="headerlink" title="大学生职业与发展规划书"></a>大学生职业与发展规划书</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从我们出生到现在，面临重大的选择的时候我们都要借助他人的帮助进行选择，尤其是一些人生选择时刻，例如中考，选文理科，高考报考专业和自己将要进入的学校，很大一部分都是参照父母或者老师的意见。在进入人生的又一个选择的时候，转身，发现已经没有人在身后要求我们要怎么做，这时候我们只能根据自己的初心，自己的本性来做决定，就业或者是读研都是我们自己的选择，今天借此契机得以认真思考老师为我们所讲授的知识，并且能够为了我职业做一份大致的构画，以此激励自己成为自己想要成为的人。</p><p>以下分为四个部分来介绍我的职业生涯规划，分别是：</p><ul><li><strong>自我分析</strong></li><li><strong>确定职业生涯规划目标</strong></li><li><strong>成功标准</strong></li><li><strong>职业生涯规划书结束语</strong></li></ul><h3 id="一、自我分析"><a href="#一、自我分析" class="headerlink" title="一、自我分析"></a><strong>一、自我分析</strong></h3><h4 id="（一）认识自己的职业性格"><a href="#（一）认识自己的职业性格" class="headerlink" title="（一）认识自己的职业性格"></a>（一）认识自己的职业性格</h4><p>我是一个热情、活泼的男孩，自信而不张扬，正直而不呆板。在个人交流的圈子里，我用真诚对待每一个人，因为我相信那些爱别人的人会得到回报。我很乐意交朋友，希望能从我的朋友那里学到我所没有的东西。坚强的毅力,持之以恒的态度是我的特征,虽有些倔强,但是如果认为自己实在没能力完成任务,我会适时放弃。因为我认为适时放弃也是人生的一大智慧。冲动是我的主要缺点。我缺乏细致和冲动。我做事的时候从不用水拖泥带水，但有时我缺乏考虑。</p><p>我是一个完美主义者，我总是希望我能完美地完成它，尽管知道这是不可能的，但是我会朝着这个方向去做。</p><h4 id="（二）自己的兴趣爱好"><a href="#（二）自己的兴趣爱好" class="headerlink" title="（二）自己的兴趣爱好"></a>（二）自己的兴趣爱好</h4><p>总的来说我的兴趣和爱好还算比较广泛，喜欢读书、听音乐、听音乐、旅行、编程等。我善于表达自己的想法，表达我的意见和看法，我希望我能得到别人的认可。在学习的过程中，我会创造工作和休息相结合的条件，这样我就能更有效率地做事。我爱看传记与诗歌，喜欢与别人分享我在书中看到的知识，有时也会激烈的进行讨论，对于各种不同的价值观，我接受和而不同的思想方式，我认为这样才是一个真实的世界。尽管有时会因为生活的忙碌让自己无法有足够的事件来做自己喜欢的事情，我还是依旧对日子保持尽可能多的新鲜感。</p><h4 id="（三）自己的职业能力"><a href="#（三）自己的职业能力" class="headerlink" title="（三）自己的职业能力"></a>（三）自己的职业能力</h4><p>从某方面来讲，自己的感性能力和理性能力对半来分，只是在不同的场合而已，在做一些重要的事情时，我不会纵容任何一位熟悉的人偷懒或者逃避责任，面对不公正的行为都会坚定的保持自己的立场。在一些个人问题上，我始终保持开放的思想，认为不应该老古董对待变化中的世界，这样是不公平的。相反同时完成任务的时候，我甚至会选择更加具有挑战性的工作，用来提升自己的实力。</p><p>对于工作中的事情，比如自己的专业内的能力，保持中立的评价，只能维持在中等水平，对于一些困难的问题，自己无法得到答案，因为一些其他因素，可能自己也会失败和沮丧，而且面对未来，曾经有过小短时间的彷徨，时而转换了自己的目标，不知道如何发展，但也不至于停滞不前，到了如今，终于明确了自己的目标。</p><h4 id="（四）自我潜能"><a href="#（四）自我潜能" class="headerlink" title="（四）自我潜能"></a>（四）自我潜能</h4><ol><li><p>在自我潜能方面，由于参加了学生会和团委的工作，我发现我的社交能力与组织领导能力均有所提高，也具有一定的吃苦能力；</p></li><li><p>我的相关经历高中时的我曾担任过班长。也帮学校老师完成工作上的事情，在工作能力和勇气方面还有基础，所以面对上台演讲这类任务，只要准备的充分，个人不存在怯场或者过度紧张的表现；</p></li><li><p>个人品质 ：在个人品质方面，我拥有中国人最传统的道德底线与指标，具有不屈不挠的品质，并且对待老人和儿童保持礼貌，公共场合不喧哗，乐于帮助陌生人，尤其是在车站附近或者公交车地铁上帮助他人指引方向；</p></li><li><p>人生格言:幸福生活是留给奋斗过的人。</p></li></ol><p>综上所述，只要我选择了适合自己的，我就会是最好的。我明白我无法决定生命的长短，但我可以控制它的宽度，我无法控制天气，但我可以改变我的心情，明天我无法预测，但我今天可以用，我不能顺利，但我可以做任何事情。努力工作。</p><h3 id="二、确定职业生涯规划目标："><a href="#二、确定职业生涯规划目标：" class="headerlink" title="二、确定职业生涯规划目标："></a><strong>二、确定职业生涯规划目标：</strong></h3><p>通过前面的自我评估，我认为自己是外向并且内敛型的人。善于思考问题不仅是我的爱好，更是我的优势。在未来的学习和生活中，我相信在一次又一次的学习和生活中，我会不断地提高自己，并尽我最大的努力去保留知识。因为机会通常只有几秒钟，而且只对那些有准备的人，我计划我的生活。只要自己能够实现自己的规划，那就能够为自己的生活作保障，并且不后悔自己所做的选择。</p><h4 id="（一）大学期间"><a href="#（一）大学期间" class="headerlink" title="（一）大学期间"></a>（一）大学期间</h4><p>大学即将结束，但并不影响我加强对自己的进一步要求，在这一过程中，积极做好学生的本职工作，并且不偷懒，不懦弱，工作认真，学习努力。</p><ol><li><p>思想政治及道德素质方面：以马列主义、毛泽东思想、邓小平理论、”三个代表”重要思想为指导，树立正确的人生观、价值观、道德观、奋斗观、创业观，坚持正确的人生价值取向。定期提交对党的章程的学习、理解和实践，以及自己的言行和感受，争取通过审查，尽快加入中国共产党，积极参加党的活动。</p></li><li><p>社会实践与志愿服务方面： 适时参加社会调查活动。及时参与安全自愿献血、植树活动、青年志愿服务活动等公益事业。</p></li><li><p>科技学术创新创业方面:扎实学习专业技能,同时,充分利用校内图书馆、校外图书城及网络信息,开拓视野和知识范围,以此,激发、开拓思路,尝试设计开展学术创新、科技创新。</p></li><li><p>文体艺术、社团活动与身心发展方面：积极参加校内外文体艺术活动、校内社团活动、演讲赛、辩论赛、书画比赛等，以此充分锻炼胆量、能力，展示个人风采。积极参加身体锻炼，每周平均锻炼四次。</p></li><li><p>学业方面：平时，无非常特殊情况绝不迟到、请假，更不准旷课，保证好学习听讲时间及学习质量。除了上课时间，我们还应该充分利用课后时间。除去必要适可的身体锻炼、娱乐活动及休闲时间外，均应安心、踏实、专注地攻读职业方向类、专业类书籍和其它类别的实用书籍。学习时要注意预习、听课、复习、综合分析比较、用时比例。知识积累不仅要博大精深，还要专业化、精练，力求毕业时获得优秀毕业生的称号。</p></li><li><p>考研任务繁重，加紧有效的时间做好考研工作的安排，对于自己的前途和理想不迷路，积极实现自己的感兴趣的目标，通识课，数学和英语的学习人中而道远，同时加强自己在专业课方面的技能，不再在懒散中浪费时光。</p></li></ol><h4 id="（二）毕业后的职业生涯规划"><a href="#（二）毕业后的职业生涯规划" class="headerlink" title="（二）毕业后的职业生涯规划"></a>（二）毕业后的职业生涯规划</h4><p>在之前的考研前期准备过程中，我发现自己的目标不在于本专业，或者如果之后读研深造，继续完成本专业的学习会给我带来困扰，于是决定在考研的过程中进行一些小的方向性调整，这些小调整也是经过我个人的认真思考，由本科学习信息安全专业转向研究生的大数据应用技术。这可能是以此小跨考，均属于计算机相关专业，只是在纯粹计算机技术方面，自己有着极大的学科空白，这也源于自己在本科学习过程中的懒惰行为。不过在我的学习过程中发现自己对于计算机硬件的极大抵触性，而且由于d之后的选择的未知性导致我做出了此次选择。并且考研院校也由自己的学校变成了中部地区的中南大学，任重而道远。</p><p>有了明确的目标就应该加紧时间足够努力去冲刺，我会每周给自己制定学习计划，深知学习非一朝一夕之事，但是会是一朝一夕积累得来的经验，面对一些无法解决的难题，我会花费足够多的是时间去增强自己的能力。去中部地区读研首要原因是日后可能在中部地区发展，并且在中部生活。那很大程度需要自己积累人脉，如果报考本校之后极大可能会因为地域的原因导致自己在中部的发展滞后他人。加上在职业招聘平台的定向搜索，发现目前所学专业信息安全虽然有很大的空缺，但在定向搜索的区域，发现人才需要并不很大，这导致了自己之后的求职之路可能艰辛且漫漫。况且由于本人的兴趣问题，在本科学习过程中发现自己对于大数据的兴趣不断提升，在一次课堂上对于老师布置的作业有着格外的兴趣，觉得日后可能会专研此方向。</p><p>以上是短暂的几年的规划，长期的规划是，短期培养能力，进入公司不断提升自己，再在人才的管理方面花费少许精力，使得之后的转型更加便捷，后来便可以进入慢慢晋升的道路。希望漫漫长路，自己能够不辞辛苦得到的果实能有心爱的人一起分享。</p><h3 id="三、成功标准"><a href="#三、成功标准" class="headerlink" title="三、成功标准"></a><strong>三、成功标准</strong></h3><p>我的成功标准：一个人设定一个积极的目标，经过努力，有一个积极的收获，就是成功。每个阶段中只要自己尽心尽力能力也得到了发挥都会自我的提高即使目标没有实现做的事至少自己努力过拼搏过我不会给自己后悔的理由。</p><p>成功之路有许多条，成功的定义也有许多种，只要在理想的指引下，真正做了自己想做的事情，真正实现了自己的人生的价值，就是一种成功，一种超越，就应该为此感到自豪和快乐。</p><h3 id="职业生涯规划书结束语"><a href="#职业生涯规划书结束语" class="headerlink" title="职业生涯规划书结束语"></a><strong>职业生涯规划书结束语</strong></h3><p>身为大学生的我们，应该珍惜这来之不易的学习机会。不是每个人都可以在大学里度过他一生中最美好的日子。人的大学时光一生中也就有一次,不把握好,将来自己一定回追悔莫及。</p><p>有了目标，才有动力。这份大学生职业生涯规划书给了我一个明确的学习目标和职业规划。我将按照上述内容完成自己的学习任务和工作任务，使我的生活更有意义。</p><p>这是我自己的职业生涯规划。有一个好的计划，就有了一个好的开端，其实这不是一件简单的事情，但只要有努力工作，就会有成就。现实是变化的，计划也应要跟着有所改变。我们务必保持清醒的头脑，及时处理我们碰到的困难。每个人都有自己的理想，不过要实现自己的这个理想还是得依靠自己的努力付出才行，无论你的理想有多美好，没有辛勤的汗水都是不可能实现的。天下没有免费的午餐，一个人，要想有所作为，必须拿出勇气，必须付出努力，必须学会去为自己的梦想拼搏，奋斗。成功,不相信眼泪成功,不相信颓废成功不相信幻影,未来,要靠自己去打拼!</p>]]></content>
      
      
      <categories>
          
          <category> 要成功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生涯规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
