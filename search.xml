<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>信息与内容安全</title>
      <link href="/2021/06/25/%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/"/>
      <url>/2021/06/25/%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="信息与内容安全概述"><a href="#信息与内容安全概述" class="headerlink" title="信息与内容安全概述"></a>信息与内容安全概述</h2><ol><li>网络安全的定义</li></ol><p>网络安全是融合<strong>物理域、信息域、认知域和社会域</strong>，以及互联互通的技术基础设施网络为平台，通过无线电、有线电信道传递信号信息，控制实体行为的信息活动空间。<br>2. 信息内容安全的定义</p><ul><li>信息内容安全是信息安全在<strong>法律、政治、道德层次</strong>上的要求，是语义层次的安全。我们要求信息内容是安全的，就是要求信息内容在政治上是健康的， 在法律上是符合国家法律法规的，在道德上是符合中华民族优良的道德规范的。</li><li>广义的信息内容安全既包括信息内容在政治、法律和道德方面的要求，也包括<strong>数据的获取，信息内容的分析与识别，数字图像视频内容安全，多媒体信息隐藏，隐私保护</strong>等诸多方面。</li></ul><ol start="3"><li>人工智能发展进阶</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/1.jpg"></p><ol start="4"><li>人工智能、机器学习和深度学习之间的关系</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/2.jpg"><br>5. 深度学习的3个步骤</p><ul><li>神经网络</li><li>多种方式模拟</li><li>挑选最优方式</li></ul><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/3.jpg"></p><h2 id="网络信息内容的获取与表示"><a href="#网络信息内容的获取与表示" class="headerlink" title="网络信息内容的获取与表示"></a>网络信息内容的获取与表示</h2><ol><li>三原色原理</li></ol><p>光学三原色：红蓝绿。</p><ol start="2"><li>信息内容表示—-视觉信息</li></ol><p>彩色图像—-&gt;灰度图像<br>Y=(R+G+B)/3<br>3. 视频</p><p>视频就是其内容随时间变化的一组动态图像，所以又叫运动图像或活动图像。</p><ol start="4"><li>计算机看的原理：视觉余像</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/4.jpg"><br>5. 视觉特征表达</p><ul><li>颜色特征</li><li>纹理特征</li><li>局部二值特征</li><li>梯度直方图特征</li><li>局部特征</li></ul><ol start="6"><li>文本特征表达</li></ol><p><strong>1-of-N Encoding(One-hot Encoding)</strong><br><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/5.jpg"><br><strong>怎么将文本表达成变量</strong></p><ul><li>词频</li><li>文档频数</li><li>词频-逆文档频数(TF-IDF)</li></ul><p>词频(TF)=某个词在文章中的出现次数/文章的总词数<br>逆文档频率(IDF)=log(语料库的文档总数/(包含该词的文档数+1))<br>TF-IDF = TF * IDF<br>7. 音频特征表达<br><strong>MFCC</strong><br><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/6.jpg"></p><h2 id="深度学习基础（重要）"><a href="#深度学习基础（重要）" class="headerlink" title="深度学习基础（重要）"></a>深度学习基础（重要）</h2><ol><li>反向传播</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/20.jpg"></p><ol start="2"><li>卷积神经网络</li></ol><p><strong>卷积的计算：矩阵对应位置先乘再加。</strong><br><strong>池化：最大池化，最小池化，平均池化。</strong><br><strong>全连接前馈网络</strong><br><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/19.jpg"><br>3. 理解神经网络<br><strong>神经网络可视化</strong><br>GoogLeNet<br>4. 经典神经网络结构<br><strong>LeNet-5</strong><br><strong>AlexNet</strong><br><strong>VGGNet</strong><br><strong>ResNet</strong></p><h2 id="生成对抗网络"><a href="#生成对抗网络" class="headerlink" title="生成对抗网络"></a>生成对抗网络</h2><ol><li>GAN的种类</li></ol><ul><li>GAN</li><li>ACGAN</li><li>BGAN</li><li>CGAN</li><li>DCGAN</li></ul><ol start="2"><li>GAN的基本思想</li></ol><p>向量—-&gt;生成器—-&gt;图像（高维度向量）<br>图像—-&gt;判别器—-&gt;范围（较大的值代表是真，较小的值代表是假）<br>3. 算法</p><ul><li>初始化生成器和判别器</li><li>每轮迭代<ul><li>固定生成器，更新判别器</li><li>固定判别器，更新生成器（生成器试图愚弄判别器）</li></ul></li></ul><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/7.jpg"><br>4. 生成对抗网络原理</p><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/8.jpg"></p><h2 id="在线社交网络分析"><a href="#在线社交网络分析" class="headerlink" title="在线社交网络分析"></a>在线社交网络分析</h2><ol><li>在线社交网络定义</li></ol><p>在线社交网络是一种在信息网络上由社会个体集合及个体之间的连接关系构成的社会性结构，包含<strong>关系结构、网络群体和网络信息</strong>三个要素。<br>2. 在线社交网络的三个维度</p><ul><li>结构</li><li>群体</li><li>信息</li></ul><ol start="3"><li>在线社交网络分析定义</li></ol><p>在线社交网络分析是指从<strong>网络结构、群体互动、信息传播</strong>三个维度，基于信息学、数学、社会学、管理学、心理学等多学科的 融合理论和方法。为理解人类各种社交关系的形成、行为特点分析以及信息传播的规律提供一种可计算的分析方法。</p><ol start="4"><li>社交网络群体行为</li></ol><p><strong>群体极化产生的条件可概括为4点</strong></p><ul><li>必须有激发事件出现</li><li>群体内的个人能看到前人的选择</li><li>群体信息缺乏</li><li>群体有一定同质性</li></ul><ol start="5"><li>在线社交网络信息传播规律</li></ol><ul><li>影响力模型</li><li>传染模型</li></ul><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/9.jpg"></p><h2 id="信息过滤"><a href="#信息过滤" class="headerlink" title="信息过滤"></a>信息过滤</h2><ol><li>信息过滤模型</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/10.jpg"><br>2. 信息过滤VS信息检索</p><ul><li>信息过滤可以看成广义信息检索的一部分。</li><li>信息过滤过滤出不相关的数据，而信息检索选择相关的数据项查询。</li><li>信息检索可以认为面向一次性的查询而使用，而信息过滤是面向用户的长期需求的重复使用。</li><li>信息过滤中信息源动态，用户需求 (采用User Profile来表示)相对静态；信息检索信息源相对静态，用户需求(采用Query来表示)动态变化</li><li>信息过滤用户要对系统有所了解，信息检索不需要。</li><li>信息过滤一般要关注用户建模，涉及用户隐私问题，信息检索不涉及。</li></ul><ol start="3"><li>信息过滤VS信息分类</li></ol><ul><li>信息过滤可以采用信息分类中的分类算法。</li><li>信息分类中的分类通常不会变化。相对而言，信息过滤的用户偏好会动态调整。</li></ul><ol start="4"><li>信息过滤VS信息提取</li></ol><ul><li>信息提取是从无格式数据源中抽取相关字段的过程。比如抽取恐怖事件的时间、地点、人物等字段。</li><li>信息过滤中要关注相关性，信息提取不太关注相关性，而只关注相关的字段。</li></ul><ol start="5"><li>信息过滤分类体系</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/11.jpg"><br>基于感知的过滤，也称为基于内容的过滤。<br>基于社会的过滤，也称为基于协同的过滤。<br>6. AC自动机</p><ul><li>基本思想</li></ul><p>在预处理阶段，AC自动机算法建立了三个函数，<strong>转向函数goto，失效函数failure和输出函数output</strong>，由此构造了一个树型有限自动机。在搜索查找阶段，则通过这三个函数的交叉使用扫描文本，定位出关键字在文本中的所有出现位置。</p><ul><li>特点</li></ul><p>扫描文本时完全不需要回溯，时间复杂度为O(n)，与关键字的数目和长度无关。</p><ul><li>树型有限自动机</li></ul><p>树型有限自动机包含一组状态，每个状态用一个数字代表。状态机读入文本串y中的字符，然后通过产生状态转移或者偶尔发送输出的方式来处理文本。<br>树型有限自动机的行为通过三个函数来指示：<strong>转向函数g，失效函数f和输出函数output。</strong></p><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/12.jpg"></p><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/18.jpg"></p><h2 id="网络舆情分析"><a href="#网络舆情分析" class="headerlink" title="网络舆情分析"></a>网络舆情分析</h2><ol><li>网络舆情概念</li></ol><p>网络舆情：是指以互联网为载体所表达的公众情绪，究其本质是社会情绪在互联网这个可见载体上的公共表达。<br>2. 网络舆情的特征</p><ul><li>自发性</li><li>指向性</li><li>时效性</li><li>情绪性</li><li>片面性</li></ul><ol start="3"><li>网络舆情的演化</li></ol><ul><li>形成期</li><li>高涨期</li><li>波动期</li><li>消退期</li></ul><h2 id="对抗攻击与防御"><a href="#对抗攻击与防御" class="headerlink" title="对抗攻击与防御"></a>对抗攻击与防御</h2><ol><li>攻击想做什么</li></ol><p><strong>愚弄分类器，是分类器不能正常识别并且分类。</strong><br>2. 攻击的损失函数<br><strong>训练—-&gt;无目标攻击—-&gt;目标攻击</strong><br>约束：不能被发现。<br><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/21.jpg"><br>3. 如何攻击<br><strong>梯度下降</strong><br><strong>攻击方法：FGSM（快速梯度符号法）</strong><br>4. 白盒和黑盒</p><p>在前面的攻击中，我们固定网络参数𝜃而寻找最优的输入𝑥。</p><ul><li>为了攻击，我们需要知道网络参数𝜃。这样的攻击叫白盒攻击(White Box Attack)。</li><li>如果我们不将模型公布是不是就安全?绝大多数API不能提供网络参数的。不行，因为黑盒攻击(Black Box Attack)是可能的。</li><li>如果你有目标网络的训练数据，训练一个代理网络(proxy network)，否则，从目标网络获取输入输出对。</li></ul><ol start="5"><li>One Pixel Attack（一像素攻击）VS一般的攻击</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/22.jpg"><br>6. 2种类型的防御</p><ul><li>被动防御(Passive defense)：在不修改模型的情况下找到攻击图像。</li><li>主动防御(Proactive defense): 训练一个对对抗攻击具有鲁棒性的模型。</li></ul><ol start="7"><li>总结</li></ol><p><strong>攻击: 在给定网络参数的情况下，攻击非常容易。</strong></p><ul><li>即使是黑盒攻击也是可能的</li><li>防御：主动防御和被动防御</li><li>未来：自适应攻击和防御</li></ul><h2 id="视觉内容伪造与检测"><a href="#视觉内容伪造与检测" class="headerlink" title="视觉内容伪造与检测"></a>视觉内容伪造与检测</h2><ol><li>Deepfake事件</li></ol><p>图像内容伪造<br>2. 内容伪造方法</p><ul><li>虚假人脸生成</li><li>人脸替换<ul><li>原始Deepfake方法</li><li>基于GAN的Deepfake方法</li></ul></li><li>人脸编辑<ul><li>属性编辑</li><li>表情重演</li><li>跨模态</li></ul></li></ul><ol start="3"><li>检测伪造方法</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/13.jpg"><br><strong>挑战</strong></p><ul><li>单个工具对付各种攻击的效率将越来越低</li><li>深度学习的方法可解释性</li></ul><h2 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h2><ol><li>什么是异常检测</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/15.jpg"><br>给定一组训练数据，我们想找到一个检测输入x与训练数据是否相似的方程。<br>2. 异常检测是二分类分类器<br>3. 如何使用分类器</p><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/16.jpg"></p><ol start="4"><li>检测框架示例</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/17.jpg"></p><ol start="5"><li>评价准则</li></ol><ul><li>准确率</li></ul><p>准确率不是一个好的评价准则，因为一个系统可以有很高的准确率，但是并不影响检测错误。</p><ol start="6"><li>自编码器</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/14.jpg"><br>训练和测试的时候都经过编码、译码的过程，发现测试图片有较大的重组损失的，将其认定为虚假照片。<br>7. 基于生成对抗网络（GAN-Based）</p>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息与内容安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全基础</title>
      <link href="/2021/06/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/06/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ol><li>计算机安全概念<br>计算机安全核心地位的3个关键目标：机密性、完整性、可用性。<br>还有2个：真实性、可计量性。</li><li>OSI安全框架</li></ol><ul><li>安全攻击<ul><li>主动攻击<br>包含数据流的改写和错误数据流的添加。<br>划分4类：假冒、重放、改写消息、拒绝服务。</li><li>被动攻击<br>包含2种主要形式：消息内容泄露和流量攻击。<br>对抗被动攻击的重点是防范而不是检测。</li></ul></li><li>安全服务<ul><li>认证<ul><li>对等实体认证</li><li>数据源认证</li></ul></li><li>访问控制</li><li>数据机密性</li><li>数据完整性</li><li>不可抵赖性<ul><li>源</li><li>目的地</li></ul></li></ul></li><li>安全机制</li></ul><p>安全服务实现了安全策略， 而安全机制实现了安全服务。<br>3. 网络安全模型<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/1.jpg"><br>4. 网络访问安全模型<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/2.jpg"><br><strong>解决有害访问的安全机制</strong></p><ul><li>看门人功能</li><li>屏蔽逻辑</li></ul><h2 id="对称加密和消息机密性"><a href="#对称加密和消息机密性" class="headerlink" title="对称加密和消息机密性"></a>对称加密和消息机密性</h2><ol><li>密码体制<br>密码体制：对称密码体制、公钥密码体制。<br>流密码是属于对称密码体制范畴。</li></ol><p><strong>对称加密方案组成</strong></p><ul><li>明文</li><li>加密算法</li><li>密钥</li><li>密文</li><li>解密算法</li></ul><ol start="2"><li>密码分析</li></ol><ul><li>唯密文（最难破解）</li><li>已知明文</li><li>选择明文</li><li>选择密文</li><li>选择文本（最容易破解）</li></ul><p>加密的两个基本模块是：代替和置换。<br>为了抵抗统计分析破译法，香农给出了设计分组密码体制的两个一般原则: 扩散与混淆。<br>3. Feistel密码结构<br>分组越大表示越高的安全性。<br><strong>DES</strong></p><ul><li>DES属于Feistel结构，明文长度64比特，密钥长度56比特。其中最重要的部分为非线性替换S盒。</li></ul><p><strong>三重DES</strong><br>使用了3次DES算法，过程按照加密-解密-加密的顺序。<br><strong>加密</strong><br>C=E(K3,D(K2,E(K1,P)))<br><strong>解密</strong><br>P=D(K1,E(K2,D(K3,C)))<br>知道过程是反过来的就行。<br>4. AES<br>明文长度是128比特，密钥长度可以是128、192、256比特。<br><strong>每1轮4个不同的步骤</strong></p><ul><li>字节替换（使用S盒，分组逐一替换）</li><li>行移位</li><li>列混淆</li><li>轮密钥加</li></ul><ol start="5"><li>随机数与伪随机数<br>随机数</li></ol><ul><li>随机性、不可预测性。</li></ul><p><strong>伪随机数生成方法</strong></p><ul><li>真随机数发生器</li><li>伪随机数生成器</li><li>伪随机函数</li></ul><p>常用密码算法创造伪随机函数</p><ul><li>对称的分组密码</li><li>不对称的密码</li><li>散列函数和消息认证码</li></ul><ol start="6"><li>流密码和RC4</li></ol><p><strong>设计流密码考虑因素</strong></p><ul><li>加密序列有长周期</li><li>密钥流尽可能接近真随机数的性质</li><li>伪随机数生成器的输出受输入密钥值控制</li></ul><p><strong>RC4算法</strong><br>用1–256个字节(8-2048位)的可变长度密钥初始化一个256个字节的状态向量S，S的元素记为[1],S[2],…,S[255]，从始至终置换后的S包含从0到255的所有8位数。对于加密和解密，字节k是从S的255个元素中按一种系统化的方式选出的一个元素生成的。每生成一个k的值，S中的元素个体就被重新置换一次。<br>7. 分组密码工作模式<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/3.jpg"><br>问：若各中工作模式传输出现错误（错误1个比特），则会影响整体多长？<br>问：5种分组密码的工作模式中，哪几种适合用于流密码中？</p><h2 id="公钥密码和消息认证"><a href="#公钥密码和消息认证" class="headerlink" title="公钥密码和消息认证"></a>公钥密码和消息认证</h2><ol><li>MAC的定义</li></ol><p>一种认证技术利用私钥产生一小块数据，称之为消息认证码。保证了数据的完整性和真实性。还可能保证时效性。<br>很多算法都可以生成MAC，比如DES。<br>MAC的一种替代方法是使用单向散列函数，可接受变长的消息M作为输入，生成定长的消息摘要H（M）作为输出。消息摘要随消息一起以可信的形式传送。<br>2. 安全散列函数<br><strong>要求</strong></p><ul><li>输入长度可变</li><li>输出长度固定</li><li>效率高</li><li>抗原像攻击（单向性）</li><li>抗第二原像攻击（抗弱碰撞性）</li><li>抗碰撞攻击（抗强碰撞性）</li><li>伪随机性</li></ul><ol start="3"><li>SHA安全散列函数</li></ol><p>SHA-1产生160位的Hash值。SHA-2包括SHA-224、SHA-256、SHA-384、SHA-512。SHA基于散列函数MD4。<br>SHA-512的输入消息以1024位的分组为单位进行处理。<br>4. 消息认证码</p><ul><li>HMAC（基于嵌入式散列函数，如SHA-1）</li><li>CMAC（基于分组密码算法）</li></ul><ol start="5"><li>公钥密码原理</li></ol><p><strong>公钥密码方案组成部分</strong></p><ul><li>明文</li><li>密文</li><li>加密算法</li><li>解密算法</li><li>公钥和私钥</li></ul><ol start="6"><li>公钥密码系统的应用</li></ol><ul><li>加密/解密（加解密消息）</li><li>数字签名（用私钥签名，公钥验证签名）</li><li>密钥交换（例如会话密钥）</li></ul><ol start="7"><li>公钥密码RSA和DH</li></ol><p><strong>RSA</strong><br>RSA 的安全基础是大整数分解的困难性，公钥密码体制的安全基础是单向陷门函数。</p><ul><li>密钥生成阶段</li></ul><p>n=p*q（p，q是两个互素的大数）<br>不需要使用到n，需要用到n的欧拉函数t，自己设定的与欧拉函数t互素的数d作为公钥，生成的与此设定的数d互逆的数e为私钥。<br>公钥为（d，n）<br>私钥为（e，n）<br>将p和q销毁</p><ul><li>消息加密和解密阶段</li></ul><p>消息M<br>加密后得到C=M^d(mod n)<br>解密后得到M=C^e(mod n)</p><ul><li>手动计算难点</li></ul><p>大数的模幂运算、求模逆运算。<br><strong>DH</strong><br>存在中间人攻击。第三者分别与两方进行密钥共享，注意这个密钥共享共享的密钥是对称钥。即计算出来的密钥是同一个密钥。之后两方加密和解密都用这个密钥。</p><ul><li>前提</li></ul><p>双方共享一个素数q和a，a &lt; q，q是一个本原根。（a是q的本原根）</p><ul><li>过程</li></ul><p>利用了求离散对数难的原理，素数a作为底，双方用私钥利用模（q）指数生成公钥，传输公钥。<br>双方再用公钥作为底，指数为各自的私钥，计算得到的是双方协商出来的对称钥。</p><ul><li>中间人攻击</li></ul><p>中间人攻击相当于两步DH过程，与A协商一个密钥m，与B协商一个密钥n。同时与A、B交流，达到攻击的效果。<br>8. 数字签名标准DSS</p><h2 id="密钥分配和用户认证"><a href="#密钥分配和用户认证" class="headerlink" title="密钥分配和用户认证"></a>密钥分配和用户认证</h2><ol><li>密钥类型</li></ol><p><strong>基本密钥 Base Key</strong><br>又称初始密钥、用户密钥，是由用户选定或由系统分配给用户，在较长时间（相对于会话密钥）内由一对用户所专用的密钥。<br><strong>会话密钥 Session Key</strong><br>两个通信终端用户在一次通话或交换数据时使用的密钥。<br><strong>密钥加密密钥 Key Encrypting Key</strong><br>用于对会话密钥或文件密钥进行加密时采用的密钥，又称辅助二级密钥(Secondary Key)或密钥传送密钥(key Transport key)。<br><strong>主机主密钥 Host Master Key</strong><br>是对密钥加密密钥进行加密的密钥，存于主机处理器中。<br>在公钥体制下还有公开密钥、秘密密钥、签名密钥之分。<br>2. Kerberos<br>KDC—-密钥分发中心<br><strong>两种票据</strong></p><ul><li>票据授权票据 （Ticket granting ticket）</li></ul><p>票据授权票据由AS发放<br>Tickettgs 在用户登录时向AS申请一次，可多次重复使用</p><ul><li>服务授权票据（Service granting ticket）</li></ul><p>是客户访问应用服务器时需要提供的票据<br>用TicketV表示访问应用服务器V的票据<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/4.jpg"></p><ol start="3"><li>公钥证书X.509</li></ol><p>X.509的核心是与每个用户相关的公钥证书。这些用户证书由一些可行的签证机构（CA）创建并被CA或用户放入目录服务器中。目录服务器本身不创建公钥和证书，仅为用户获得证书提供一种简单的存取方式。<br><strong>证书链</strong><br><strong>证书撤销列表CRL</strong><br><strong>PKIX模型</strong></p><ul><li>端实体</li><li>认证中心</li><li>注册中心</li><li>CRL发放者</li><li>存储库</li></ul><h2 id="网络访问控制和云安全"><a href="#网络访问控制和云安全" class="headerlink" title="网络访问控制和云安全"></a>网络访问控制和云安全</h2><ol><li>网络访问强制措施</li></ol><ul><li>IEEE 802.1X</li></ul><p>这是一个链接层协议，在一个端口被分配IP之前必须强制进行认证。IEEE 802.1X在认证过程中使用了可扩展认证协议。</p><ul><li>虚拟局域网(VLAN)</li></ul><p>由互连的局域网组成的企业网络被逻辑划分为许多VLAN，NAC系统根据安全需求，决定将网络中的哪一个虚拟局域网分配给用户。</p><ul><li>防火墙</li></ul><p>防火墙允许或者拒绝主机与外部的网络数据流，提供一种基于安全策略的网络访问控制。</p><ul><li>动态主机配置协议(DHCP)管理</li></ul><p>DHCP为主机动态分配IP地址，通过IP地址的控制分配，实现网络的访问控制。</p><ul><li>PPPoE认证</li><li>Web portal认证</li></ul><ol start="2"><li>可扩展认证协议结构(EAP)<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/5.jpg"></li><li>基于端口的网络访问控制<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/6.jpg"></li></ol><h2 id="传输层安全"><a href="#传输层安全" class="headerlink" title="传输层安全"></a>传输层安全</h2><ol><li>SSL体系结构<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/7.jpg"><br>SSL协议中重要概念：SSL会话、SSL连接。<br>SSL中定义的3个较高层协议分别是：握手协议、修改密码规范协议、警报协议。</li></ol><ul><li>SSL记录协议</li></ul><p>对各种更高层协议提供基本的安全服务。<br>保证了机密性和完整性。<br>步骤：数据分块、压缩、加MAC、加密、添加SSL记录头、作为1个TCP分组发送。</p><ul><li>SSL握手协议</li></ul><p><strong>4步握手</strong></p><ul><li>客户端请求并且相互协商协议版本和随机数等信息</li><li>服务器发送证书</li><li>客户端发送证书</li><li>更改密码套件生成主密钥</li></ul><ol start="2"><li>HTTPS</li></ol><p><strong>通信为以下元素加密</strong></p><ul><li>要求文件的URL</li><li>文件的内容</li><li>浏览器表单的内容</li><li>浏览器与服务器的Cookie</li><li>HTTP报头的内容</li></ul><p><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/8.jpg"></p><h2 id="无线网络安全"><a href="#无线网络安全" class="headerlink" title="无线网络安全"></a>无线网络安全</h2><ol><li>无线网络安全常见威胁<br>偶然连接、恶意连接、身份盗窃、中间人攻击、拒绝服务、网络注入、Ad hoc网络。</li><li>802.11网络组成与架构模型<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/9.jpg"></li><li>IEEE 802.11i操作阶段</li></ol><p><strong>分为5个阶段</strong></p><ul><li>发现</li><li>认证</li><li>密钥管理</li><li>数据传输</li><li>终止连接</li></ul><p><strong>所有阶段</strong><br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/10.jpg"><br><strong>发现和认证阶段</strong><br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/11.jpg"><br><strong>密钥管理阶段</strong><br>在密钥管理阶段期间，各种加密密钥被生成并分发给各个STA。<br>有两种类型的密钥</p><ul><li>用于STA和AP间通信的成对密钥</li><li>用于组播通信的群组密钥</li></ul><p><strong>各种密钥</strong></p><ul><li>AAAK，根密钥，最初始的密钥，认证、计数、授权并且生成其他密钥功能。</li><li>PSK，预分享密钥，生成PMK。</li><li>PMK，成对主密钥，生成PTK。</li><li>GMK，群组主密钥，生成GTK。</li><li>PTK，成对临时密钥，加密。</li><li>GTK，群组成对密钥，加密。</li><li>TK，临时密钥，单播用户信息加密。</li><li>MIC，消息完整码密钥，保证完整性。</li><li>WEP，有线等效保密密钥，交换密钥。</li></ul><p><strong>成对密钥发布阶段</strong><br>被称为4次握手，4个组成部分如下。<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/12.jpg"></p><ul><li>访问接入点—-&gt;站点，发送MAC地址和1个随机数</li><li>站点—-&gt;访问接入点，站点用2个随机数和MAC地址和成对组密钥生成成对临时密钥，包含消息完整性字段。令访问接入点也生成此承兑临时密钥。</li><li>访问接入点—-&gt;站点，访问接入点使用密钥重发第一次相同内容，包含消息完整性字段。</li><li>站点—-&gt;访问接入点，确认消息，包含消息完整性字段。</li></ul><h2 id="电子邮件安全"><a href="#电子邮件安全" class="headerlink" title="电子邮件安全"></a>电子邮件安全</h2><ol><li>PGP的操作<br>认证（数字签名）、保密（消息加密）、压缩和电子邮件兼容性。</li><li>S/MIME<br>基于RSA的安全性基础。</li><li>PGP为什么在压缩前生成签名？<br>顺序：签名—-压缩—-加密<br>压缩对邮件传输或存储都有节省空间的好处。</li></ol><p><strong>签名后压缩的原因</strong><br>不需要为检验签名而保留压缩版本的消息。<br>为了检验而再做压缩不能保证一致性，压缩算法的不同实现版本可能会产生不同的结果。<br><strong>压缩之后再做加密的原因</strong><br>压缩后的消息其冗余小，增加密码分析的难度<br>若先加密，则压缩难以见效<br><strong>E-mail兼容性</strong><br>PGP处理后的消息，部分或者全部是加密后的消息流，为任意的8位字节。某些邮件系统只允许ASC字符，所以PGP提供了转换到ASC格式的功能。采用了Radix-64转换方案。</p><h2 id="IP安全"><a href="#IP安全" class="headerlink" title="IP安全"></a>IP安全</h2><ol><li>IP协议<br>IP是TCP/IP协议族中至关重要的组成部分, 但它提供的是一种不可靠、无连接的的数据报传输服务。</li></ol><ul><li>不可靠（unreliable)</li></ul><p>不能保证一个IP数据报成功地到达其目的地。错误处理办法：扔掉该数据报，向其发送着传送一个ICMP消息。</p><ul><li>无连接（connectionless）</li></ul><p>IP并不维护关于连续发送的数据报的任何状态信息。每个数据报单独处理，在传送过程中可能出现错序。<br>2. IPsec的原理<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/13.jpg"><br>3. IPSec的规范<br>IPSec包括三种功能：认证、机密性和密钥管理。<br><strong>包含以下多种规范（未详细列出）</strong></p><ul><li>认证报头(AH) RFC4302：用于提供消息认证的扩展头。 </li><li>封装安全载荷(ESP) RFC4303 ：ESP包含了一个封装的用来提供加密或者机密和认证的结合。</li><li>因特网密钥交换(IKE) RFC4306：用于IPSec的密钥交换方案。</li></ul><ol start="4"><li>传输模式和隧道模式</li></ol><ul><li>传输模式Transport Mode</li></ul><p>用于两个主机之间的端到端通信，传输模式为上层协议提供保护，保护扩充到IP分组的有效载荷，用于两个主机之间的端到端通信。传输方式ESP对有效载荷加密并可选认证；AH认证IP有效载荷和IP首部的选中部分。</p><ul><li>隧道模式Tunnel Mode</li></ul><p>适用于当SA的一端或两端是安全网关，隧道模式对整个IP分组提供保护。原始的分组加安全域被当做一个新IP分组的载荷，并拥有一个新的外部IP报头, 通过“隧道”从IP网络的一端传输到另一端。适用于当SA的一端或两端是安全网关, 例如实现了IPSec的防火墙或路由器的情况，防火墙之后的网络主机可以不用实现IPSec而参加安全通信。<br>隧道模式中, ESP加密和认证(可选)整个内部IP包, AH认证整个内部IP包和外部IP报头中的选中部分。<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/14.jpg"><br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/15.jpg"><br>5. 安全关联<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/16.jpg"><br>安全关联SA是在发送者和的接收者之间的一种单向关系，如果需要一个对等的关系用于双向的安全交换，就要用两个安全关联。提供给一个SA的安全服务用于AH或ESP，但不能同时用于两者。<br><strong>安全关联由三个参数标识</strong></p><ul><li>安全参数索引SPI：SPI加载在AH和ESP的首部，使接收系统能够选择SA来处理接收的分组。</li><li>IP目的地址：SA的目的地址，端用户或网络。</li><li>安全协议标识符：标识该关联是否AH或ESP安全关联。</li></ul><ol start="6"><li>IPSec ESP Header格式</li></ol><p><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/17.jpg"><br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/18.jpg"><br><strong>填充域有如下几个作用</strong></p><ul><li>填充域用于把明文(包括载荷数据、填充、填充长度、邻接报头域)扩展到需要的长度 (如分组加密要求明文是分组长度的整数倍) 。</li><li>ESP格式要求填充长度和邻接报头域为32比特的字，密文也是32比特的整数倍，填充域用来保证这样的排列。</li><li>增加额外的填充能隐藏载荷的实际长度，从而提供部分流量的保密。</li></ul><ol start="7"><li>窗口与重放攻击检测</li></ol><ul><li>重复的接收经过认证的IP包可能会以某种方式中断服务或产生一些不希望出现的结果。</li><li>序列号能阻止重放攻击。每建立一个新的SA，发送方把序列号计数器的初始值设为0，每次在SA上发送一个包，则发送方增加计数器的值。</li><li>IP提供无连接且不可靠的分组投递服务，不能保证分组能按照顺序传输，也不能保证无丢失。IPSec规定接收方应该实现一个大小为W的窗口(W的默认值为64)。</li></ul><p><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/19.jpg"><br>8. 密钥确定协议<br>基于DH交换<br>DH交换的缺陷</p><ul><li>没有身份标识和认证</li><li>易受中间人攻击</li><li>算法的模指运算代价高，易受阻塞Clogging攻击（Clogging攻击是一类面对公钥密码系统的DoS攻击）。</li></ul><p><strong>IKE密钥确定的特性</strong></p><ul><li>使用Cookie机制来抵御阻塞Clogging攻击</li><li>允许协商公共参数，即DH中的公共参数</li><li>使用随机数防止重放攻击</li><li>可以交换DH的公钥值</li><li>对DH交换进行认证，防止中间人攻击</li></ul><p><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/20.jpg"><br>9. IPSec的优点和路由应用<br><strong>IPSec的优点</strong></p><ul><li>提供强大的安全性，应用于防火墙和路由器。</li><li>IPSec在传输层以下，对所有的应用透明。</li><li>IPSec对终端用户透明。</li><li>必要时可以为单个用户提供安全性。</li></ul><p><strong>路由选择应用，IPSec保证</strong></p><ul><li>路由器的通告(新的路由器通告它的存在)来自被认可的路由器。</li><li>邻站通告(一个路由器尝试与另一个路由选择域的一台路由器建立或维护邻站关系)来自被认可的路由器。</li><li>重定向报文来自于发送包的初始路由器。</li><li>路由选择更新不会被假造。</li></ul><h2 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h2><ol><li>病毒</li></ol><p><strong>组成部分（1或多或重复包含）</strong></p><ul><li>感染机制</li><li>触发</li><li>载荷</li></ul><p><strong>生命周期</strong></p><ul><li>休眠阶段</li><li>传播阶段</li><li>触发阶段</li><li>执行阶段</li></ul><p><strong>按目标分类</strong></p><ul><li>引导扇区感染病毒</li><li>文件感染病毒</li><li>宏病毒</li><li>混合体病毒</li></ul><p><strong>按隐藏策略分类</strong></p><ul><li>加密病毒</li><li>隐形飞机式病毒</li><li>多态病毒</li><li>变形病毒</li></ul><p><strong>分布式拒绝服务攻击DDoS</strong></p><h2 id="入侵者"><a href="#入侵者" class="headerlink" title="入侵者"></a>入侵者</h2><ol><li>常用的入侵检测方法</li></ol><p>统计异常检测，定义通常的或期望的行为。</p><ul><li>阈值检测</li><li>基于行为曲线</li></ul><p>基于规则的检测，定义合适的行为。</p><ul><li>异常检测</li><li>渗透检测</li></ul><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><ol><li>防火墙类型</li></ol><ul><li>包过滤防火墙</li><li>状态检测防火墙</li><li>链路层网关</li><li>应用层网关</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全高级内存访问</title>
      <link href="/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/"/>
      <url>/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全SQL注入</title>
      <link href="/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入和数组越界访问漏洞"><a href="#SQL注入和数组越界访问漏洞" class="headerlink" title="SQL注入和数组越界访问漏洞"></a>SQL注入和数组越界访问漏洞</h2><p><strong>大致内容</strong></p><ul><li>SQL注入漏洞<ul><li>实现原理及后果</li><li>现有的相关应对措施</li></ul></li><li>数组越界访问漏洞</li></ul><h3 id="实现原理及后果"><a href="#实现原理及后果" class="headerlink" title="实现原理及后果"></a>实现原理及后果</h3><p><strong>B/S（浏览器和服务器）架构</strong></p><p>B/S是WEB兴起后的一种网络架构模式</p><ul><li>采用浏览器统一了客户端，将系统功能实现的核心部分集中到服务器上。</li><li>客户端使用浏览器，通过Web Server与数据库进行数据交互。</li></ul><p>B/S架构优势—-瘦客户端，胖服务端</p><ul><li>将系统实现的核心部分集中在服务端，简化系统的开发。</li><li>客户端载荷降低，减轻系统维护和升级成本。</li></ul><p><strong>数据库与SQL简介</strong></p><p>数据库：大型软件系统的关键基础设施。</p><ol><li>有结构的、有组织（集成）的、可共享的统一管理的数据集合。</li><li>具有尽可能小的冗余度、较高的数据独立性和易扩展性。</li><li>应用场景 — Web后台数据、企业级联机事务处理。</li></ol><p>结构化查询语言(Structured Query Language, SQL)，用户存取数据、查询、更新和管理关系数据库系统。注意：独立于数据库本身、硬件、网络以及操作系统。</p><ol><li>特殊目的编程语言。</li><li>数据库查询+程序设计语言。</li><li>屏蔽底层细节的高级数据库操作语言。</li></ol><p>SQL语言核心结构。</p><ul><li>做什么事情。</li><li>要找哪个对象做。</li><li>怎么做这件事情。</li><li>怎么找到这个对象（约束条件）。</li></ul><p>SQL注入出现原因：程序员的水平及经验也参差不齐，相当大一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。</p><p>SQL注入过程：把SQL命令插入到web表单递交或输入域名或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。<strong>SQL命令伪装成数据。</strong></p><p><strong>SQL注入原理</strong><br><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8SQL%E6%B3%A8%E5%85%A5/1.jpg"></p><p><strong>SQL注入过程</strong></p><ol><li>寻找可能存在SQL注入漏洞的链接</li><li>测试该网站是否有SQL注入漏洞</li><li>猜管理员帐号表</li><li>猜测管理员表中的字段</li><li>猜测用户名和密码的长度</li><li>猜测用户名</li><li>猜测密码</li></ol><p><strong>初级的注入</strong></p><ul><li>判断是否存在注入</li></ul><p>对于可能存在SQL注入的动态网页，只要该网页带有参数且此网页访问了数据库，则有可能存在注入<br><code>http://xxx.xxx.xxx/abcd.php?id=XX</code><br>给参数赋值单引号，查看页面变化（单引号不匹配而报错，则表示执行了SQL）<br><code>http://xxx.xxx.xxx/abcd.php?id=XX’</code><br>若未报错，可能做了单引号过滤，使用判断语句进行注入测试（SQL注入漏洞分为数字型和字符型）</p><ul><li>数字型漏洞</li></ul><p><code>http://xxx.xxx.xxx/abcd.php?id=XX</code><br>若XX为数字类型，例如页码、ID等，存在注入时则为数字类型的注入。<br>给参数赋值为and 1=1，页面正常。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX and 1=1</code><br>接着给参数赋值为and 1=2，页面报错。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX and 1=2</code></p><ul><li>字符型漏洞</li></ul><p><code>http://xxx.xxx.xxx/abcd.php?id=XX</code><br>若XX为字符串，注入测试需使用单引号来闭合。<br>给参数赋值为and 1=1，页面正常。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX ‘and ’1‘=’1</code><br>接着给参数赋值为and 1=2，页面报错。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX ‘and ’1‘=’2</code></p><ul><li>猜管理员账号表</li></ul><p>在末尾加上：<code>and exists (select * from admin)</code><br>我们的意思是猜测他有个admin表段。页面返回正常，我们猜对了。当然也可能错误返回，这时就要看猜测的本事了。</p><ul><li>猜测管理员表表中的字段</li></ul><p>我们再来猜他的管理员表中是否有一个ID段，在末尾加上：<code>and exists (select id from admin)</code><br>页面返回正常,说明他的admin表中有个id的字段。<br>我们继续： <code>and exists (select username from admin)</code>。这里的意思是看看他的admin表中是否有username字段，页面返回正常,说明在admin中有一个username字段<br>我们继续猜他放密码的字段： <code>and exists (select password from admin)</code>。返回正常的页面,说明他的admin表中有个password字段。<br>到此可以知道admin表中至少有如下三个字段：id,username,password，这种命名方式与普通程序员的命名方法一致。</p><ul><li>猜测用户名和密码的长度</li></ul><p>首先猜他的管理员的id值： <code>and exists (select id from admin where id=1)</code>，意思是看看他的admin表中是否有一个id=1的值。<br>返回了正常的页面,说明我们猜对了。<br>接着猜ID为1的用户名长度： <code>and exists (select id from admin where len(username)&lt;6 and id=1)</code><br>这里我们猜他的管理员长度小于6,返回了正常的页面,还好,名字不是太长,我们一个个来实验好了。<br><code>and exists (select id from admin where len(username)=5 and id=1)</code>，返回了正常的页面,说明用户名的长度我们已经猜出了为5。<br>用同样的方法，我们猜出了密码的长度是10，要添加的语句是：<code> and exists (select id from admin where len(password)=10 and id=1)</code><br>到此，用户名和密码的长度都已经猜出来了，下面要做的是猜出它们的每一位分别是多少。<br>方法是在后面加上： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,1,1))&lt;100)</code><br>我们这里做的意思是，猜测他的用户名的第一个字的ascii码值小于100。</p><blockquote><p>其中，asc函数的功能是将字符转换成ASCII码，mid函数的功能是截取username字段值的字串，从第1位开始，截取的长度是1</p></blockquote><p>返回了正常页面，说明的确如我们所料，接着： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,1,1))&lt;50)</code><br>返回错误信息，说明：50&lt;=第一个字的ascii码值&lt;100。接下来，我们用折半查找的思想： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,1,1))&lt;75)</code><br>接下来我们猜测第二位： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,2,1))&lt;100)</code><br>用折半查找的思想，采取上述方式，很快就能找到密码。</p><blockquote><p>注意：网站上密码多是以杂凑值处理，需要专用的哈希函数破解。尽管哈希函数是单向的，然而用户的密码是有限长度的，可以预先存储计算匹配，而非反向破解。</p></blockquote><p><strong>高级的注入</strong></p><ol><li>大小写绕过。</li><li>双写绕过。</li><li>等效语言表达绕过。</li><li>科学计数法、括号绕过。</li><li>浮点数、括号绕过。</li><li>内联注释绕过。</li><li>子查询、join联合绕过。</li></ol><h3 id="现有相关应对措施"><a href="#现有相关应对措施" class="headerlink" title="现有相关应对措施"></a>现有相关应对措施</h3><ol><li>对SQL请求的动态解析树，采用SQL引擎预先对SQL语法进行分析，生成该SQL语句的语法树。对客户端输入的参数中的SQL命令解析为字符串字面值参数，进而不会执行。</li><li>对用户输入的参数进行严格的匹配以及过滤。</li><li>设置用户操作数据库的权限。</li></ol><h2 id="数组越界访问漏洞"><a href="#数组越界访问漏洞" class="headerlink" title="数组越界访问漏洞"></a>数组越界访问漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>溢出与越界不完全相等</p><ul><li>数组越界分为读/写两种情况，而溢出漏洞属于越界写入。</li><li>一些溢出漏洞的本质是数组越界。</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#123;      int x[10];        cout &lt;&lt; x[10]; &#125;&#x2F;&#x2F;直观的数组越界可以在编译时较容易地检查出来，但是……&#123;      int i, x[10];        &#x2F;&#x2F;对i进行算术运算      cout &lt;&lt; x[i]; &#125;&#x2F;&#x2F;用法是允许的，存在越界的可能，但编译器无法指出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="举例与分析"><a href="#举例与分析" class="headerlink" title="举例与分析"></a>举例与分析</h3><p>CVE-2014-0160“OpenSSL数组越界访问漏洞”(Heartbleed心脏滴血) 。</p><p>成因–处理heartbeat response时没有检查包长度的合法性，直接分配相应大小的内存。</p><p>TLS和DTLS在处理心跳请求包逻辑中，从堆空间上申请的内存大小由type、length、request的数据长度和payload四个部分组成，其中type,length,payload字段分为占1byte，2byte，16byte，所以response的数据总是比request的多出来19byte。</p><p>length（心跳包的长度）是用户可控的，而payload（也是储存长度）是也是用户可控的，那么当payload长度大于心跳包的长度，那么就可以读取内存中心跳包后面的数据了。</p><p><strong>C语言的数组越界为何难以检查？</strong></p><ul><li>性能⟺安全。</li><li>指向数组元素的指针和数组本身是完全独立的。</li><li>指针运算的可行性。</li><li>用指针表示范围，不仅需要指针本身存在且可用，还需要指针指向的内存可用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全其他溢出漏洞</title>
      <link href="/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="本文大致内容"><a href="#本文大致内容" class="headerlink" title="本文大致内容"></a>本文大致内容</h2><ul><li>整数溢出<ul><li>数值计算的基本原理</li><li>整数溢出及其可能的后果</li></ul></li><li>格式化字符串漏洞<ul><li>类printf函数簇实现原理</li><li>格式化字符串攻击原理及潜在后果</li></ul></li></ul><p>在这一章节似乎只是在计算机中实现，更偏向于怎么将漏洞在计算机上实现，对于一些常见的编程中出现的漏洞，也似乎不能叫出现的漏洞吧，应该是编译器的漏洞。对一些边界问题的规定是否规范，还是任由编译器自己决定，决定着这个漏洞是否可以被实现。通过打印出一些内存中具体的值，为后来的其他溢出做了铺垫。</p><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><h3 id="数值计算的基本原理"><a href="#数值计算的基本原理" class="headerlink" title="数值计算的基本原理"></a>数值计算的基本原理</h3><ul><li>整数的表示</li></ul><p><strong>64位</strong><br>类型：short（16bit）、int（32bit）、long（64bit），8字节<br>带符号：-2^（n-1)-2^（n-1）-1、不带符号：0-2^n-1<br><strong>32位</strong><br>long（32bit），4字节</p><ul><li>带符号整数格式中的补码</li></ul><ol><li>带符号的正护士统一用补码表示（正整数和负整数都是）。</li><li>意义：符号位和数值域统一，加法和减法统一。</li></ol><blockquote><p>对于正数原码、反码以及补码是其本身。负数的原码是其本身，反码是对原码除符号位之外的各位取反，补码则是反码加1。</p></blockquote><ul><li>整数的加减法</li></ul><p><strong>CF是无符号数溢出标志，OF是有符号数溢出标志。</strong></p><p>CF/OF=1，则表示计算结果溢出。</p><ol><li>CF的判断<ul><li>加法<br>十进制角度，如果两个无符号数相加，结果大于阈值，则CF=1，否则CF=0。<br>二进制角度，如果两无符号数相加，最高位向前进位，则CF=1，否则CF=0。</li><li>减法<br>十进制角度，两无符号数相减，减数大于被减数，则CF=1，否则CF=0。<br>二进制角度，如果两无符号数相减，最高位向前有借位，则CF=1，否则CF=0。</li></ul></li><li>OF判断<ul><li>加法<br>十进制角度，两有符号数相加，结果不在范围内，则OF=1，否则OF=0。<br>二进制角度，如果两有符号数同号，得到的结果异号，则OF=1，否则OF=0。</li><li>减法<br>十进制角度，两有符号数相减，结果不在范围内，则OF=1，否则OF=0。<br>二进制角度，如果两有符号数异号，得到的结果与被减数符号相反，则OF=1，否则OF=0。</li></ul></li></ol><p>整数溢出的例子中需要注意</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int atoi(const char *nptr);&#x2F;&#x2F;用法：将字符串里的数字字符转化为整形数。返回整形值。&#x2F;&#x2F;注意：转化时跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(&#39;&#x2F;0&#39;)才结束转换，并将结果返回。void *memcpy(void *destin, const void *src, size_t n);&#x2F;*由src指向地址为起始地址的连续n个字节的数据复制到以destin指向地址为起始地址的空间内。　　函数返回一个指向destin的指针。说明    1. source和destin所指内存区域不能重叠，函数返回指向destin的指针。    2. 与strcpy相比，memcpy并不是遇到&#39;\0&#39;就结束，而是一定会拷贝完n个字节。    3. 如果目标数组destin本身已有数据，执行memcpy（）后，将覆盖原有数据（最多覆盖n）。如果要追加数据，则每次执行memcpy后，要将目标数组地址增加到你要追加数据的地址。注意，source和destin都不一定是数组，任意的可读写的空间均可。*&#x2F;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在C语言中的表示</li></ul><p>在C/C++语言中，char变量为一个字节，8位，signed char表示的范围：-128-127【-128在内存中的二进制表示为1000 0000，127在内存中的表示为0111 1111】；unsign char表示的范围：0000 0000-1111 1111，即0-255；<br>默认是signed还是unsigned取决于编译器。</p><p>因为size是字节数，所以要*8，这样unsigned取模刚好是对它的表示范围取模。<br>左边是无符号型全1，是最大值+1=0<br>右边是0111 1111 = 127，也是最大值，+1=128，实际上溢出了，超出了表示范围。1 000 0000=-128</p><blockquote><p>C语言中的表示不是很一样，如果取无符号，则只表示之前范围的非负数的那部分。</p></blockquote><h3 id="整数溢出及其可能的后果"><a href="#整数溢出及其可能的后果" class="headerlink" title="整数溢出及其可能的后果"></a>整数溢出及其可能的后果</h3><p><strong>例如</strong></p><ol><li>举例1</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/1.jpg"></p><p>若将MAX_LEN设置为32767，同时，假设buf的值总为2，实际结果：当len==32766时，line 6 造成len的值变为-32768，程序死循环</p><p>32767是signed short上限，len=32766时，+2溢出，如果不规定处理方式则变为最小值-32768。程序无法跳出循环。</p><ol start="2"><li>举例2</li></ol><p>又如：abs(-2147483648) &lt; 0</p><p>函数abs的功能 — 对于输入参数为正，返回其本身，否则返回其相反数。<br>然而，对于-2147483648（int类型的最大负数值），函数abs返回的是其本身。</p><p>可见，整数溢出至少可能产生以下一些后果</p><ul><li>产生逻辑谬误，造成程序在执行中卡死或者出错</li><li>为后续的缓冲区溢出充当引信</li></ul><p>一些防范整数溢出的编程习惯</p><ul><li>对整数溢出的检查必须出现在可能溢出的位置之前，否则就有可能不起作用</li><li>注意类型强制转换（或者说，注意指针的使用）</li><li>同等地重视上溢和下溢，两者都需要预先检查</li></ul><p><strong>整数溢出的防护</strong></p><ol><li>IntScope — 检测整数溢出本身</li></ol><p>利用符号执行、动态污点跟踪等分析运行时数据流，寻找异常。</p><ol start="2"><li>IntPatch — 检测并修复后续的缓冲区溢出漏洞</li></ol><p>针对：整数溢出到缓冲区溢出（IO2BO）</p><h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><h3 id="类printf函数簇实现原理"><a href="#类printf函数簇实现原理" class="headerlink" title="类printf函数簇实现原理"></a>类printf函数簇实现原理</h3><ul><li>类printf函数簇的第一个可利用点：参数不匹配时难以发现。<ul><li>printf()是一个参数长度可变函数，仅仅看参数数量无法发现问题。</li><li>为了查出不匹配，编译器需要了解printf()的运行机制，然而编译器通常不做这类分析。</li><li>若格式字符串在程序运行期间生成(如用户输入)，则编译器无法发现不匹配。</li></ul></li></ul><h3 id="格式化字符串攻击原理及潜在后果"><a href="#格式化字符串攻击原理及潜在后果" class="headerlink" title="格式化字符串攻击原理及潜在后果"></a>格式化字符串攻击原理及潜在后果</h3><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2.jpg"></p><blockquote><p>当printf在输出格式化字符串的时候，会维护一个内部指针，当printf逐步将格式化字符串的字符打印到屏幕，当遇到%的时候，printf会期望它后面跟着一个格式字符串，因此会递增内部字符串以抓取格式控制符的输入值。这就是问题所在，printf无法知道栈上是否放置了正确数量的变量供它操作，如果没有足够的变量可供操作，而指针按正常情况下递增，就会产生越界访问。甚至由于%n的问题，可导致任意地址读写。</p></blockquote><ol><li>举例1</li></ol><p>如果让str=“%x”，则会发生什么？<br>%x是printf规定的一种输出类型，unsigned int，输出无符号16进制数。<br>结果：通过构造异常字符串，可以实现对程序栈结构的任意读取。</p><p><strong>为什么程序员写的是错误的呢？</strong></p><p>他传入了一个他想要逐字打印的字符串。实际上该字符串被printf函数解释为一个格式化字符（formatstring），printf就会根据该字符串来决定printf函数中省略号参数表中参数的格式和类型，如果这个程序员想要打印的字符串中刚好有“%d”,“%x”之类的格式化字符，那么一个变量的参数值就从堆栈中取出。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char* argv[])&#123;    if(argc !&#x3D; 2)        return 0;    printf(argv[1]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当./a.out “hello world”时一切正常，但是当./a.out “%x”时，就会有莫名其妙的数字被打印出来了。因为后面没跟参数，但printf以为后面有个参数，就会把当前堆栈对应的4字节（应该是高地址）以%x打印。通过特定设计，可以打印特定位置内存信息。<br>很明显，攻击者至少可以通过打印出堆栈中的这些值来偷看程序的内存。但是有些事情就不那么明显了，这个简单的错误允许向运行中程序的内存里写入任意值。</p><ol start="2"><li>举例2</li></ol><p><strong>更进一步</strong><br>%s，printf规定的另一种输出类型，char <em>/wchar_t</em>，输出字符串。</p><p>结果：通过构造异常字符串，还有可能实现对任意内存的（大面积）读取。</p><ol start="3"><li>举例3</li></ol><p><strong>再进一步</strong><br>%n，特殊printf输出类型，int*，将此前已输出的串长度写入指针所指位置。</p><p>结果：通过构造异常字符串，可以实现对任意内存的任意改写。</p><blockquote><p>%n:该符号前输入的字符数量会被存储到对应的参数中去。<br>int i; printf (“12345%n”, &amp;i);<br>数字5（%n前的字符数量）将会被写入i中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对晨晨说的话</title>
      <link href="/2021/06/22/%E5%AF%B9%E6%99%A8%E6%99%A8%E8%AF%B4%E7%9A%84%E8%AF%9D/"/>
      <url>/2021/06/22/%E5%AF%B9%E6%99%A8%E6%99%A8%E8%AF%B4%E7%9A%84%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="对晨晨说的话"><a href="#对晨晨说的话" class="headerlink" title="对晨晨说的话"></a>对晨晨说的话</h2><p><img src="../%E5%AF%B9%E6%99%A8%E6%99%A8%E8%AF%B4%E7%9A%84%E8%AF%9D/1.JPG"></p><p>今天是星期三，我很想知道什么事情，这件事情在我的心里憋了很久，我一直提醒自己不要忘记，不要记起，不要回想。不要去追寻。在多少年前，我是过着什么样的生活，在大概十年前，我知道自己在做什么吗，十年前的这个时候，我可能现在早已经进入梦乡，或者是在做其他的事，具体什么事，也是在幻想生活的改变。</p><p>我期待明天，我期待每天的早晨，现在不是如此吗？现在也是，在早上我是不会有任何烦心的事情，我总能想起梦里的事情，梦里我怎么做，怎么说，我梦到了谁，昨晚梦到了谁，今晚我要梦到谁，做怎么样的梦。我的生活是由无数人的生活促就的，他们做的改变，他们的呼吸，他们的欢笑和哭泣，让远方的我有了如此的生活。</p><p>在这一天，我遇到了这个人。我很认定我自己是对的，因为我心动了，在自己经历过如此多的事情之后，我发现自己喜欢的是什么，讨厌的是什么，不屑的是什么，甚至追求的是什么都已经模糊。在我遇到她之前，我早上是八点十分起床的，我早上吃肉夹馍，中午吃快餐，晚上吃烩面。我有时还会打游戏，在虚拟世界里沉迷一小刻，我便开始幻想，为什么我自己不能有自己的幸福。为什么爱情要如此令我受折磨，在一个孤独的冰冷的世界遨游，我要归往的是哪里，我是会要做一个没有经历过青春的人吗？还是要在无数个不愿意睁开眼，知道世界上的某个角落的某个人仍旧孤孤零零寻找我的味道呢？</p><p>我遇到你，我想要对你说过许多话，但有很多是不足够表达我的心的。我想，我听，我思考。我最爱这样子，这样就可以慢慢规划以后的事情，我拒绝做一个精英，我想不断陪伴一个人成长。不是要面谈生意，我不愿牺牲爱情，我不愿在自己的心中磨灭对爱情的美妙的想象。你喜欢什么颜色，爱吃什么食物，喜欢冬天还是夏天，今天的天气如何，你的心情如何，有没有不舒服，有没有饿到肚子，有没有吃了不对胃口的饮食。这些问题困扰着我，我也不会知道，我不知道今天你在一棵树前停留许久，是在想，是在听，还是在发呆。想要一个人的依靠，想要一个人的照顾。</p><p>我不希望自己成为他人的迷茫点，在无数个夜晚，我都是怎么在想你，想你做什么，我怕失去你，也怕错过你。我总该想，要多和你说几句话，说有趣的事，吃可口的食物，吹凉飒的晚风，走在平常的街道，听夏日的蝉鸣。我又想在午后，吃完最后一口米饭，一起将碗筷收进厨房，看到时间还早，我不过是想靠你近一点，用纸巾擦去你嘴巴上的油。</p><p>生活如此，我梦想，幻想，还是想象。你存在吗？我不敢相信自己，我从来不会觉得自己有着足够的幸运遇到你，我知道过无数的人，无数的事。知道他们过着怎么样的生活，却没曾想终于愿意沉下心来为自己做打算，为我们的之后做安排。</p><p>夜没深，我也没有醒，希望我在梦里不会醒，你也不会从梦里走出来，在梦里，我很喜欢。喜欢你的发梢，你的脸庞，你的呼吸，你的心跳，最喜欢你无处不在的可爱。</p><p>你要吃掉我的心吗，晨晨，生活是美好的，就算眼前困惑。你要相信我。</p><p>–SS</p>]]></content>
      
      
      <categories>
          
          <category> 胜胜的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胜胜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全期末</title>
      <link href="/2021/06/22/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/"/>
      <url>/2021/06/22/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/</url>
      
        <content type="html"><![CDATA[<p>这篇文章也是花了很久的时间才能说半抄半理解结束，其中有一些内容到现在还是不清楚，但愿自己慢慢思考。</p><span id="more"></span><ul><li><p>堆的构造与维护原理</p><ul><li>堆的场地和块</li><li>隐式/显示链表与堆的维护</li></ul></li><li><p>堆溢出</p><ul><li>linux系统典型堆溢出原理</li><li>现有应对策略和技术</li></ul></li></ul><h2 id="堆的工作原理"><a href="#堆的工作原理" class="headerlink" title="堆的工作原理"></a>堆的工作原理</h2><ul><li>堆与栈的区别<ul><li>栈：硬件支持；存储数据+控制流信息。</li><li>堆：操作系统的库函数支持；存储数据。</li></ul></li></ul><p>堆的创建和维护通过malloc实现。</p><p>堆内存是移动[Program Break]的位置产生的（通过brk中断），实际产生的堆比申请的堆还要大，这个连续的堆区域被称为[arena]。被主进程创建的，因此称为[main arena]。接下来申请会分配到这个arena的多余申请空间的部分。分配完毕后，它可以通过继续移动Program Break的位置扩容。扩容后，top chunk的大小也随之调整，将这块新增的空间圈进去。相应地，arena也可以在top chunk过大时缩小。top chunk是一个 arena位于最顶层的chunk。</p><blockquote><p>注意：非直接返还给系统，由malloc库函数管理，将其添加到bin。当用户再次调用，首先从bins查找是否有满足的，若没有才向操作系统申请新的堆空间，以提高整个效率。</p></blockquote><p>堆在栈创造之前便存在了，是程序运行便开始调用栈，而堆需要使用malloc函数才行。</p><h3 id="堆内存的建立"><a href="#堆内存的建立" class="headerlink" title="堆内存的建立"></a>堆内存的建立</h3><p>堆内存是使用mmap系统调用产生的，而非同主线程一样使用sbrk系统调用。用户请求的空间中略大（申请100kb，但实际映射到地址空间的有1Mb），只有132kb空间有读写权限，并成为该线程的堆内存。称之为[thread areana]。</p><p>当用户请求超过128kb，并且arena中没有足够的空间来满足用户的请求，内存将通过mmap系统调用分配（不再是sbrk），而不论请求是发自main arena还是thread arena。</p><h3 id="堆的工作原理-1"><a href="#堆的工作原理-1" class="headerlink" title="堆的工作原理"></a>堆的工作原理</h3><p>arena数量</p><ul><li>32位系统=2*内核数+1</li><li>64位系统=8*内核数+1</li></ul><p>单核32位系统，运行多线程程序—-1个主线程+3个用户线程，malloc如何令4个线程共享3个arena？</p><p>主线程分配主arena,线程1、2分别分配arena，那么线程3需要重复使用已分配好的arena.glibc malloc循环遍历所有可用的场地，如果lock成功（该 场地当前对应的线程并未使用堆内存），则将该场地供线程3使用。</p><p>如果没有找到可用的area，则将线程3的malloc操作阻塞，直到找到可用的为止。</p><ul><li><p>在[glibc malloc]中主要有3种数据结构：</p><ul><li><p>heap_info ——Heap Header—— 一个 thread arena 可以维护多个堆。每个堆都有自己的堆 Header（注：也即头部元数据）。什么时候 Thread Arena 会维护多个堆呢？ 一般情况下，每个 thread arena 都只维护一个堆，但是当这个堆的空间耗尽时，新的堆（而非连续内存区域）就会被 mmap 到这个 aerna 里；</p></li><li><p>malloc_state ——Arena header—— 一个 thread arena 可以维护多个堆，这些堆另外共享同一个 arena header。Arena header 描述的信息包括：bins、top chunk、last remainder chunk 等；</p></li><li><p>malloc_chunk ——Chunk header—— 根据用户请求，每个堆被分为若干 chunk。每个 chunk 都有自己的 chunk header；</p></li></ul></li></ul><p>Main arena 无需维护多个堆，因此也无需heap_info。当空间耗尽时，与 thread arena 不同，main arena 可以通过 sbrk 拓展堆段，直至堆段[碰]到内存映射段；</p><p>与 thread arena 不同，main arena 的 arena header 不是保存在通过 sbrk 申请的堆段里，而是作为一个全局变量，可以在 libc.so 的数据段中找到。</p><p>thread arena只含有一个malloc_state(即arena header)，却有两个heap_info(即heap header)。由于两个heap segments是通过mmap分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，libc malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了malloc_state，这样就构成了一个单链表，方便后续管理。</p><p><strong>堆块进化史</strong></p><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/1.jpg"></p><p>左上是allocated chunk格式，左下是free chunk格式，右边是整个堆内存组织成一个连续的已分配或未分配chunk序列。</p><p>堆内存中要求每个chunk的大小必须为8的整数倍，因此chunk size的后3位是无效的，为了充分利用内存，堆管理器将这3个比特位用作chunk的标志位，典型的就是将第0比特位用于标记该chunk是否已经被分配。</p><blockquote><p>这样的设计很巧妙，因为我们只要获取了一个指向chunk size的指针，就能知道该chunk的大小，即确定了此chunk的边界，且利用chunk size的第0比特位还能知道该chunk是否已经分配，这样就成功地将各个chunk区分开来。注意在allocated chunk中padding部分主要是用于地址对齐的(也可用于对付外部碎片)，即让整个chunk的大小为8的整数倍。</p></blockquote><p>上面的这种结构就叫做<strong>隐式链表</strong>。该链表隐式地由每个chunk的size字段链接起来，在进行分配操作的时候，堆内存管理器可以通过遍历整个堆内存的chunk，分析每个chunk的size字段，进而找到合适的chunk。</p><p>缺点：这种隐式链表效率其实是相当低的，特别是在内存回收方面，它难以进行相邻多个free chunk的合并操作。我们知道，如果只对free chunk进行分割，而不进行合并的话，就会产生大量小的、无法继续使用的内部碎片，直至整个内存消耗殆尽。因此堆内存管理器设计了带边界标记的chunk合并技术。</p><p><strong>出现问题</strong></p><ol><li>向前合并</li></ol><p>假设我们要释放的chunk为P，它紧邻的前一个chunk为FD，紧邻的后一个chunk为BK，且BK与FD都为free chunk。将P于BK合并在一起是很容易的，因为可以通过P的size字段轻松定位到BK的开始位置，进而获取BK的size等等，但是将P于FD合并却很难，我们必须从头遍历整个堆，找到FD，然后加以合并，这就意味着每次进行chunk释放操作消耗的时间与堆的大小成线性关系。</p><p>为了解决这个问题，Knuth提出了一种聪明而通用的技术——边界标记。</p><p>Knuth在每个chunk的最后添加了一个脚部(Footer)，它就是该chunk 头部(header)的一个副本，我们称之为边界标记。显然每个chunk的脚部都在其相邻的下一个chunk的头部的前4个字节处。通过这个脚部，堆内存管理器就可以很容易地得到前一个chunk的起始位置和分配状态，进而加以合并了。</p><p>但是，边界标记同时带来了一个问题：它要求每个块都包含一个头部和脚部，如果应用程序频繁地进行小内存的申请和释放操作的话(比如1，2个字节)，就会造成很大的性能损耗。</p><p>同时，考虑到只有在对free chunk进行合并的时候才需要脚部，也就是说对于allocated chunk而言它并不需要脚部，因此我们可以对这个脚部加以优化——将前一个chunk的已分配/空闲标记位存储在当前chunk的size字段的第1，或2比特位上，这样如果我们通过当前chunk的size字段知道了前一个chunk为free chunk，<em>那么就可得出结论</em>：当前chunk地址之前的4个字节为前一个free chunk的脚部，我们可以通过该脚部获取前一个chunk的起始位置；如果当前chunk的size字段的标记位表明前一个chunk是allocated chunk的话，<em>那么就可得出另一个结论</em>：前一个chunk没有脚部，即当前chunk地址之前的4个字节为前一个allocated chunk的payload或padding的最后部分。</p><ol start="2"><li>多线程时标志位不够</li></ol><p>随着技术的发展，特别是堆内存管理器添加对多线程的支持，前述的chunk格式已经难以满足需求，比如，我们需要标志位来标记当前chunk是否属于非主线程即thread arena，以及该chunk由mmap得来还是通过brk实现等等。但此时chunk size只剩下一个比特位未使用了，怎么办呢？这需要对chunk格式进行大手术！</p><p>首先思考：是否有必要同时保存当前chunk和前一个chunk的已分配/空闲标记位？</p><p>答案是否定的，因为我们只需要保存前一个chunk的分配标志位就可以了，至于当前chunk的分配标志位，可以通过查询下一个chunk的size字段得到。那么size字段中剩下的两个比特位就可以用于满足多线程的标志需求了。</p><p>PREV_INUSE(P): 表示前一个chunk是否为allocated。<br>IS_MMAPPED(M)：表示当前chunk是否是通过mmap系统调用产生的。  NON_MAIN_ARENA(N)：表示当前chunk是否是thread arena。</p><p><strong>当前的堆块的形态</strong></p><p>没必要保存chunk size的副本，也就是说Footer的作用并不大，但是如果前一个chunk是free的话，在合并的时候我们又需要知道前一个chunk的大小，怎么办呢？</p><p>将Footer从尾部移到首部，同时其不再保存当前chunk的size，而是前一个free chunk的size不就行了。同样的，为了提高内存利用率，如果前一个chunk是allocated chunk的话，这个Footer就作为allocated chunk的payload或padding的一部分。</p><p><strong>隐式/显式（bin）链表结构</strong></p><p>该结构体通过每个chunk的prev_size和size构成了隐式链表，而后续的fd, bk等指针并不是作用于隐式链表的，而是用于加快内存分配和释放效率的显示链表bin(还记得bin么？用于记录同一类型free chunk的链表)，并且这些指针跟prev_size一样只在free chunk中存在。</p><p><strong>bin的分类</strong></p><ul><li>fastbinsY，16-80字节，记录所有fastbins的数组。</li><li>bins，记录除了fastbins之外所有的bins。<ul><li>unsorted bin。</li><li>small bin。</li><li>large bin。</li></ul></li></ul><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/2.jpg"></p><p>在所有的 bins 中，fast bins 路径享有最快的内存分配及释放速度。</p><p><strong>堆的工作原理</strong></p><p>每个 fast bin 都维护着一条 free chunk 的单链表，采用单链表是因为链表中所有 chunk 的大小相等，增删 chunk 发生在链表顶端即可；—— LIFO。添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。需要注意的是，为了实现LIFO算法，fastbinsY数组中每个fastbin元素均指向了该链表的rear end（尾结点），而尾结点通过其fd指针指向前一个结点，依次类推。<br>chunk 大小：8 字节递增。 fast bins 由一系列所维护 chunk 大小以 8 字节递增的 bins 组成。也即，fast bin[0] 维护大小为 16 字节的 chunk、fast bin[1] 维护大小为 24 字节的 chunk。依此类推……  指定 fast bin 中所有 chunk 大小相同；</p><p>在 malloc 初始化过程中，最大的 fast bin 的大小被设置为 64 而非 80 字节。因为默认情况下只有大小 16 ~ 64 的 chunk 被归为 fast chunk 。</p><p>无需合并 —— 两个相邻 chunk 不会被合并。虽然这可能会加剧内存碎片化，但也大大加速了内存释放的速度！</p><p>malloc(fast chunk) ：初始情况下 fast chunck 最大尺寸以及 fast bin 相应数据结构均未初始化，因此即使用户请求内存大小落在 fast chunk 相应区间，服务用户请求的也将是 small bin 路径而非 fast bin 路径；初始化后，将在计算 fast bin 索引后检索相应 bin；</p><p>相应 bin 中被检索的第一个 chunk 将被摘除并返回给用户。<br>free(fast chunk) ：计算 fast bin 索引以索引相应 bin；free 掉的 chunk 将被添加到上述 bin 的顶端。  </p><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中(为什么，在什么情况下会发生这种事情呢？详情见后文)，系统就将这些chunk添加到unsorted bin中。为什么要这么做呢？这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。</p><p><strong>Unsorted bin的特性如下</strong></p><ul><li><p>unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。</p></li><li><p>Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。这就是前言说的特例了，不过特例并非仅仅这一个，后文会介绍。</p></li><li><p>小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。每个small bin也是一个由对应free chunk组成的循环双链表。第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 61*8 = 508字节。</p></li><li><p>大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。</p></li><li><p>鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行从大到小的排列：最大的chunk放在链表的front end，最小的chunk放在rear end。</p></li></ul><p><strong>top chunk</strong></p><p>当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。该chunk并不属于任何bin，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。</p><p>如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：</p><ol><li>用户请求的chunk；</li><li>剩余的部分成为新的top chunk。<br>否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</li></ol><p><strong>顶块的作用：救火队员</strong></p><ol><li>不属于任何bin</li><li>当前所有空闲块(无论那种bin)全都尺寸不合时，由顶块应急</li><li>顶块比请求尺寸大 — 分割供给使用，剩余部分为新顶块</li><li>顶块比请求尺寸小 — 全堆无适合块，扩展堆/分配新堆</li></ol><p>对于Last remainder chunk，我们主要有两个问题：<br>1)它是怎么产生的；<br>2)它的作用是什么？</p><ul><li><p>当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。</p></li><li><p>此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</p></li></ul><h4 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h4><p><strong>与栈溢出的区别</strong></p><ol><li>堆溢出方向=堆增长方向。</li><li>首先破坏（虚拟地址意义上的）下一个堆块的构造。</li></ol><p><strong>linux典型的堆溢出利用方式</strong></p><ol><li>攻击fast bin。</li><li>攻击unlink。</li></ol><p><strong>攻击fastbin</strong></p><p>攻击原理是在chunk被分配时，从队尾删除，并将当前chunk的fd写入到fastbin。下次分配就分配这个fd对应地址的chunk。<br>具体用法是chunk0写入溢出，覆盖相邻的chunk1的fd。当chunk1被分配时，被篡改的chunk1中的fd被写入fastbin。在chunk2被分配时就分配攻击者想攻击的内存地址。因为被分配的内存空间可写，攻击者因此实现对指定地址写入数据的目的。</p><p>可能是在内存有连续空间时，快速分配释放，使得buf0 buf1空间连续，这样在写入溢出时，就可以覆盖到相邻的未分配的buf1里面的fd地址。</p><p><strong>攻击unlink</strong></p><p>一旦涉及到free内存（非mmaped的chunks的回收机制），那么就意味着有新的chunk由allocated状态变成了free状态，此时glibc malloc就需要进行合并操作——向前以及(或)向后合并。</p><p>将previous free chunk合并到当前free chunk，叫做向后合并；将后面的free chunk合并到当前free chunk，叫做向前合并</p><p><strong>向后合并操作</strong></p><p>首先检测previous chunk是否为free，这可以通过检测当前free chunk的PREV_INUSE(P)比特位获得。</p><p><strong>如果为free的话，那么就进行向后合并</strong></p><p>将前一个chunk占用的内存合并到当前chunk。<br>修改指向当前chunk的指针，改为指向前一个chunk。<br>使用unlink宏，将前一个free chunk从双向循环链表中移除。</p><p><strong>向前合并操作</strong></p><p>首先检测next chunk是否为free。那么如何检测呢？通过查询next chunk之后的chunk的PREV_INUSE (P)。</p><p><strong>即可如果为free的话，那么就进行向前合并</strong></p><p>本质是将next chunk从双向链表中移除，合并到当前chunk。<br>在glibc malloc中，会将合并后的chunk(或因为不满足合并条件而没合并的chunk) ，放到unsorted bin中。</p><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/3.jpg"></p><ol><li><p>在代码3中存在一个堆溢出漏洞：如果用户输入的argv1的大小比first变量的666字节更大的话，那么输入的数据就有可能覆盖掉下一个chunk的chunk header——这可以导致任意代码执行。而攻击的核心思路就是利用glibc malloc的unlink机制。</p></li><li><p>程序在[4]处调用free(first)后，执行：</p><ul><li><p>向后合并：鉴于first的前一个chunk非free的，所以不会发生向后合并操作。</p></li><li><p>向前合并：先判断后一个chunk是否为free，若free则合并。</p></li></ul></li><li><p>prev_size =一个偶数，这样其PREV_INUSE位就是0了，即表示前一个chunk为free。</p><ul><li>size = -4</li><li>fd = free函数的got表地址address – 12；(简称为“free addr – 12”)。</li><li>bk = shellcode的地址Bitmap Flipping攻击。</li></ul></li><li><p>  nextchunk + nextsize计算得到指向下下一个chunk的指针，然后判断下下个chunk的size的PREV_INUSE标记位（判断是否为free）。    + nextsize=-4,进而导致next chunk的prev_size字段看做是next-next chunk的size字段。    + next chunk的prev_size字段设置为了一个偶数，低位为0进而判断next chunk为free。</p></li></ol><p><strong>注意</strong></p><p>既然next chunk为free，那么就需要进行向前合并，所以就会调用unlink(nextchunk, bck, fwd)函数。真正的重点就是这个unlink函数！</p><p><strong>上一段中描述的”前一个“与”后一个“chunk，是指的由chunk的prev_size与size字段隐式连接的chunk，即它们在内存中是连续、相邻的！而不是通过chunk中的fd与bk字段组成的bin(双向链表)中的前一个与后一个chunk，切记！</strong></p><p>fd = free函数的got表地址address – 12；(简称为“free addr – 12”)<br>bk = shellcode的地址。</p><p>调用unlink(nextchunk, bck, fwd)合并。</p><p>FD = nextchunk-&gt;fd = free addr– 12;<br>BK = nextchunk-&gt;bk = shellcode起始地址;<br>BK赋值给FD-&gt;bk，即（free add– 12）-&gt;bk = shellcode起始地址；<br>FD赋值给BK-&gt;fd，即(shellcode起始地址)-&gt;fd = free addr– 12;</p><p>最终，free add指向shellcode add,当程序在代码[5]处再次执行free的时候，就会转而执行shellcode。达到攻击效果</p><p><strong>Windows堆溢出攻击的主要形式</strong></p><ul><li>利用向量化异常处理（VEH）</li><li>利用系统默认异常处理函数（UEF）</li><li>Heap spray</li><li>Bitmap Flipping攻击</li><li>Bitmap XOR攻击</li><li>Heap Cache攻击</li></ul><h4 id="堆溢出的防御"><a href="#堆溢出的防御" class="headerlink" title="堆溢出的防御"></a>堆溢出的防御</h4><p>相比栈溢出，针对堆溢出的防御措施更易实用化<br>堆依靠系统库实现其维护，故堆保护=系统库升级</p><p><strong>针对unlink的保护</strong></p><ol><li><p>Double Free检测:该机制不允许释放已经处于free状态的chunk。因此，当攻击者将second chunk的size设置为-4的时候，就意味着该size的PREV_INUSE位为0，也就是说second chunk之前的first chunk(我们需要free的chunk)已经处于free状态，那么再free就报出double free错误。</p></li><li><p>next size非法检测: 检测next size是否在8到当前arena的整个系统内存大小之间。因此当检测到next size为-4的时候，就会报出invalid next size错误。</p></li><li><p>双链表冲突检测:执行unlink操作的时候检测链表中前一个chunk的fd与后一个chunk的bk是否都指向当前需要unlink的chunk。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等待爱情</title>
      <link href="/2021/06/20/CC%E7%9A%84%E5%BF%AB%E4%B9%90/"/>
      <url>/2021/06/20/CC%E7%9A%84%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<h2 id="晨晨的快乐"><a href="#晨晨的快乐" class="headerlink" title="晨晨的快乐"></a>晨晨的快乐</h2><p><img src="../CC%E7%9A%84%E5%BF%AB%E4%B9%90/0.JPG"></p><p> 这一周和弟弟的联系感觉没有上一周多了，原因呢大概就是我忙着找工作弟弟忙着准备期末考试呢，不知道为什么每次到这种环节我的心底就会泛起涟漪，想着我们的联系变少了以后会不会更少了，想着我们的联系变少了感情会不会没有之前热烈了，想着我们的联系变少了会不会没有以前那么亲密无间了，这些想法一直在我脑海中徘徊挥之不去，一空闲下来就会在想他在干嘛呢，不知道是不是在忙，早上是在背单词吗，背完有记得吃早饭再去学习吗。中午想的是他要不要休息会不然等会子下午学习会想打瞌睡的等等。</p><p>有时候看我这边的天气的时候，也会点开他那边的天气看一下，想知道和我的是否一样，想知道那个他有没有受凉或者中暑，晚上睡觉时想和他说完晚安一起睡，还有挂电话想等他挂这都是我的小心思呢，觉得这样会很甜！</p><p>再说回自己我这个人其实对要什么不是很清楚，但是等事情来了我就知道我要的是不是他，我的第一天工作总体来说说不上满意也说不上不满意，只要是第一天没啥事情可做我有点闲不住，其次就是这个岗位据我观察目前就是一个话务员的职位，我想做的是资料员所以目前不是特别满意之后跟那个负责人沟通一下叭，但是这不是一个长久的岗位只是一个过度而已，我的志愿目前是考公务员，虽然不知道我能不能考的上但是我会尽自己的努力加油的！</p><p>想安安稳稳的和弟弟生活下去，希望一切顺遂。</p><p>–LC</p>]]></content>
      
      
      <categories>
          
          <category> 晨晨的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 晨晨 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个小实验</title>
      <link href="/2021/06/18/python%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/18/python%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>犯了一个错误，以后慢慢改吧！</p><pre class="line-numbers language-none"><code class="language-none">from torch.utils.data import DataLoader, random_splitfrom torchvision import transforms, datasets, modelsimport torch.nn as nnfrom torch.optim import SGDimport torchimport os#print(torch.cuda.is_available())#使用GPUdevice &#x3D; torch.device(&#39;cuda:0&#39;)#自定义数据集data_transform &#x3D; transforms.Compose([    transforms.Resize((224, 224)),    transforms.RandomHorizontalFlip(),    transforms.ToTensor(),    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])full_datasets &#x3D; datasets.ImageFolder(root &#x3D; &#39;.&#x2F;dataset&#39;, transform &#x3D; data_transform)#分为训练集和测试集train_size &#x3D; 1000test_size &#x3D; len(full_datasets) - train_sizetrain_datasets, test_datasets &#x3D; random_split(full_datasets, [train_size, test_size])#载入训练集和测试集batch_size_num &#x3D; 16load_train_datasets &#x3D; DataLoader(dataset &#x3D; train_datasets, batch_size&#x3D; batch_size_num, shuffle &#x3D; True)load_test_datasets &#x3D; DataLoader(dataset &#x3D; test_datasets, batch_size &#x3D; batch_size_num, shuffle &#x3D; True)#使用googlenet算法cnn &#x3D; models.googlenet(pretrained &#x3D; True)#将分类层的参数改为2features &#x3D; cnn.fc.in_featurescnn.fc &#x3D; nn.Linear(features, 2)#模型放入GPU中cnn &#x3D; cnn.to(device)#loss设置和梯度下降法lr_num &#x3D; 0.001loss_function &#x3D; nn.CrossEntropyLoss()optimizer &#x3D; SGD(cnn.parameters(), lr &#x3D; lr_num, momentum &#x3D; 0.9)#scheduler &#x3D; lr_scheduler.StepLR(optimizer &#x3D; optimizer, step_size &#x3D; 100, gamma &#x3D; 0.5)epochs &#x3D; 5for epoch in range(epochs):    loss_value &#x3D; 0.0    #scheduler.step()    #启用 BatchNormalization 和 Dropout    cnn.train()    for i, (datas_train, labels_train) in enumerate(load_train_datasets):        datas_train &#x3D; datas_train.to(device)        labels_train &#x3D; labels_train.to(device)                #优化器优化        optimizer.zero_grad()        outputs &#x3D; cnn(datas_train)        loss &#x3D; loss_function(outputs, labels_train)        loss.backward()        optimizer.step()        loss_value +&#x3D; loss.cpu().item()        correct &#x3D; 0    #每一个batch的loss求和除以batch的数量，就是该次epoch的平均loss    loss_value &#x3D; loss_value * batch_size_num &#x2F; train_size    cnn.eval()    #预测    acc &#x3D; 0    for datas_test, labels_test in load_test_datasets:        datas_test &#x3D; datas_test.to(device)        labels_test &#x3D; labels_test.to(device)            outputs_test &#x3D; cnn(datas_test)        prediction &#x3D; torch.max(outputs_test, 1)[1]        #同样的计算该次epoch的acc        acc +&#x3D; (torch.sum((prediction &#x3D;&#x3D; labels_test))).cpu().to(torch.float32)    print(&#39;epochs: &#123;&#125; |loss &#x3D; &#123;:.5f&#125; |accurcay &#x3D; &#123;:.5f&#125;&#39;.format(epoch + 1, loss_value, acc &#x2F; test_size))print(&#39;学习率:&#39;, lr_num, &#39;|Epochs:&#39;, epochs, &#39;|batch_size:&#39;, batch_size_num)os.system(&quot;pause&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 进步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的规划</title>
      <link href="/2021/06/18/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92/"/>
      <url>/2021/06/18/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="大学生职业与发展规划书"><a href="#大学生职业与发展规划书" class="headerlink" title="大学生职业与发展规划书"></a>大学生职业与发展规划书</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从我们出生到现在，面临重大的选择的时候我们都要借助他人的帮助进行选择，尤其是一些人生选择时刻，例如中考，选文理科，高考报考专业和自己将要进入的学校，很大一部分都是参照父母或者老师的意见。在进入人生的又一个选择的时候，转身，发现已经没有人在身后要求我们要怎么做，这时候我们只能根据自己的初心，自己的本性来做决定，就业或者是读研都是我们自己的选择，今天借此契机得以认真思考老师为我们所讲授的知识，并且能够为了我职业做一份大致的构画，以此激励自己成为自己想要成为的人。</p><p>以下分为四个部分来介绍我的职业生涯规划，分别是：</p><ul><li><strong>自我分析</strong></li><li><strong>确定职业生涯规划目标</strong></li><li><strong>成功标准</strong></li><li><strong>职业生涯规划书结束语</strong></li></ul><h3 id="一、自我分析"><a href="#一、自我分析" class="headerlink" title="一、自我分析"></a><strong>一、自我分析</strong></h3><h4 id="（一）认识自己的职业性格"><a href="#（一）认识自己的职业性格" class="headerlink" title="（一）认识自己的职业性格"></a>（一）认识自己的职业性格</h4><p>我是一个热情、活泼的男孩，自信而不张扬，正直而不呆板。在个人交流的圈子里，我用真诚对待每一个人，因为我相信那些爱别人的人会得到回报。我很乐意交朋友，希望能从我的朋友那里学到我所没有的东西。坚强的毅力,持之以恒的态度是我的特征,虽有些倔强,但是如果认为自己实在没能力完成任务,我会适时放弃。因为我认为适时放弃也是人生的一大智慧。冲动是我的主要缺点。我缺乏细致和冲动。我做事的时候从不用水拖泥带水，但有时我缺乏考虑。</p><p>我是一个完美主义者，我总是希望我能完美地完成它，尽管知道这是不可能的，但是我会朝着这个方向去做。</p><h4 id="（二）自己的兴趣爱好"><a href="#（二）自己的兴趣爱好" class="headerlink" title="（二）自己的兴趣爱好"></a>（二）自己的兴趣爱好</h4><p>总的来说我的兴趣和爱好还算比较广泛，喜欢读书、听音乐、听音乐、旅行、编程等。我善于表达自己的想法，表达我的意见和看法，我希望我能得到别人的认可。在学习的过程中，我会创造工作和休息相结合的条件，这样我就能更有效率地做事。我爱看传记与诗歌，喜欢与别人分享我在书中看到的知识，有时也会激烈的进行讨论，对于各种不同的价值观，我接受和而不同的思想方式，我认为这样才是一个真实的世界。尽管有时会因为生活的忙碌让自己无法有足够的事件来做自己喜欢的事情，我还是依旧对日子保持尽可能多的新鲜感。</p><h4 id="（三）自己的职业能力"><a href="#（三）自己的职业能力" class="headerlink" title="（三）自己的职业能力"></a>（三）自己的职业能力</h4><p>从某方面来讲，自己的感性能力和理性能力对半来分，只是在不同的场合而已，在做一些重要的事情时，我不会纵容任何一位熟悉的人偷懒或者逃避责任，面对不公正的行为都会坚定的保持自己的立场。在一些个人问题上，我始终保持开放的思想，认为不应该老古董对待变化中的世界，这样是不公平的。相反同时完成任务的时候，我甚至会选择更加具有挑战性的工作，用来提升自己的实力。</p><p>对于工作中的事情，比如自己的专业内的能力，保持中立的评价，只能维持在中等水平，对于一些困难的问题，自己无法得到答案，因为一些其他因素，可能自己也会失败和沮丧，而且面对未来，曾经有过小短时间的彷徨，时而转换了自己的目标，不知道如何发展，但也不至于停滞不前，到了如今，终于明确了自己的目标。</p><h4 id="（四）自我潜能"><a href="#（四）自我潜能" class="headerlink" title="（四）自我潜能"></a>（四）自我潜能</h4><ol><li><p>在自我潜能方面，由于参加了学生会和团委的工作，我发现我的社交能力与组织领导能力均有所提高，也具有一定的吃苦能力；</p></li><li><p>我的相关经历高中时的我曾担任过班长。也帮学校老师完成工作上的事情，在工作能力和勇气方面还有基础，所以面对上台演讲这类任务，只要准备的充分，个人不存在怯场或者过度紧张的表现；</p></li><li><p>个人品质 ：在个人品质方面，我拥有中国人最传统的道德底线与指标，具有不屈不挠的品质，并且对待老人和儿童保持礼貌，公共场合不喧哗，乐于帮助陌生人，尤其是在车站附近或者公交车地铁上帮助他人指引方向；</p></li><li><p>人生格言:幸福生活是留给奋斗过的人。</p></li></ol><p>综上所述，只要我选择了适合自己的，我就会是最好的。我明白我无法决定生命的长短，但我可以控制它的宽度，我无法控制天气，但我可以改变我的心情，明天我无法预测，但我今天可以用，我不能顺利，但我可以做任何事情。努力工作。</p><h3 id="二、确定职业生涯规划目标："><a href="#二、确定职业生涯规划目标：" class="headerlink" title="二、确定职业生涯规划目标："></a><strong>二、确定职业生涯规划目标：</strong></h3><p>通过前面的自我评估，我认为自己是外向并且内敛型的人。善于思考问题不仅是我的爱好，更是我的优势。在未来的学习和生活中，我相信在一次又一次的学习和生活中，我会不断地提高自己，并尽我最大的努力去保留知识。因为机会通常只有几秒钟，而且只对那些有准备的人，我计划我的生活。只要自己能够实现自己的规划，那就能够为自己的生活作保障，并且不后悔自己所做的选择。</p><h4 id="（一）大学期间"><a href="#（一）大学期间" class="headerlink" title="（一）大学期间"></a>（一）大学期间</h4><p>大学即将结束，但并不影响我加强对自己的进一步要求，在这一过程中，积极做好学生的本职工作，并且不偷懒，不懦弱，工作认真，学习努力。</p><ol><li><p>思想政治及道德素质方面：以马列主义、毛泽东思想、邓小平理论、”三个代表”重要思想为指导，树立正确的人生观、价值观、道德观、奋斗观、创业观，坚持正确的人生价值取向。定期提交对党的章程的学习、理解和实践，以及自己的言行和感受，争取通过审查，尽快加入中国共产党，积极参加党的活动。</p></li><li><p>社会实践与志愿服务方面： 适时参加社会调查活动。及时参与安全自愿献血、植树活动、青年志愿服务活动等公益事业。</p></li><li><p>科技学术创新创业方面:扎实学习专业技能,同时,充分利用校内图书馆、校外图书城及网络信息,开拓视野和知识范围,以此,激发、开拓思路,尝试设计开展学术创新、科技创新。</p></li><li><p>文体艺术、社团活动与身心发展方面：积极参加校内外文体艺术活动、校内社团活动、演讲赛、辩论赛、书画比赛等，以此充分锻炼胆量、能力，展示个人风采。积极参加身体锻炼，每周平均锻炼四次。</p></li><li><p>学业方面：平时，无非常特殊情况绝不迟到、请假，更不准旷课，保证好学习听讲时间及学习质量。除了上课时间，我们还应该充分利用课后时间。除去必要适可的身体锻炼、娱乐活动及休闲时间外，均应安心、踏实、专注地攻读职业方向类、专业类书籍和其它类别的实用书籍。学习时要注意预习、听课、复习、综合分析比较、用时比例。知识积累不仅要博大精深，还要专业化、精练，力求毕业时获得优秀毕业生的称号。</p></li><li><p>考研任务繁重，加紧有效的时间做好考研工作的安排，对于自己的前途和理想不迷路，积极实现自己的感兴趣的目标，通识课，数学和英语的学习人中而道远，同时加强自己在专业课方面的技能，不再在懒散中浪费时光。</p></li></ol><h4 id="（二）毕业后的职业生涯规划"><a href="#（二）毕业后的职业生涯规划" class="headerlink" title="（二）毕业后的职业生涯规划"></a>（二）毕业后的职业生涯规划</h4><p>在之前的考研前期准备过程中，我发现自己的目标不在于本专业，或者如果之后读研深造，继续完成本专业的学习会给我带来困扰，于是决定在考研的过程中进行一些小的方向性调整，这些小调整也是经过我个人的认真思考，由本科学习信息安全专业转向研究生的大数据应用技术。这可能是以此小跨考，均属于计算机相关专业，只是在纯粹计算机技术方面，自己有着极大的学科空白，这也源于自己在本科学习过程中的懒惰行为。不过在我的学习过程中发现自己对于计算机硬件的极大抵触性，而且由于d之后的选择的未知性导致我做出了此次选择。并且考研院校也由自己的学校变成了中部地区的中南大学，任重而道远。</p><p>有了明确的目标就应该加紧时间足够努力去冲刺，我会每周给自己制定学习计划，深知学习非一朝一夕之事，但是会是一朝一夕积累得来的经验，面对一些无法解决的难题，我会花费足够多的是时间去增强自己的能力。去中部地区读研首要原因是日后可能在中部地区发展，并且在中部生活。那很大程度需要自己积累人脉，如果报考本校之后极大可能会因为地域的原因导致自己在中部的发展滞后他人。加上在职业招聘平台的定向搜索，发现目前所学专业信息安全虽然有很大的空缺，但在定向搜索的区域，发现人才需要并不很大，这导致了自己之后的求职之路可能艰辛且漫漫。况且由于本人的兴趣问题，在本科学习过程中发现自己对于大数据的兴趣不断提升，在一次课堂上对于老师布置的作业有着格外的兴趣，觉得日后可能会专研此方向。</p><p>以上是短暂的几年的规划，长期的规划是，短期培养能力，进入公司不断提升自己，再在人才的管理方面花费少许精力，使得之后的转型更加便捷，后来便可以进入慢慢晋升的道路。希望漫漫长路，自己能够不辞辛苦得到的果实能有心爱的人一起分享。</p><h3 id="三、成功标准"><a href="#三、成功标准" class="headerlink" title="三、成功标准"></a><strong>三、成功标准</strong></h3><p>我的成功标准：一个人设定一个积极的目标，经过努力，有一个积极的收获，就是成功。每个阶段中只要自己尽心尽力能力也得到了发挥都会自我的提高即使目标没有实现做的事至少自己努力过拼搏过我不会给自己后悔的理由。</p><p>成功之路有许多条，成功的定义也有许多种，只要在理想的指引下，真正做了自己想做的事情，真正实现了自己的人生的价值，就是一种成功，一种超越，就应该为此感到自豪和快乐。</p><h3 id="职业生涯规划书结束语"><a href="#职业生涯规划书结束语" class="headerlink" title="职业生涯规划书结束语"></a><strong>职业生涯规划书结束语</strong></h3><p>身为大学生的我们，应该珍惜这来之不易的学习机会。不是每个人都可以在大学里度过他一生中最美好的日子。人的大学时光一生中也就有一次,不把握好,将来自己一定回追悔莫及。</p><p>有了目标，才有动力。这份大学生职业生涯规划书给了我一个明确的学习目标和职业规划。我将按照上述内容完成自己的学习任务和工作任务，使我的生活更有意义。</p><p>这是我自己的职业生涯规划。有一个好的计划，就有了一个好的开端，其实这不是一件简单的事情，但只要有努力工作，就会有成就。现实是变化的，计划也应要跟着有所改变。我们务必保持清醒的头脑，及时处理我们碰到的困难。每个人都有自己的理想，不过要实现自己的这个理想还是得依靠自己的努力付出才行，无论你的理想有多美好，没有辛勤的汗水都是不可能实现的。天下没有免费的午餐，一个人，要想有所作为，必须拿出勇气，必须付出努力，必须学会去为自己的梦想拼搏，奋斗。成功,不相信眼泪成功,不相信颓废成功不相信幻影,未来,要靠自己去打拼!</p>]]></content>
      
      
      <categories>
          
          <category> 要成功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生涯规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
