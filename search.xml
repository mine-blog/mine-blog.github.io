<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>以前的记录</title>
      <link href="/2021/07/04/%E4%BB%A5%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/07/04/%E4%BB%A5%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="假装自己记录了"><a href="#假装自己记录了" class="headerlink" title="假装自己记录了"></a>假装自己记录了</h2><h3 id="记录一"><a href="#记录一" class="headerlink" title="记录一"></a>记录一</h3><p><img src="../%E4%BB%A5%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BD%95/1.JPG"></p><p>宋体小四，这是在word上我认为打字显示很舒服的设置，尤其是要加粗。今天是换了一间自习室进行学习，以至于觉得之前的几天学习效率极低。思考一下，可能是教室有许多面熟之人，加上眼前总有一些小动静。静不下心来，有会考虑到一些其他问题，导致一天的学习时间实际上很少。</p><p>不过换了一个新鲜环境就不必拘泥于其他问题，而且在五楼学习还不用考虑太多问题的烦恼，想在门口呼吸新鲜空气也大可不必在乎其他人的眼光，甚至，有时可以和晨晨能在合适的时候趴在栏杆上聊一些天，讲一讲生活。</p><p>没有想到太多的生活，最近一段时间，或者说是自从大三上的结束后，自己结束了以前的玩闹的心态，开始做正事，也没有算很正经的事，一直以来该做的事情罢了。前几天可能是比较累，加上睡眠不是很足吗？或者是由于水分补充不足？躺在床上休息的时候，半梦半醒的时候，我在想是不是自己在做梦？</p><p>为什么很真实，脑子多想后，世界就变得很复杂，并非物理世界的复杂，是心里世界的复杂。总幻想有时不清楚哪里是虚构，哪里是真实。走在路上也成谜一样。我便想，如果这是一场梦，我也愿意把自己做好，但谁知这是不是一场梦。醒来就是另一件事了。醒来的时候发现自己在睡眠舱已经离开原来所在的星球好远，一切只是可悲的科学实验。</p><p>那我的人生比较不一般，是在梦里的虚拟空间。如此也是仅仅娱乐自己，放松大脑。趁机荒唐时间，看看诗集。勉强做一些事，有时觉得自己做的还算足够，但是回到宿舍洗完澡，头脑放轻松便开始迷糊以下，这时候晨晨便发消息过来，问，波比回宿舍了吗？还是在自习啊？我今日有一些累，想让宝贝去打会游戏，自己也就可以稍微放空心情，看会视频，我不喜欢被事情或者人催着做什么事情，只要我愿意去做，那便不用担心我不会去做。事实有时候觉得自己对晨晨没有足够好，我都觉得自己的不称职。</p><p>但目前情况没办法将事情讲清楚，也有很多麻烦事，只活在理想中是不足够的。爱情令人容光焕发，面包使人享受爱情。我不但渴求爱情，又对面包如此饥渴。在我眼前摆着，我又不愿意去思考，只顾着说要吃饱肚子，晨晨有时便会因此被冷落。</p><p>如果在之前的一段时间认识，我可能会有大不一样的想法和行为，磨砺了我的想法和行为，思考也趋于理性，有感性的那一面的时候也是她在照顾我。</p><p>西安最近天气是怎么样的，问我，可能我也不是很清楚，早上九点左右便不再仰望天空，伏案或者戴上耳机，等到合适时候，出门吃午餐。看天气最近都是阴沉，偶尔有阳光，是昨天吧。出去取快递，买了一箱脱乳糖牛奶，这么甜，本想甚至喝一杯奶茶。后来作罢，有意识的控制自己的糖分，不可让自己太甜，甜腻会让晨宝更加喜欢。</p><p>晚上的时候会思考很多，有些人是最初会很有缘的相遇吧。就像两个朋友有缘的相遇，那也是令人感到很舒服的，只是两个人能不能长久还是要很多的机缘巧合，从小到大来，我交过很多朋友，有一些非常快的离开我的世界，有的甚至会在毕业后再也不会联系。最初还会很惋惜，后来再也不会。</p><p>走在路上，看到有的人三三两两一起去自习，爽朗开心，好像男人在一起或者同性在一起都较为高兴，大家都交谈玩笑。但谈恋爱一些事情发生变化，男人变了，女人变了。</p><p>觉得因为恋爱放弃健康的社交是极其愚蠢的行为，恋人，家人，朋友，自己。大可不必。好久没有写，乱七八糟，不过不在乎，是给晨宝还有自己读的。<br>最近读了好多诗歌。摘抄一条。</p><blockquote><p>卷纸<br>将爱情比作一种卷纸<br>一开始你闻闻它的气味<br>摸一摸它的质地<br>你撕开一个边角沿着纹路扯下一张<br>两张 紧接着是三张四张<br>它被你渐渐匆忙的手扯下<br>你一开始沿着纹路扯下<br>这很有仪式感<br>紧接着不再看 一次次扯下<br>扯下一张两张三张十张<br>不再数数<br>扯下一段是一段<br>用它擦桌子擦鼻子擦坐便器<br>擦你生活的污染部分<br>你感到脏了就用它擦掉<br>纸用尽了 只剩下一只纸筒<br>你拿在手里 轻蔑地捏一下<br>但你还是有太多污染部分来不及处置啊<br>你从垃圾桶 地上 桌上捡起<br>一张两张三张揉成一团的<br>脏了一遍又一遍的纸</p></blockquote><h3 id="记录二"><a href="#记录二" class="headerlink" title="记录二"></a>记录二</h3><p>现在是三月十三日，我已经很久没有出去玩耍。是自己懒惰了吗，可能没有晨晨也会是这样吧。只是不会有现在这样的充实。</p><p>我曾经多少次想我的恋人是什么样子，会不会是那种娇小让我一下子搂在怀里，或者是那种强势有思想主张，和我声声探讨事情的真相，说出自己的看法。我绝对要找到自己的那位眼中是我，心里转满了我，真诚善良的她。又或者是眼前有着无数的愿望，但愿意和我分享，不知道的事情勇敢说出口，自信，勇敢。</p><p>等到我遇见了她，我才认定这么久的等待完全是我的一种人生磨砺，如果没有认识这么多人，我哪会有如此幸运。</p><p>哎，不知道为什么在宿舍里会如此发困。我不愿待在宿舍里了！</p><p>过了一天，我换了个教室进行自习，今天的学习还算很舒服呢，学习了好多。哎，今天发一篇公众号吧！</p>]]></content>
      
      
      <categories>
          
          <category> 胜胜的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胜胜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们吵架了</title>
      <link href="/2021/06/27/%E6%99%A8%E6%99%A8%E7%9A%84%E5%BF%AB%E4%B9%90%E5%8A%A0%E4%B8%80/"/>
      <url>/2021/06/27/%E6%99%A8%E6%99%A8%E7%9A%84%E5%BF%AB%E4%B9%90%E5%8A%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="晨晨的周记二"><a href="#晨晨的周记二" class="headerlink" title="晨晨的周记二"></a>晨晨的周记二</h2><p><img src="../%E6%99%A8%E6%99%A8%E7%9A%84%E5%BF%AB%E4%B9%90%E5%8A%A0%E4%B8%80/1.JPG"></p><p>再过大概4个小时即将结束这一周，这一周感觉跟上周的工作日差不多，但是这周和胜胜发生了口角，吵架原因大概就是我周四的晚上跟着贝姐姐出了一趟门，当时确实时间挺晚的，贝姐姐的弟弟突然发了个消息过来问她去不去玩，当时她在考虑估计有可能会拒绝，因为已经11点多了而且明天还得上班，后来她弟弟突然发了个消息说今天是他生日，当时的我有点怀疑，说怎么会这么巧，后来问了贝姐姐一些信息，说真有可能，他没必要拿这个骗我们，当时确实有点急着走，所以这边回了弟弟一个我去了，可能是由于担心吧，一路上弟弟都在跟我说，但是估计不知道是我们两谁急了，突然就开始吵起来了，然后某个人的话题就在往一个人要照顾好自己这方面引，我就很气，本来都还好的我知道他是因为担心我，所以一路上都在解释也没怎么生气，他这几句话听的我瞬间就来火气了，我有种自我保护意识了，他说我也说，反正你不在乎我了，我也不怕跟你分手了，就一路吵到了餐馆，直到要回去了，都还在吵，因为很气所以我说的有些话可能也挺狠的，害！我本来也不想谁让你老说这种引导话题，最后还说是不是我想分了，我怎么可能想哼，我想的话你怎么可能还在，晚上回来说了晚安就睡了，这是真把我气到了，你说话可狠了，幸好之后和好了，不然我就再也不理你啦，都快气死了，每次都是前几天好甜，一吵架就闹得要分手，直男每次生气吵架都不让让人家。</p><p>周末去找了两天的房子累惨了，虽然每次都下午才出门，回来基本上都将近两万步了，长沙就是个火炉真的好热啊，都是35度晒死我们俩啦，还得到处跑，要么跟着中介、要么自己联系。好想赚钱啊，就能不这么辛苦了，但总体老说还是挺圆满的，虽然房子还是没租好还在考虑当中，顺便吐槽一句长沙已经被新环境垄断了（微笑），你们真棒，总之这周开心，下周继续努力生活吧，要天天开心哦胜胜，永远爱你哦(比）！！！</p><p>–LC</p>]]></content>
      
      
      <categories>
          
          <category> 晨晨的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 晨晨 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>返回导向编程</title>
      <link href="/2021/06/27/%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/06/27/%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>主题目录</strong></p><ul><li>栈溢出</li><li>返回导向编程<ul><li>动机</li><li>前身</li><li>原理</li><li>图灵安全</li></ul></li><li>地址空间随机化防护</li></ul><h2 id="栈的工作原理"><a href="#栈的工作原理" class="headerlink" title="栈的工作原理"></a>栈的工作原理</h2><ol><li>简介</li></ol><p>调用函数将在栈上创建一个结构化空间，称为栈帧。<br>锚点：函数被调用时的栈指针位置，可用于对函数的局部数据寻址/返回到调用者。</p><p><img src="../%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B/1.jpg"></p><ol start="2"><li>栈溢出</li></ol><p><img src="../%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B/2.jpg"><br><img src="../%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B/3.jpg"></p><ol start="3"><li>基于栈溢出的典型代码注入攻击</li></ol><ul><li>通过栈溢出，劫持位于栈帧中的函数返回地址</li><li>直接将被劫持的返回地址指向被溢出的栈区</li><li>溢出过程在被指向的位置上写入shellcode</li></ul><ol start="4"><li>针对代码注入的防护机制</li></ol><p>** 数据执行保护**</p><ul><li>一些别名：W⊕X，NX-bit</li><li>机制：对内存页面增加一个标识bit，使之要么可改写，要么可执行</li></ul><p><strong>经典代码注入的核心思想</strong></p><ul><li>利用逻辑异常，在程序数据中混入代码。</li><li>劫持控制流，使得指令指针从数据段读取指令。</li><li>所需弱点：读取指令时，CPU无法区分目标内存区域的性质（代码？数据？）。</li></ul><p><strong>针对上述特点，DEP的防御思路</strong><br>引入新的硬件安全属性，支持CPU在执行时区分代码和数据区域。<br><strong>缺点</strong></p><ul><li>既然注入Shellcode无法执行，进程和动态库的代码段怎么也要执行吧，具有可执行属性，那攻击者能否利用进程空间现有的代码段进行攻击，答案是肯定的。</li><li>若不试图执行数据区内容，则不能发现/阻止溢出，也无法防范溢出的其他后果。</li></ul><ol start="5"><li>DEP与return-to-libc攻击</li></ol><p><strong>绕过DEP</strong><br>DEP客观存在，注入类攻击如何下手？</p><p>代码重用（code reuse）攻击—-异常数据的注入仍然可以实施。</p><p>既然代码无法直接注入，那么就利用进程空间中已经存在的代码。不管所利用代码原本的用途为何，通过注入的异常数据控制其为攻击者服务，最先出现的此类手段：return-to-libc攻击。</p><p><strong>DEP核心思想</strong></p><p>缓冲区溢出的常用攻击方法是用 shellcode 的地址来覆盖漏洞程序的返回地址，使得漏洞程序去执行存放在栈中 shellcode。</p><p>为了阻止这种类型的攻击，一些操作系统使得系统管理员具有使栈不可执行的能力。这样的话，一旦程序执行存放在栈中的 shellcode 就会崩溃，从而阻止了攻击。</p><p><strong>return-to-libc核心思想</strong></p><p>攻击者采用缓冲区溢出改写返回地址为一个库函数的地址，并且将此库函数执行时的参数也重新写入栈中。</p><p>当函数调用时获取的是攻击者设定好的参数值，此库函数实际上就帮助攻击者执行其恶意行为。</p><p>更复杂的攻击还可以通过 return-into-libc 的调用链（一系列库函数的连续调用）来完成。</p><p><strong>return-to-libc局限性</strong><br>攻击者可用的指令序列只能为应用程序中已存在的函数,所以这种攻击方式的攻击能力有限。</p><p>从函数—-&gt;指令，不再局限于将漏洞程序的控制流跳转到库函数中，而是可以利用程序和库函数中识别并选取的一组指令序列。攻击者将这些指令序列串连起来，形成攻击所需要的 shellcode 来从事后续的攻击行为<br>可行吗？</p><p><strong>绕过DEP新利用点</strong><br><strong>复杂指令集（complex instruction set computing，CISC）</strong><br>指令变长（目的：以最短的代码长度压缩最多的指令内容），CPU串行地读取指令，依据上下文区分操作码/操作数等成分。<br>典型：x86指令构架</p><p><strong>CISC所存在的问题</strong></p><ul><li>代码中一个字节的含义取决于上下文。</li><li>同一数值在单字节/双字节操作码中出现，意义不同。</li><li>同一数值作为指令中的不同元素（如操作码/立即数）时，意义不同。</li><li>原则上，任何一个字节都可能是一条指令的起始。</li></ul><h2 id="返回导向编程"><a href="#返回导向编程" class="headerlink" title="返回导向编程"></a>返回导向编程</h2><p><strong>挑战</strong><br>ROP挑战在于，需要在整个内存代码空间中“搜索”我们需要的gadgets，而后“拼接”。</p><p>代码均是合法的，常规方法难以检测。已有实验室提出包括扫描可利用的代码、将代码结合的constructor，使用一套专用的语言，进而将语言编译成对应代码片段之和的编译器，并给出计算实际代码地址的加载器。</p><h2 id="地址空间随机化防护"><a href="#地址空间随机化防护" class="headerlink" title="地址空间随机化防护"></a>地址空间随机化防护</h2><ol><li>增强软件系统的多样性（安全性）</li></ol><p>通过地址空间随机化増强系统的多样性，同一个程序在不同的机器上，内存布局不一样，在同一台计算机上，两次运行的内存布局也不同。</p><p>Ｒet2libc攻击、ROP攻击利用基于每一个gardget的地址己知并且不会变化的前提。</p><p>地址空间随机化(ASLR）技术通过将程序代码段加载到一个随机的基址，代码段中每一条指令的地址都发生了变化。如果ROP等攻击方法仍然将控制流劫持到原来gardget的地址就会导致攻击失败，ASLR技术在目前主流的操作系统上都有相应的实现。</p><ol start="2"><li>如何将地址空间随机化</li></ol><p>系统将进程的用户空间划分为三个区域，可执行区域（代码区（部分可随机化代码），初始化数据和未初始化数据），映射区（堆，动态库和共享内存）和栈区。</p><p>对于32位系统来说，并不能在整个４Ｇ的地址空间中进行随机化，栈区基址第4-23位可随机化，映射区基址第12-27位可被随机化，可执行区也是12-27位可被随机化。</p><p>32位线性地址，高四位为全局页表，如果应用随机化则会影响到高位内存的映射能力，产生大量内存碎片，低12位考虑页对齐操作。</p><ol start="3"><li>ASLR的局限性</li></ol><p>在32位系统上，ASLR对于代码段只有16位的随机化强度，这样的随机化强度远远不够，平均只需要32768次（最坏情况是2的16次方）尝试即可攻破一个采用ASLR防御技术的系统。</p><p>实验结果，采用暴力尝试的方法用ROP技术攻击部署了ASLR的机器上的Apache Http Server，平均耗费216秒即可攻击成功。</p><p>仅仅对代码段的基地址进行随机化，指令间的相对位置并没有改变，易受到信息泄露攻击的威胁。</p><ol start="4"><li>细粒度ASLR的实施</li></ol><ul><li>程序在加载时自我随机化</li><li>通过虚拟机进行动态随机化</li><li>操作系统的随机化</li></ul><ol start="5"><li>ASLR总结</li></ol><ul><li>ASLR通过给内存布局的偏移做了随机化工作。</li><li>ASLR增加了漏洞利用的难度，不解决漏洞本身。</li><li>64位操作系统中，ASLR能够提供更大的熵（可随机的地址范围更大），因而具有很好的防利用效果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息论期末</title>
      <link href="/2021/06/27/%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/"/>
      <url>/2021/06/27/%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/</url>
      
        <content type="html"><![CDATA[<p>根据老师画的80分的知识点复习。</p><ol><li>熵的概念</li></ol><p>离散集的平均自信息—-熵</p><p>熵是接收的每条消息中包含的信息的平均量，又被称为信息熵、信源熵、平均自信息量。这里，“消息”代表来自分布或数据流中的事件、样本或特征。熵的单位通常为比特，但也用Sh、nat、Hart计量，取决于定义用到对数的底。<br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/1.jpg"><br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/2.jpg"><br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/6.jpg"><br>熵的性质：对称性、非负性、确定性、扩展性。<br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/3.jpg"><br>示例<br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/7.jpg"></p><ol start="2"><li>平均互信息的概念</li></ol><p>互信息量<br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/9.jpg"><br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/8.jpg"><br>定义<br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/4.jpg"><br>性质：非负性、对称性<br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/5.jpg"></p><ol start="3"><li>信息处理不等式</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/10.jpg"><br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/11.jpg"><br>对观测数据的任何处理都会带来信息损失。绝对不会使信息增加。处理的越细致，信息的损失越小。但是处理的代价就越高。</p><p>当消息经过多级处理后，随着处理器数目的增多，输入消息与输出消息之间的平均互信息量趋于变小。</p><ol start="4"><li>信源编码定理</li></ol><p>在信息论中，香农的信源编码定理确立了数据压缩的限度，以及香农熵的操作意义。</p><p>信源编码定理表明不可能把数据压缩得码率比信源的香农熵还小，又不丢失信息。但是有可能使码率任意接近香农熵，且损失的概率极小。</p><p>码符号的信源编码定理把码字的最小可能期望长度看作输入字的熵和目标编码表的大小的一个函数，给出了此函数的上界和下界。</p><ol start="5"><li>信道编码定理</li></ol><p>只要信息传输速率小于信道容量，就存在一类编码，使信息传输的错误概率可以任意小。 </p><p>设R是信息传输的速率，C是离散无记忆信道的信道容量，ε&gt;0是任意小的数，则只要R&lt;C就总存在码字长为N，码字数为M=2NR的分组码使译码的平均差错概率Pe&lt;ε。</p><ol start="6"><li>信息量的计算</li></ol><ol start="7"><li>霍夫曼编码的计算</li></ol><ol start="8"><li>准对称信道容量的计算</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/12.jpg"><br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/13.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全模糊测试</title>
      <link href="/2021/06/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/06/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><strong>主体目录</strong></p><ul><li>模糊测试介绍<ul><li>模糊测试概述</li><li>简单示例</li><li>模糊测试步骤</li></ul></li><li>模糊测试案例<ul><li>常见的模糊测试</li><li>XSS 模糊测试</li></ul></li></ul><h2 id="模糊测试介绍"><a href="#模糊测试介绍" class="headerlink" title="模糊测试介绍"></a>模糊测试介绍</h2><h3 id="模糊测试概述"><a href="#模糊测试概述" class="headerlink" title="模糊测试概述"></a>模糊测试概述</h3><ol><li>定义</li></ol><p>模糊测试（Fuzz testing/fuzzing）是一种发现安全漏洞的有效的测试方法，在安全性测试中越来越受到重视，模糊测试将随机的坏数据插入程序，观察程序是否能容忍杂乱输入。<br>模糊测试是不合逻辑的，只是产生杂乱数据攻击程序，采用模糊测试攻击应用程序可发现其他采用逻辑思维来测试很难发现的安全漏洞。<br>2. 模糊测试的本质<br><strong>跳出程序员制定的规则圈圈</strong><br>Fuzz技术的思想就是利用“暴力”来实现对目标程序的自动化测试，然后监视检查其最后的结果，如果符合某种情况就认为程序可能存在某种漏洞或者问题。<br>暴力指利用不断地向目标程序发送或者传递不同格式的数据来测试目标程序的反应。</p><blockquote><p>我们可以把模糊测试理解成为一种能自动进行”rough attack”尝试的工具。之所以说它是”rough attack”,是因为Fuzz往往可以触发一个缓冲区溢出的漏洞，但却不能实现有效的exploit。测试人员需要实时地捕捉目标程序抛出的异常、发生的崩溃和寄存器等信息，综合判断这些错误是不是真正的可利用漏洞。</p></blockquote><ol start="3"><li>模糊测试特点</li></ol><ul><li>测试的用例通常具备某种攻击性的畸形数据，用以触发各种类型的漏洞。</li><li>具备较好的自动化测试能力。</li><li>“暴力（蛮力）”攻击方法。</li><li>很少出现误报。</li><li>能够快速找到真正的漏洞，操作简单。</li><li>通常不是进行功能性测试，而是检查系统处理错误的能力，比如：“入侵”、 “破坏” 、 “崩溃”。</li><li>不能保证系统中已经没有漏洞，即使我们用Fuzz找到了100个严重的漏洞，系统中仍然可能存在第101个漏洞。</li></ul><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><ol><li>模糊测试方式</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/1.jpg"></p><h3 id="模糊测试步骤"><a href="#模糊测试步骤" class="headerlink" title="模糊测试步骤"></a>模糊测试步骤</h3><ol><li>模糊测试常规步骤</li></ol><p><strong>典型模糊测试过程</strong></p><ul><li>识别测试目标</li><li>识别用户输入</li><li>生成Fuzz测试数据</li><li>执行Fuzz测试数据</li><li>监视异常</li><li>确定可利用性</li></ul><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/2.jpg"></p><ol start="2"><li>模糊测试的主要方法</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/3.jpg"></p><ol start="3"><li>模糊测试类型</li></ol><p><strong>本地模糊测试器</strong></p><ul><li>命令行模糊测试器</li><li>环境变量模糊测试器</li><li>文件格式模糊测试器</li></ul><p><strong>远程模糊测试器</strong></p><ul><li>网络协议模糊测试器（简单协议、复杂协议）</li><li>Web应用模糊测试器</li></ul><p><strong>内存模糊测试器</strong><br><strong>模糊测试框架</strong></p><h2 id="模糊测试案例"><a href="#模糊测试案例" class="headerlink" title="模糊测试案例"></a>模糊测试案例</h2><h3 id="常见模糊测试"><a href="#常见模糊测试" class="headerlink" title="常见模糊测试"></a>常见模糊测试</h3><p><strong>典型模糊测试</strong></p><ul><li>文件Fuzz测试</li><li>协议Fuzz测试</li><li>组件Fuzz测试</li><li>Web Fuzz测试</li></ul><ol><li>文件Fuzz测试</li></ol><p><strong>盲模糊测试</strong><br><strong>操作</strong><br>在随机位置插入随机的数据以生成畸形文件。<br><strong>事实</strong><br>现代软件往往使用非常复杂的私有数据结构，数据结构越复杂，解析程序的逻辑就越复杂，越容易出错。<br><strong>结果</strong><br>产生测试用例的策略缺少针对性、大量测试用例无效、难以发现复杂解析器深层逻辑的漏洞。</p><p><strong>智能模糊测试</strong><br><strong>复杂数据结构特征</strong></p><ul><li>拥有一批预定义的静态数据</li><li>数据结构的内容是可以动态改变的</li><li>数据结构之间是嵌套的</li><li>数据中存在多种数据关系(size of,point to,reference of,CRC)</li><li>有意义的数据被编码或压缩，甚至用另一种文件格式来存储，这些格式的文件被挖掘出来越来越多的漏洞。</li></ul><p><strong>Smart Fuzz应运而生</strong></p><ul><li>面向逻辑(Logic Oriented Fuzzing)</li></ul><p><strong>测试目标是解析文件的程序逻辑，而不是文件本身。</strong><br>明确测试用例正在试探的是哪一层的解析逻辑，即明确测试“深度”以及畸形数据的测试“粒度”。<br>生成畸形数据时可以具有针对性的仅仅改动样本文件的特定位置，尽量不破坏其他数据依赖关系，这样使得改动的数据能够传递到测试的解析深，而不会在上层的解析器中被破坏。</p><ul><li>面向数据类型(Data Type Oriented Fuzzing)</li></ul><p><strong>面向数据类型：测试中可以生成的数据。</strong><br>算术型：包括以HEX、ASCII、Unicode、Raw格式存在的各种数值。<br>指针型：包括Null指针、合法/非法的内存指针等。<br>字符串型：包括超长字符串、缺少终止符(0x00)的字符串等。<br>特殊字符：包括#，@，’，&lt;,&gt;,/,,../等等。<br>面向数据类型测试是指能够识别不同的数据类型，并且能够针对目标数据的类型按照不同规则来生成畸形数据。<br>跟Blind Fuzz相比，这种方法产生的畸形数据通常都是有效的，能够大大减少无效的畸形文件。</p><ul><li>基于样本(Sample Based Fuzzing)</li></ul><p><strong>测试前首先构造一个合法的样本文件（模版文件），这时样本文件里所有数据结构和逻辑必然都是合法的。</strong><br>以这个文件为模板，每次只改动一小部分数据和逻辑来生成畸形文件，这种方法也叫做“变异”(Mutation)。<br>对于复杂文件来说，以现成的样本文件为基础进行畸形数据变异来生成畸形文件的方法要比上面两种的难度要小很多，也更容易实现。<br>漏报：不能测试样本文件里没有包含的数据结构。<br>为了提高测试质量，就要求在测试前构造一个能够包含几乎所有数据结构的文件（比如文字、图像、视频、声音、版权信息等数据）来作为样本。<br>2. 协议模糊测试<br><strong>协议：网络通信（双方或多方）的约定，网络系统的核心灵魂。</strong></p><blockquote><p>多数网络协议细节未公开</p></blockquote><p>多种类型的漏洞出现，如拒绝服务、缓冲区溢出、格式化字符串<br>协议解析的软件通常较复杂，需要反复进行数据的读取和处理。<br><strong>协议逆向工程</strong></p><ul><li>Network Trace，利用网络流量来推测网络协议。</li><li>Tainted Data，对实现网络协议的服务器程序进行二进制的动态跟踪分析，通过跟踪二进制文件对报文的处理流程对报文进行解析。以动态污点分析技术为基础。</li></ul><p><strong>FTP协议模糊测试</strong></p><ul><li>File Transfer Protocol，基于TCP，其工作模式采用客户端/服务器的模式，也就是C/S模式。</li><li>客户连接FTP服务过程：建立连接、传送数据和释放连接。</li><li>基本原理就是通过对FTP协议中的命令及命令参数进行脏数据替换，构造畸形的FTP命令并发送给被测试FTP服务程序。</li></ul><ol start="3"><li>组件模糊测试</li></ol><ul><li>组件提取</li><li>组件接口分析</li><li>构造测试用例</li><li>测试驱动、异常跟踪</li><li>结果分析</li></ul><ol start="4"><li>Web模糊测试</li></ol><p><strong>特殊形式的网络协议模糊测试，测试方法如下</strong></p><ul><li>设置目标环境</li><li>输入</li><li>GET、POST、HEAD 、PUT 、DELETE 、TRACE 、CONNECT 、 OPTIONS</li><li>请求URL</li><li>异常检测</li></ul><p><strong>主要的Web漏洞</strong></p><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/4.jpg"></p><p><strong>Web模糊测试异常检测</strong><br>HTTP 状态码、Web服务器错误消息、中断连接、日志文件、时间日志、调试器。</p><h3 id="XSS模糊测试"><a href="#XSS模糊测试" class="headerlink" title="XSS模糊测试"></a>XSS模糊测试</h3><p>对于XSS的漏洞挖掘过程，其实就是一个使用Payload不断测试和调整再测试的过程，这个过程我们把它叫做Fuzzing。</p><p>同样是Fuzzing，有些人挖洞比较高效，有些人却不那么容易挖出漏洞，除了掌握的技术之外，比如编码的绕过处理等，还包含一些技巧性的东西，掌握一些技巧和规律，可以使得挖洞会更加从容。</p><p>Fuzzing（模糊测试）是挖掘漏洞最常用的手段之一，不止是XSS，应该可以说Fuzzing可以用于大部分类型的漏洞挖掘。通俗可以把这种方式理解为不断尝试的过程。</p><ol><li>XSS模糊测试关键</li></ol><ul><li>检测输入点<br>寻找数据入口，比如说GET/POST数据，或者Header头部里的UA/Referer/Cookie，再或者URL路径等等，这些都可以成为输入入口<br>转换为比较形象点的说法，比如看到一个搜索框，你可能会在搜索框里提交关键词进行搜索，那么这里可能就发生了一个GET或者POST请求，这里其实就是一个输入点。</li><li>潜在注入点检测：判断输入点是否可以成功把数据注入到页面内容。</li></ul><p>对于提交数据内容但是不输出到页面的输入点是没有必要进行Fuzzing的，因为即使可以提交攻击代码，也不会产生XSS。</p><p>在潜在注入点的检测通常使用的是一个随机字符串，比如随机6位数字，再判断这6位数字是否返回输出在页面，以此来进行判断。</p><p>为什么不直接使用Payload进行判断呢？因为Payload里包含了攻击代码，通常很多应用都有防火墙或者过滤机制，Payload中的关键词会被拦截导致提交失败或者不会返回输出在页面，但这种情况不代表不能XSS，因为有可能只是Payload不够好，没有绕过过滤或者其他安全机制，所以采用无害的随机数字字符就可以避免这种情况产生。</p><p>先验证可注入，再调整Payload去绕过过滤；而随机的目的在于不希望固定字符成为XSS防御黑名单里的关键词。</p><ul><li>生成Payload和进行攻击验证：Payload的好坏决定了攻击是否可以成功。</li></ul><p>而对于不同情况的注入点，需要使用的Payload也是不同的，比如，注入的位置在标签属性中还是标签事件中，使用的Payload是不同的，<br>标签属性中：如<code>&lt;a href=&quot;注入位置&quot;&gt;test&lt;/a&gt;，Payload：&quot;&gt;&lt;/a&gt;&lt;script&gt;alert(0)&lt;/script&gt;&lt;a  href=&quot;</code><br>标签事件中：<code>&lt;img href=&quot;a.jpg&quot; onload=&quot;注入位置&quot;&gt;, Payload：alert(0)</code></p><blockquote><p>Payload的生成就是一个不断Fuzzing和不断调整的过程，根据注入位置上下文代码的结构、内容以及应用过滤机制等不断调整和不断提交测试的过程。</p></blockquote><ol start="2"><li>XSS模糊测试一些技巧</li></ol><p>类似QQ、微信这种一号多用的情况，可以想象你的微信昵称、QQ昵称或者签名等，在不同的应用、网页中登录，你的昵称就会在不同的地方显示，这些昵称在微信、QQ本身不会导致问题的产生，但到了其他页面呢？也许就会导致问题的产生。</p><p>登录和注册是大部分网站的必备功能，当你在未登录状态下访问一些需要需要登录态的页面，比如个人中心，会自动跳转到登录或者注册页面要求你登录，然后这个时候的登录URL其实会带有一个跳转URL，这是为了方便你登录后直接跳转到你原来访问的页面，是一个比较好的用户体验的设计。由于功能设计上的缺陷，没有对跳转的URL进行判断或者判断有问题，于是可以导致直接跳转到其他网站或者产生XSS。当然，不止是登录，注册功能也存在同样问题</p><p>盲打：常规的XSS攻击是通过页面返回内容中JS攻击代码的生效与否来判断XSS的攻击是否成功；而对于一些网页功能，比如反馈，我们可以发现，不管你提交什么内容，返回的内容都是”感谢您的反馈”类似的语句，并不会根据你提交的内容而在页面中显示不同的内容，对于这样的内容提交点，就无法通过页面反馈判断攻击代码是否注入成功，那么就可以通过XSS盲打。</p><p>XSS盲打一般通过XSS盲打平台，在XSS盲打平台建立项目，会生成项目攻击链接，实际上就是一个类似JS文件的访问链接，这个JS文件中其中至少包含一个功能，那就是向盲打平台发送GET/POST请求传输数据回来，比如Cookie，这样的话，类似在反馈页面提交的攻击代码一旦生效，就等于JS代码被执行，那么就会向盲打平台返回数据，那就说明攻击成功了；假如一直没有返回数据，那就说明提交的攻击代码没有执行或者执行出问题，也就证明攻击失败。</p><p>类似于这样的功能，如果存在XSS，一般会在什么地方什么时候出发攻击代码呢？管理人员在后台审核这些内容的时候，所以说一般XSS盲打如果成功，往往可以获得对应功能管理后台的地址以及管理员的Cookie，假如管理后台没有做访问的限制，就能用对应管理员的Cookie登录上去</p><p>不管是来自哪里的内容，都应该有自己的过滤机制，而不能完全的信任其实总结一句话就是：任何的输入都是有害的。</p>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息与内容安全</title>
      <link href="/2021/06/25/%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/"/>
      <url>/2021/06/25/%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="信息与内容安全概述"><a href="#信息与内容安全概述" class="headerlink" title="信息与内容安全概述"></a>信息与内容安全概述</h2><ol><li>网络安全的定义</li></ol><p>网络安全是融合<strong>物理域、信息域、认知域和社会域</strong>，以及互联互通的技术基础设施网络为平台，通过无线电、有线电信道传递信号信息，控制实体行为的信息活动空间。<br>2. 信息内容安全的定义</p><ul><li>信息内容安全是信息安全在<strong>法律、政治、道德层次</strong>上的要求，是语义层次的安全。我们要求信息内容是安全的，就是要求信息内容在政治上是健康的， 在法律上是符合国家法律法规的，在道德上是符合中华民族优良的道德规范的。</li><li>广义的信息内容安全既包括信息内容在政治、法律和道德方面的要求，也包括<strong>数据的获取，信息内容的分析与识别，数字图像视频内容安全，多媒体信息隐藏，隐私保护</strong>等诸多方面。</li></ul><ol start="3"><li>人工智能发展进阶</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/1.jpg"></p><ol start="4"><li>人工智能、机器学习和深度学习之间的关系</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/2.jpg"><br>5. 深度学习的3个步骤</p><ul><li>神经网络</li><li>多种方式模拟</li><li>挑选最优方式</li></ul><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/3.jpg"></p><h2 id="网络信息内容的获取与表示"><a href="#网络信息内容的获取与表示" class="headerlink" title="网络信息内容的获取与表示"></a>网络信息内容的获取与表示</h2><ol><li>三原色原理</li></ol><p>光学三原色：红蓝绿。</p><ol start="2"><li>信息内容表示—-视觉信息</li></ol><p>彩色图像—-&gt;灰度图像<br>Y=(R+G+B)/3<br>3. 视频</p><p>视频就是其内容随时间变化的一组动态图像，所以又叫运动图像或活动图像。</p><ol start="4"><li>计算机看的原理：视觉余像</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/4.jpg"><br>5. 视觉特征表达</p><ul><li>颜色特征</li><li>纹理特征</li><li>局部二值特征</li><li>梯度直方图特征</li><li>局部特征</li></ul><ol start="6"><li>文本特征表达</li></ol><p><strong>1-of-N Encoding(One-hot Encoding)</strong><br><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/5.jpg"><br><strong>怎么将文本表达成变量</strong></p><ul><li>词频</li><li>文档频数</li><li>词频-逆文档频数(TF-IDF)</li></ul><p>词频(TF)=某个词在文章中的出现次数/文章的总词数<br>逆文档频率(IDF)=log(语料库的文档总数/(包含该词的文档数+1))<br>TF-IDF = TF * IDF<br>7. 音频特征表达<br><strong>MFCC</strong><br><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/6.jpg"></p><h2 id="深度学习基础（重要）"><a href="#深度学习基础（重要）" class="headerlink" title="深度学习基础（重要）"></a>深度学习基础（重要）</h2><ol><li>反向传播</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/20.jpg"></p><ol start="2"><li>卷积神经网络</li></ol><p><strong>卷积的计算：矩阵对应位置先乘再加。</strong><br><strong>池化：最大池化，最小池化，平均池化。</strong><br><strong>全连接前馈网络</strong><br><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/19.jpg"><br>3. 理解神经网络<br><strong>神经网络可视化</strong><br>GoogLeNet<br>4. 经典神经网络结构<br><strong>LeNet-5</strong><br><strong>AlexNet</strong><br><strong>VGGNet</strong><br><strong>ResNet</strong></p><h2 id="生成对抗网络"><a href="#生成对抗网络" class="headerlink" title="生成对抗网络"></a>生成对抗网络</h2><ol><li>GAN的种类</li></ol><ul><li>GAN</li><li>ACGAN</li><li>BGAN</li><li>CGAN</li><li>DCGAN</li></ul><ol start="2"><li>GAN的基本思想</li></ol><p>向量—-&gt;生成器—-&gt;图像（高维度向量）<br>图像—-&gt;判别器—-&gt;范围（较大的值代表是真，较小的值代表是假）<br>3. 算法</p><ul><li>初始化生成器和判别器</li><li>每轮迭代<ul><li>固定生成器，更新判别器</li><li>固定判别器，更新生成器（生成器试图愚弄判别器）</li></ul></li></ul><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/7.jpg"><br>4. 生成对抗网络原理</p><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/8.jpg"></p><h2 id="在线社交网络分析"><a href="#在线社交网络分析" class="headerlink" title="在线社交网络分析"></a>在线社交网络分析</h2><ol><li>在线社交网络定义</li></ol><p>在线社交网络是一种在信息网络上由社会个体集合及个体之间的连接关系构成的社会性结构，包含<strong>关系结构、网络群体和网络信息</strong>三个要素。<br>2. 在线社交网络的三个维度</p><ul><li>结构</li><li>群体</li><li>信息</li></ul><ol start="3"><li>在线社交网络分析定义</li></ol><p>在线社交网络分析是指从<strong>网络结构、群体互动、信息传播</strong>三个维度，基于信息学、数学、社会学、管理学、心理学等多学科的 融合理论和方法。为理解人类各种社交关系的形成、行为特点分析以及信息传播的规律提供一种可计算的分析方法。</p><ol start="4"><li>社交网络群体行为</li></ol><p><strong>群体极化产生的条件可概括为4点</strong></p><ul><li>必须有激发事件出现</li><li>群体内的个人能看到前人的选择</li><li>群体信息缺乏</li><li>群体有一定同质性</li></ul><ol start="5"><li>在线社交网络信息传播规律</li></ol><ul><li>影响力模型</li><li>传染模型</li></ul><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/9.jpg"></p><h2 id="信息过滤"><a href="#信息过滤" class="headerlink" title="信息过滤"></a>信息过滤</h2><ol><li>信息过滤模型</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/10.jpg"><br>2. 信息过滤VS信息检索</p><ul><li>信息过滤可以看成广义信息检索的一部分。</li><li>信息过滤过滤出不相关的数据，而信息检索选择相关的数据项查询。</li><li>信息检索可以认为面向一次性的查询而使用，而信息过滤是面向用户的长期需求的重复使用。</li><li>信息过滤中信息源动态，用户需求 (采用User Profile来表示)相对静态；信息检索信息源相对静态，用户需求(采用Query来表示)动态变化</li><li>信息过滤用户要对系统有所了解，信息检索不需要。</li><li>信息过滤一般要关注用户建模，涉及用户隐私问题，信息检索不涉及。</li></ul><ol start="3"><li>信息过滤VS信息分类</li></ol><ul><li>信息过滤可以采用信息分类中的分类算法。</li><li>信息分类中的分类通常不会变化。相对而言，信息过滤的用户偏好会动态调整。</li></ul><ol start="4"><li>信息过滤VS信息提取</li></ol><ul><li>信息提取是从无格式数据源中抽取相关字段的过程。比如抽取恐怖事件的时间、地点、人物等字段。</li><li>信息过滤中要关注相关性，信息提取不太关注相关性，而只关注相关的字段。</li></ul><ol start="5"><li>信息过滤分类体系</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/11.jpg"><br>基于感知的过滤，也称为基于内容的过滤。<br>基于社会的过滤，也称为基于协同的过滤。<br>6. AC自动机</p><ul><li>基本思想</li></ul><p>在预处理阶段，AC自动机算法建立了三个函数，<strong>转向函数goto，失效函数failure和输出函数output</strong>，由此构造了一个树型有限自动机。在搜索查找阶段，则通过这三个函数的交叉使用扫描文本，定位出关键字在文本中的所有出现位置。</p><ul><li>特点</li></ul><p>扫描文本时完全不需要回溯，时间复杂度为O(n)，与关键字的数目和长度无关。</p><ul><li>树型有限自动机</li></ul><p>树型有限自动机包含一组状态，每个状态用一个数字代表。状态机读入文本串y中的字符，然后通过产生状态转移或者偶尔发送输出的方式来处理文本。<br>树型有限自动机的行为通过三个函数来指示：<strong>转向函数g，失效函数f和输出函数output。</strong></p><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/12.jpg"></p><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/18.jpg"></p><h2 id="网络舆情分析"><a href="#网络舆情分析" class="headerlink" title="网络舆情分析"></a>网络舆情分析</h2><ol><li>网络舆情概念</li></ol><p>网络舆情：是指以互联网为载体所表达的公众情绪，究其本质是社会情绪在互联网这个可见载体上的公共表达。<br>2. 网络舆情的特征</p><ul><li>自发性</li><li>指向性</li><li>时效性</li><li>情绪性</li><li>片面性</li></ul><ol start="3"><li>网络舆情的演化</li></ol><ul><li>形成期</li><li>高涨期</li><li>波动期</li><li>消退期</li></ul><h2 id="对抗攻击与防御"><a href="#对抗攻击与防御" class="headerlink" title="对抗攻击与防御"></a>对抗攻击与防御</h2><ol><li>攻击想做什么</li></ol><p><strong>愚弄分类器，使得分类器不能正常识别并且分类。</strong><br>2. 攻击的损失函数<br><strong>训练—-&gt;无目标攻击—-&gt;目标攻击</strong><br>约束：不能被发现。<br><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/21.jpg"><br>3. 如何攻击<br><strong>梯度下降</strong><br><strong>攻击方法：FGSM（快速梯度符号法）</strong><br>4. 白盒和黑盒</p><p>在前面的攻击中，我们固定网络参数𝜃而寻找最优的输入𝑥。</p><ul><li>为了攻击，我们需要知道网络参数𝜃。这样的攻击叫白盒攻击(White Box Attack)。</li><li>如果我们不将模型公布是不是就安全?绝大多数API不能提供网络参数的。不行，因为黑盒攻击(Black Box Attack)是可能的。</li><li>如果你有目标网络的训练数据，训练一个代理网络(proxy network)，否则，从目标网络获取输入输出对。</li></ul><ol start="5"><li>One Pixel Attack（一像素攻击）VS一般的攻击</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/22.jpg"><br>6. 2种类型的防御</p><ul><li>被动防御(Passive defense)：在不修改模型的情况下找到攻击图像。</li><li>主动防御(Proactive defense): 训练一个对对抗攻击具有鲁棒性的模型。</li></ul><ol start="7"><li>总结</li></ol><p><strong>攻击: 在给定网络参数的情况下，攻击非常容易。</strong></p><ul><li>即使是黑盒攻击也是可能的</li><li>防御：主动防御和被动防御</li><li>未来：自适应攻击和防御</li></ul><h2 id="视觉内容伪造与检测"><a href="#视觉内容伪造与检测" class="headerlink" title="视觉内容伪造与检测"></a>视觉内容伪造与检测</h2><ol><li>Deepfake事件</li></ol><p>图像内容伪造<br>2. 内容伪造方法</p><ul><li>虚假人脸生成</li><li>人脸替换<ul><li>原始Deepfake方法</li><li>基于GAN的Deepfake方法</li></ul></li><li>人脸编辑<ul><li>属性编辑</li><li>表情重演</li><li>跨模态</li></ul></li></ul><ol start="3"><li>检测伪造方法</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/13.jpg"><br><strong>挑战</strong></p><ul><li>单个工具对付各种攻击的效率将越来越低</li><li>深度学习的方法可解释性</li></ul><h2 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h2><ol><li>什么是异常检测</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/15.jpg"><br>给定一组训练数据，我们想找到一个检测输入x与训练数据是否相似的方程。<br>2. 异常检测是二分类分类器<br>3. 如何使用分类器</p><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/16.jpg"></p><ol start="4"><li>检测框架示例</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/17.jpg"></p><ol start="5"><li>评价准则</li></ol><ul><li>准确率</li></ul><p>准确率不是一个好的评价准则，因为一个系统可以有很高的准确率，但是并不影响检测错误。</p><ol start="6"><li>自编码器</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/14.jpg"><br>训练和测试的时候都经过编码、译码的过程，发现测试图片有较大的重组损失的，将其认定为虚假照片。<br>7. 基于生成对抗网络（GAN-Based）</p><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>已经考完试了，感觉出的题还好吧。只是并不像划重点那么多，大概总结一些供学弟学妹们备考。选择题填空题正常，注意填空题会出多一些对抗网络内容，GAN的公式，还有BP神经网络的概念，信息过滤什么的没有出。可能是第一年，之后也可能会出的，计算题常规，一道计算卷积，一道AC自动机，简答题讲了一些基本的概念，最后一道大题说的第二个实验内容，要求设计一种模型来检测Deepfake虚假人脸，是对实验的理解。总体难度还是有的，看平时对于这部分的理解。只靠期末考试的复习是不足够的，希望学弟学妹们好好学习！不过还是可以达到中等分数，考研的同学可以依据自己的目标进行选择做法。</p>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息与内容安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全基础</title>
      <link href="/2021/06/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/06/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ol><li>计算机安全概念<br>计算机安全核心地位的3个关键目标：机密性、完整性、可用性。<br>还有2个：真实性、可计量性。</li><li>OSI安全框架</li></ol><ul><li>安全攻击<ul><li>主动攻击<br>包含数据流的改写和错误数据流的添加。<br>划分4类：假冒、重放、改写消息、拒绝服务。</li><li>被动攻击<br>包含2种主要形式：消息内容泄露和流量攻击。<br>对抗被动攻击的重点是防范而不是检测。</li></ul></li><li>安全服务<ul><li>认证<ul><li>对等实体认证</li><li>数据源认证</li></ul></li><li>访问控制</li><li>数据机密性</li><li>数据完整性</li><li>不可抵赖性<ul><li>源</li><li>目的地</li></ul></li></ul></li><li>安全机制</li></ul><p>安全服务实现了安全策略， 而安全机制实现了安全服务。<br>3. 网络安全模型<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/1.jpg"><br>4. 网络访问安全模型<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/2.jpg"><br><strong>解决有害访问的安全机制</strong></p><ul><li>看门人功能</li><li>屏蔽逻辑</li></ul><h2 id="对称加密和消息机密性"><a href="#对称加密和消息机密性" class="headerlink" title="对称加密和消息机密性"></a>对称加密和消息机密性</h2><ol><li>密码体制<br>密码体制：对称密码体制、公钥密码体制。<br>流密码是属于对称密码体制范畴。</li></ol><p><strong>对称加密方案组成</strong></p><ul><li>明文</li><li>加密算法</li><li>密钥</li><li>密文</li><li>解密算法</li></ul><ol start="2"><li>密码分析</li></ol><ul><li>唯密文（最难破解）</li><li>已知明文</li><li>选择明文</li><li>选择密文</li><li>选择文本（最容易破解）</li></ul><p>加密的两个基本模块是：代替和置换。<br>为了抵抗统计分析破译法，香农给出了设计分组密码体制的两个一般原则: 扩散与混淆。<br>3. Feistel密码结构<br>分组越大表示越高的安全性。<br><strong>DES</strong></p><ul><li>DES属于Feistel结构，明文长度64比特，密钥长度56比特。其中最重要的部分为非线性替换S盒。</li></ul><p><strong>三重DES</strong><br>使用了3次DES算法，过程按照加密-解密-加密的顺序。<br><strong>加密</strong><br>C=E(K3,D(K2,E(K1,P)))<br><strong>解密</strong><br>P=D(K1,E(K2,D(K3,C)))<br>知道过程是反过来的就行。<br>4. AES<br>明文长度是128比特，密钥长度可以是128、192、256比特。<br><strong>每1轮4个不同的步骤</strong></p><ul><li>字节替换（使用S盒，分组逐一替换）</li><li>行移位</li><li>列混淆</li><li>轮密钥加</li></ul><ol start="5"><li>随机数与伪随机数<br>随机数</li></ol><ul><li>随机性、不可预测性。</li></ul><p><strong>伪随机数生成方法</strong></p><ul><li>真随机数发生器</li><li>伪随机数生成器</li><li>伪随机函数</li></ul><p>常用密码算法创造伪随机函数</p><ul><li>对称的分组密码</li><li>不对称的密码</li><li>散列函数和消息认证码</li></ul><ol start="6"><li>流密码和RC4</li></ol><p><strong>设计流密码考虑因素</strong></p><ul><li>加密序列有长周期</li><li>密钥流尽可能接近真随机数的性质</li><li>伪随机数生成器的输出受输入密钥值控制</li></ul><p><strong>RC4算法</strong><br>用1–256个字节(8-2048位)的可变长度密钥初始化一个256个字节的状态向量S，S的元素记为[1],S[2],…,S[255]，从始至终置换后的S包含从0到255的所有8位数。对于加密和解密，字节k是从S的255个元素中按一种系统化的方式选出的一个元素生成的。每生成一个k的值，S中的元素个体就被重新置换一次。<br>7. 分组密码工作模式<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/3.jpg"><br>问：若各中工作模式传输出现错误（错误1个比特），则会影响整体多长？<br>问：5种分组密码的工作模式中，哪几种适合用于流密码中？</p><h2 id="公钥密码和消息认证"><a href="#公钥密码和消息认证" class="headerlink" title="公钥密码和消息认证"></a>公钥密码和消息认证</h2><ol><li>MAC的定义</li></ol><p>一种认证技术利用私钥产生一小块数据，称之为消息认证码。保证了数据的完整性和真实性。还可能保证时效性。<br>很多算法都可以生成MAC，比如DES。<br>MAC的一种替代方法是使用单向散列函数，可接受变长的消息M作为输入，生成定长的消息摘要H（M）作为输出。消息摘要随消息一起以可信的形式传送。<br>2. 安全散列函数<br><strong>要求</strong></p><ul><li>输入长度可变</li><li>输出长度固定</li><li>效率高</li><li>抗原像攻击（单向性）</li><li>抗第二原像攻击（抗弱碰撞性）</li><li>抗碰撞攻击（抗强碰撞性）</li><li>伪随机性</li></ul><ol start="3"><li>SHA安全散列函数</li></ol><p>SHA-1产生160位的Hash值。SHA-2包括SHA-224、SHA-256、SHA-384、SHA-512。SHA基于散列函数MD4。<br>SHA-512的输入消息以1024位的分组为单位进行处理。<br>4. 消息认证码</p><ul><li>HMAC（基于嵌入式散列函数，如SHA-1）</li><li>CMAC（基于分组密码算法）</li></ul><ol start="5"><li>公钥密码原理</li></ol><p><strong>公钥密码方案组成部分</strong></p><ul><li>明文</li><li>密文</li><li>加密算法</li><li>解密算法</li><li>公钥和私钥</li></ul><ol start="6"><li>公钥密码系统的应用</li></ol><ul><li>加密/解密（加解密消息）</li><li>数字签名（用私钥签名，公钥验证签名）</li><li>密钥交换（例如会话密钥）</li></ul><ol start="7"><li>公钥密码RSA和DH</li></ol><p><strong>RSA</strong><br>RSA 的安全基础是大整数分解的困难性，公钥密码体制的安全基础是单向陷门函数。</p><ul><li>密钥生成阶段</li></ul><p>n=p*q（p，q是两个互素的大数）<br>不需要使用到n，需要用到n的欧拉函数t，自己设定的与欧拉函数t互素的数d作为公钥，生成的与此设定的数d互逆的数e为私钥。<br>公钥为（d，n）<br>私钥为（e，n）<br>将p和q销毁</p><ul><li>消息加密和解密阶段</li></ul><p>消息M<br>加密后得到C=M^d(mod n)<br>解密后得到M=C^e(mod n)</p><ul><li>手动计算难点</li></ul><p>大数的模幂运算、求模逆运算。<br><strong>DH</strong><br>存在中间人攻击。第三者分别与两方进行密钥共享，注意这个密钥共享共享的密钥是对称钥。即计算出来的密钥是同一个密钥。之后两方加密和解密都用这个密钥。</p><ul><li>前提</li></ul><p>双方共享一个素数q和a，a &lt; q，q是一个本原根。（a是q的本原根）</p><ul><li>过程</li></ul><p>利用了求离散对数难的原理，素数a作为底，双方用私钥利用模（q）指数生成公钥，传输公钥。<br>双方再用公钥作为底，指数为各自的私钥，计算得到的是双方协商出来的对称钥。</p><ul><li>中间人攻击</li></ul><p>中间人攻击相当于两步DH过程，与A协商一个密钥m，与B协商一个密钥n。同时与A、B交流，达到攻击的效果。<br>8. 数字签名标准DSS</p><h2 id="密钥分配和用户认证"><a href="#密钥分配和用户认证" class="headerlink" title="密钥分配和用户认证"></a>密钥分配和用户认证</h2><ol><li>密钥类型</li></ol><p><strong>基本密钥 Base Key</strong><br>又称初始密钥、用户密钥，是由用户选定或由系统分配给用户，在较长时间（相对于会话密钥）内由一对用户所专用的密钥。<br><strong>会话密钥 Session Key</strong><br>两个通信终端用户在一次通话或交换数据时使用的密钥。<br><strong>密钥加密密钥 Key Encrypting Key</strong><br>用于对会话密钥或文件密钥进行加密时采用的密钥，又称辅助二级密钥(Secondary Key)或密钥传送密钥(key Transport key)。<br><strong>主机主密钥 Host Master Key</strong><br>是对密钥加密密钥进行加密的密钥，存于主机处理器中。<br>在公钥体制下还有公开密钥、秘密密钥、签名密钥之分。<br>2. Kerberos<br>KDC—-密钥分发中心<br><strong>两种票据</strong></p><ul><li>票据授权票据 （Ticket granting ticket）</li></ul><p>票据授权票据由AS发放<br>Tickettgs 在用户登录时向AS申请一次，可多次重复使用</p><ul><li>服务授权票据（Service granting ticket）</li></ul><p>是客户访问应用服务器时需要提供的票据<br>用TicketV表示访问应用服务器V的票据<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/4.jpg"></p><ol start="3"><li>公钥证书X.509</li></ol><p>X.509的核心是与每个用户相关的公钥证书。这些用户证书由一些可行的签证机构（CA）创建并被CA或用户放入目录服务器中。目录服务器本身不创建公钥和证书，仅为用户获得证书提供一种简单的存取方式。<br><strong>证书链</strong><br><strong>证书撤销列表CRL</strong><br><strong>PKIX模型</strong></p><ul><li>端实体</li><li>认证中心</li><li>注册中心</li><li>CRL发放者</li><li>存储库</li></ul><h2 id="网络访问控制和云安全"><a href="#网络访问控制和云安全" class="headerlink" title="网络访问控制和云安全"></a>网络访问控制和云安全</h2><ol><li>网络访问强制措施</li></ol><ul><li>IEEE 802.1X</li></ul><p>这是一个链接层协议，在一个端口被分配IP之前必须强制进行认证。IEEE 802.1X在认证过程中使用了可扩展认证协议。</p><ul><li>虚拟局域网(VLAN)</li></ul><p>由互连的局域网组成的企业网络被逻辑划分为许多VLAN，NAC系统根据安全需求，决定将网络中的哪一个虚拟局域网分配给用户。</p><ul><li>防火墙</li></ul><p>防火墙允许或者拒绝主机与外部的网络数据流，提供一种基于安全策略的网络访问控制。</p><ul><li>动态主机配置协议(DHCP)管理</li></ul><p>DHCP为主机动态分配IP地址，通过IP地址的控制分配，实现网络的访问控制。</p><ul><li>PPPoE认证</li><li>Web portal认证</li></ul><ol start="2"><li>可扩展认证协议结构(EAP)<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/5.jpg"></li><li>基于端口的网络访问控制<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/6.jpg"></li></ol><h2 id="传输层安全"><a href="#传输层安全" class="headerlink" title="传输层安全"></a>传输层安全</h2><ol><li>SSL体系结构<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/7.jpg"><br>SSL协议中重要概念：SSL会话、SSL连接。<br>SSL中定义的3个较高层协议分别是：握手协议、修改密码规范协议、警报协议。</li></ol><ul><li>SSL记录协议</li></ul><p>对各种更高层协议提供基本的安全服务。<br>保证了机密性和完整性。<br>步骤：数据分块、压缩、加MAC、加密、添加SSL记录头、作为1个TCP分组发送。</p><ul><li>SSL握手协议</li></ul><p><strong>4步握手</strong></p><ul><li>客户端请求并且相互协商协议版本和随机数等信息</li><li>服务器发送证书</li><li>客户端发送证书</li><li>更改密码套件生成主密钥</li></ul><ol start="2"><li>HTTPS</li></ol><p><strong>通信为以下元素加密</strong></p><ul><li>要求文件的URL</li><li>文件的内容</li><li>浏览器表单的内容</li><li>浏览器与服务器的Cookie</li><li>HTTP报头的内容</li></ul><p><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/8.jpg"></p><h2 id="无线网络安全"><a href="#无线网络安全" class="headerlink" title="无线网络安全"></a>无线网络安全</h2><ol><li>无线网络安全常见威胁<br>偶然连接、恶意连接、身份盗窃、中间人攻击、拒绝服务、网络注入、Ad hoc网络。</li><li>802.11网络组成与架构模型<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/9.jpg"></li><li>IEEE 802.11i操作阶段</li></ol><p><strong>分为5个阶段</strong></p><ul><li>发现</li><li>认证</li><li>密钥管理</li><li>数据传输</li><li>终止连接</li></ul><p><strong>所有阶段</strong><br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/10.jpg"><br><strong>发现和认证阶段</strong><br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/11.jpg"><br><strong>密钥管理阶段</strong><br>在密钥管理阶段期间，各种加密密钥被生成并分发给各个STA。<br>有两种类型的密钥</p><ul><li>用于STA和AP间通信的成对密钥</li><li>用于组播通信的群组密钥</li></ul><p><strong>各种密钥</strong></p><ul><li>AAAK，根密钥，最初始的密钥，认证、计数、授权并且生成其他密钥功能。</li><li>PSK，预分享密钥，生成PMK。</li><li>PMK，成对主密钥，生成PTK。</li><li>GMK，群组主密钥，生成GTK。</li><li>PTK，成对临时密钥，加密。</li><li>GTK，群组成对密钥，加密。</li><li>TK，临时密钥，单播用户信息加密。</li><li>MIC，消息完整码密钥，保证完整性。</li><li>WEP，有线等效保密密钥，交换密钥。</li></ul><p><strong>成对密钥发布阶段</strong><br>被称为4次握手，4个组成部分如下。<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/12.jpg"></p><ul><li>访问接入点—-&gt;站点，发送MAC地址和1个随机数</li><li>站点—-&gt;访问接入点，站点用2个随机数和MAC地址和成对组密钥生成成对临时密钥，包含消息完整性字段。令访问接入点也生成此承兑临时密钥。</li><li>访问接入点—-&gt;站点，访问接入点使用密钥重发第一次相同内容，包含消息完整性字段。</li><li>站点—-&gt;访问接入点，确认消息，包含消息完整性字段。</li></ul><h2 id="电子邮件安全"><a href="#电子邮件安全" class="headerlink" title="电子邮件安全"></a>电子邮件安全</h2><ol><li>PGP的操作<br>认证（数字签名）、保密（消息加密）、压缩和电子邮件兼容性。</li><li>S/MIME<br>基于RSA的安全性基础。</li><li>PGP为什么在压缩前生成签名？<br>顺序：签名—-压缩—-加密<br>压缩对邮件传输或存储都有节省空间的好处。</li></ol><p><strong>签名后压缩的原因</strong><br>不需要为检验签名而保留压缩版本的消息。<br>为了检验而再做压缩不能保证一致性，压缩算法的不同实现版本可能会产生不同的结果。<br><strong>压缩之后再做加密的原因</strong><br>压缩后的消息其冗余小，增加密码分析的难度<br>若先加密，则压缩难以见效<br><strong>E-mail兼容性</strong><br>PGP处理后的消息，部分或者全部是加密后的消息流，为任意的8位字节。某些邮件系统只允许ASC字符，所以PGP提供了转换到ASC格式的功能。采用了Radix-64转换方案。</p><h2 id="IP安全"><a href="#IP安全" class="headerlink" title="IP安全"></a>IP安全</h2><ol><li>IP协议<br>IP是TCP/IP协议族中至关重要的组成部分, 但它提供的是一种不可靠、无连接的的数据报传输服务。</li></ol><ul><li>不可靠（unreliable)</li></ul><p>不能保证一个IP数据报成功地到达其目的地。错误处理办法：扔掉该数据报，向其发送着传送一个ICMP消息。</p><ul><li>无连接（connectionless）</li></ul><p>IP并不维护关于连续发送的数据报的任何状态信息。每个数据报单独处理，在传送过程中可能出现错序。<br>2. IPsec的原理<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/13.jpg"><br>3. IPSec的规范<br>IPSec包括三种功能：认证、机密性和密钥管理。<br><strong>包含以下多种规范（未详细列出）</strong></p><ul><li>认证报头(AH) RFC4302：用于提供消息认证的扩展头。 </li><li>封装安全载荷(ESP) RFC4303 ：ESP包含了一个封装的用来提供加密或者机密和认证的结合。</li><li>因特网密钥交换(IKE) RFC4306：用于IPSec的密钥交换方案。</li></ul><ol start="4"><li>传输模式和隧道模式</li></ol><ul><li>传输模式Transport Mode</li></ul><p>用于两个主机之间的端到端通信，传输模式为上层协议提供保护，保护扩充到IP分组的有效载荷，用于两个主机之间的端到端通信。传输方式ESP对有效载荷加密并可选认证；AH认证IP有效载荷和IP首部的选中部分。</p><ul><li>隧道模式Tunnel Mode</li></ul><p>适用于当SA的一端或两端是安全网关，隧道模式对整个IP分组提供保护。原始的分组加安全域被当做一个新IP分组的载荷，并拥有一个新的外部IP报头, 通过“隧道”从IP网络的一端传输到另一端。适用于当SA的一端或两端是安全网关, 例如实现了IPSec的防火墙或路由器的情况，防火墙之后的网络主机可以不用实现IPSec而参加安全通信。<br>隧道模式中, ESP加密和认证(可选)整个内部IP包, AH认证整个内部IP包和外部IP报头中的选中部分。<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/14.jpg"><br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/15.jpg"><br>5. 安全关联<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/16.jpg"><br>安全关联SA是在发送者和的接收者之间的一种单向关系，如果需要一个对等的关系用于双向的安全交换，就要用两个安全关联。提供给一个SA的安全服务用于AH或ESP，但不能同时用于两者。<br><strong>安全关联由三个参数标识</strong></p><ul><li>安全参数索引SPI：SPI加载在AH和ESP的首部，使接收系统能够选择SA来处理接收的分组。</li><li>IP目的地址：SA的目的地址，端用户或网络。</li><li>安全协议标识符：标识该关联是否AH或ESP安全关联。</li></ul><ol start="6"><li>IPSec ESP Header格式</li></ol><p><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/17.jpg"><br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/18.jpg"><br><strong>填充域有如下几个作用</strong></p><ul><li>填充域用于把明文(包括载荷数据、填充、填充长度、邻接报头域)扩展到需要的长度 (如分组加密要求明文是分组长度的整数倍) 。</li><li>ESP格式要求填充长度和邻接报头域为32比特的字，密文也是32比特的整数倍，填充域用来保证这样的排列。</li><li>增加额外的填充能隐藏载荷的实际长度，从而提供部分流量的保密。</li></ul><ol start="7"><li>窗口与重放攻击检测</li></ol><ul><li>重复的接收经过认证的IP包可能会以某种方式中断服务或产生一些不希望出现的结果。</li><li>序列号能阻止重放攻击。每建立一个新的SA，发送方把序列号计数器的初始值设为0，每次在SA上发送一个包，则发送方增加计数器的值。</li><li>IP提供无连接且不可靠的分组投递服务，不能保证分组能按照顺序传输，也不能保证无丢失。IPSec规定接收方应该实现一个大小为W的窗口(W的默认值为64)。</li></ul><p><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/19.jpg"><br>8. 密钥确定协议<br>基于DH交换<br>DH交换的缺陷</p><ul><li>没有身份标识和认证</li><li>易受中间人攻击</li><li>算法的模指运算代价高，易受阻塞Clogging攻击（Clogging攻击是一类面对公钥密码系统的DoS攻击）。</li></ul><p><strong>IKE密钥确定的特性</strong></p><ul><li>使用Cookie机制来抵御阻塞Clogging攻击</li><li>允许协商公共参数，即DH中的公共参数</li><li>使用随机数防止重放攻击</li><li>可以交换DH的公钥值</li><li>对DH交换进行认证，防止中间人攻击</li></ul><p><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/20.jpg"><br>9. IPSec的优点和路由应用<br><strong>IPSec的优点</strong></p><ul><li>提供强大的安全性，应用于防火墙和路由器。</li><li>IPSec在传输层以下，对所有的应用透明。</li><li>IPSec对终端用户透明。</li><li>必要时可以为单个用户提供安全性。</li></ul><p><strong>路由选择应用，IPSec保证</strong></p><ul><li>路由器的通告(新的路由器通告它的存在)来自被认可的路由器。</li><li>邻站通告(一个路由器尝试与另一个路由选择域的一台路由器建立或维护邻站关系)来自被认可的路由器。</li><li>重定向报文来自于发送包的初始路由器。</li><li>路由选择更新不会被假造。</li></ul><h2 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h2><ol><li>病毒</li></ol><p><strong>组成部分（1或多或重复包含）</strong></p><ul><li>感染机制</li><li>触发</li><li>载荷</li></ul><p><strong>生命周期</strong></p><ul><li>休眠阶段</li><li>传播阶段</li><li>触发阶段</li><li>执行阶段</li></ul><p><strong>按目标分类</strong></p><ul><li>引导扇区感染病毒</li><li>文件感染病毒</li><li>宏病毒</li><li>混合体病毒</li></ul><p><strong>按隐藏策略分类</strong></p><ul><li>加密病毒</li><li>隐形飞机式病毒</li><li>多态病毒</li><li>变形病毒</li></ul><p><strong>分布式拒绝服务攻击DDoS</strong></p><h2 id="入侵者"><a href="#入侵者" class="headerlink" title="入侵者"></a>入侵者</h2><ol><li>常用的入侵检测方法</li></ol><p>统计异常检测，定义通常的或期望的行为。</p><ul><li>阈值检测</li><li>基于行为曲线</li></ul><p>基于规则的检测，定义合适的行为。</p><ul><li>异常检测</li><li>渗透检测</li></ul><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><ol><li>防火墙类型</li></ol><ul><li>包过滤防火墙</li><li>状态检测防火墙</li><li>链路层网关</li><li>应用层网关</li></ul><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>考试还行，不算难，有一些细节方面真的得看书，看课本，不过这是对于考高分比如九十加要把课本研读一遍。其他的同学把老师划的重点部分仔细理解！比如IPSec的结构等等。一般般难度，不过每个人对自己要求不一样，尽量学好吧杨超老师经典话语：这是你吃饭的本事！</p>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全高级内存访问漏洞</title>
      <link href="/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/"/>
      <url>/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>主体结构是这样的</strong></p><ul><li>高级堆内存访问漏洞<ul><li>双重释放（double-free）</li><li>释放重引用（use-after-free）</li></ul></li><li>一些其他的Web安全漏洞<ul><li>跨站脚本（XSS）</li><li>跨站请求伪造（CSFR）</li></ul></li></ul><h2 id="回顾堆块的分配与释放机制"><a href="#回顾堆块的分配与释放机制" class="headerlink" title="回顾堆块的分配与释放机制"></a>回顾堆块的分配与释放机制</h2><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/1.jpg"></p><ul><li>堆空间的管理本质上是对bin链表的维护。</li><li>堆块释放后，原本指向它的指针并不自动销毁。</li><li>结果：指针悬空（指向未使用的内存，但仍然可以引用该空间）。</li></ul><blockquote><p>堆空间由用户而不是系统管理，所以指针不自动销毁。所以c 指针是不安全的。</p></blockquote><h2 id="双重释放漏洞"><a href="#双重释放漏洞" class="headerlink" title="双重释放漏洞"></a>双重释放漏洞</h2><p><strong>那么，如果尝试释放一个悬空指针所引用的内存，会如何？</strong><br>free()函数中对此的规定：“undefined behavior”。<br>问题的爆发点：堆块合并和unlink。<br><strong>示例</strong></p><ol><li>一个空的bin表项与一个对应尺寸的堆块P（已分配）看上去就像这样。</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/2.jpg"></p><ol start="2"><li>当堆块P被释放，bin表项变成了这样。表示指针悬空，堆块的前向指针和后向指针都已经指向bin中。</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/3.jpg"><br>3. 如果再次释放P，则free()的原理使得bin表项发生了下面的情况。</p><p>释放P对应合并和unlink，目前看来不是向后合并，而是向前合并，即将P的next chunk（P-&gt;FD）从链中摘除。被摘除的自己指针不动，前后块的指针修改。<br>P-&gt;FD-&gt;FD-&gt;BK = P-&gt;FD-&gt;BK 即 <strong>P-&gt;BK = P</strong><br>P-&gt;FD-&gt;BK-&gt;FD = P-&gt;FD-&gt;FD 即 <strong>P-&gt;FD = P</strong></p><blockquote><p>分配P就是要把P前后块链起来，也就是要让P-&gt;fd-&gt;bk = P-&gt;bk, P-&gt;bk-&gt;fd = P-&gt;fd</p></blockquote><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/4.jpg"></p><ol start="4"><li>此时，如果系统试图将堆块P分配出去，就可能导致分配后fd和bk会被用户数据覆盖。</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/5.jpg"></p><ol start="5"><li>如果系统再次试图分配一个与P同样大小的块。就要把P的指针再改，此时P的fd和bk会影响到前后块中的地址信息。类似于前向合并漏洞，可以用来修改特定函数的入口地址。</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/6.jpg"></p><ol start="6"><li>代码解释</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/7.jpg"></p><p>第22行意思是把fd里面放 strcpy()地址-12。</p><p>第23行意思是bk里面放shellcode地址,一个指针长度4字节。fd指针地址+4字节是bk指针地址。</p><p>第24行再分配这个chunk，此时因为chunk被unlink，调用unlink函数。分配就是要把P前后块链起来，也就是要让, P-&gt;fd-&gt;bk = P-&gt;bk, P-&gt;bk-&gt;fd = P-&gt;fd。</p><p>先是：shellcode地址赋给strcpy()地址-12+12，然后：strcpy()地址-12写入到shellcode地址-4。</p><p>第25行strcpy()被调用时，调用shellcode。</p><h2 id="双重释放重引用"><a href="#双重释放重引用" class="headerlink" title="双重释放重引用"></a>双重释放重引用</h2><p>双重释放可以认为是释放重引用漏洞的一个特例<br><strong>释放重引用漏洞的一般流程</strong></p><ul><li>申请一段空间，将其释放但并不将指针置为空（这个悬空指针记为p1）。</li><li>申请空间p2，由于malloc分配的过程使得p2指向的空间为刚刚释放的p1指针的空间。</li><li>构造恶意的数据将p2指向的内存空间布局好（即覆盖了p1中的数据）利用p1。</li></ul><ol><li>释放冲引用与缓冲区溢出的结合<br>通过操作溢出后的指针形成释放重引用，代码本身并未出现释放重引用漏洞。</li></ol><p><strong>合法指针在溢出后越界指向空闲块，在此块被分配后就有两个指针指向它。</strong><br>2. 释放重引用的潜在后果<br>一般地，攻击会尝试<strong>劫持函数指针</strong>，造成<strong>不同指针引用同一内存区域</strong>。<br><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/8.jpg"></p><h2 id="跨站脚本"><a href="#跨站脚本" class="headerlink" title="跨站脚本"></a>跨站脚本</h2><ol><li>原理：即由畸形输入的构造，使攻击方得以以访问者的身份在站点执行HTML代码。</li><li>本质：是对HTML的注入攻击。</li><li>主要分类</li></ol><ul><li>反射型XSS</li></ul><p>它通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数被HTML解析、执行。它的特点是非持久化，必须用户点击带有特定参数的链接才能引起。非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。</p><ul><li>存储型XSS</li></ul><p>持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie等。</p><ul><li>基于DOM的XSS</li></ul><h2 id="跨站请求伪造"><a href="#跨站请求伪造" class="headerlink" title="跨站请求伪造"></a>跨站请求伪造</h2><ol><li>示例</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/9.jpg"></p><ol start="2"><li>针对跨站脚本/请求伪造的防御措施</li></ol><ul><li>浏览器/站点增加针对性的过滤机制<ul><li>标签</li><li>关键字</li><li>特殊符号</li></ul></li><li>在URL请求中引入伪随机数<ul><li>类似SQL请求的随机化</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉学习过程是一个了解的阶段，并没有深入一个层次去知晓它，不过慢慢接受知识也是一个良性的过程。</p>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全SQL注入</title>
      <link href="/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入和数组越界访问漏洞"><a href="#SQL注入和数组越界访问漏洞" class="headerlink" title="SQL注入和数组越界访问漏洞"></a>SQL注入和数组越界访问漏洞</h2><p><strong>大致内容</strong></p><ul><li>SQL注入漏洞<ul><li>实现原理及后果</li><li>现有的相关应对措施</li></ul></li><li>数组越界访问漏洞</li></ul><h3 id="实现原理及后果"><a href="#实现原理及后果" class="headerlink" title="实现原理及后果"></a>实现原理及后果</h3><p><strong>B/S（浏览器和服务器）架构</strong></p><p>B/S是WEB兴起后的一种网络架构模式</p><ul><li>采用浏览器统一了客户端，将系统功能实现的核心部分集中到服务器上。</li><li>客户端使用浏览器，通过Web Server与数据库进行数据交互。</li></ul><p>B/S架构优势—-瘦客户端，胖服务端</p><ul><li>将系统实现的核心部分集中在服务端，简化系统的开发。</li><li>客户端载荷降低，减轻系统维护和升级成本。</li></ul><p><strong>数据库与SQL简介</strong></p><p>数据库：大型软件系统的关键基础设施。</p><ol><li>有结构的、有组织（集成）的、可共享的统一管理的数据集合。</li><li>具有尽可能小的冗余度、较高的数据独立性和易扩展性。</li><li>应用场景 — Web后台数据、企业级联机事务处理。</li></ol><p>结构化查询语言(Structured Query Language, SQL)，用户存取数据、查询、更新和管理关系数据库系统。注意：独立于数据库本身、硬件、网络以及操作系统。</p><ol><li>特殊目的编程语言。</li><li>数据库查询+程序设计语言。</li><li>屏蔽底层细节的高级数据库操作语言。</li></ol><p>SQL语言核心结构。</p><ul><li>做什么事情。</li><li>要找哪个对象做。</li><li>怎么做这件事情。</li><li>怎么找到这个对象（约束条件）。</li></ul><p>SQL注入出现原因：程序员的水平及经验也参差不齐，相当大一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。</p><p>SQL注入过程：把SQL命令插入到web表单递交或输入域名或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。<strong>SQL命令伪装成数据。</strong></p><p><strong>SQL注入原理</strong><br><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8SQL%E6%B3%A8%E5%85%A5/1.jpg"></p><p><strong>SQL注入过程</strong></p><ol><li>寻找可能存在SQL注入漏洞的链接</li><li>测试该网站是否有SQL注入漏洞</li><li>猜管理员帐号表</li><li>猜测管理员表中的字段</li><li>猜测用户名和密码的长度</li><li>猜测用户名</li><li>猜测密码</li></ol><p><strong>初级的注入</strong></p><ul><li>判断是否存在注入</li></ul><p>对于可能存在SQL注入的动态网页，只要该网页带有参数且此网页访问了数据库，则有可能存在注入<br><code>http://xxx.xxx.xxx/abcd.php?id=XX</code><br>给参数赋值单引号，查看页面变化（单引号不匹配而报错，则表示执行了SQL）<br><code>http://xxx.xxx.xxx/abcd.php?id=XX’</code><br>若未报错，可能做了单引号过滤，使用判断语句进行注入测试（SQL注入漏洞分为数字型和字符型）</p><ul><li>数字型漏洞</li></ul><p><code>http://xxx.xxx.xxx/abcd.php?id=XX</code><br>若XX为数字类型，例如页码、ID等，存在注入时则为数字类型的注入。<br>给参数赋值为and 1=1，页面正常。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX and 1=1</code><br>接着给参数赋值为and 1=2，页面报错。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX and 1=2</code></p><ul><li>字符型漏洞</li></ul><p><code>http://xxx.xxx.xxx/abcd.php?id=XX</code><br>若XX为字符串，注入测试需使用单引号来闭合。<br>给参数赋值为and 1=1，页面正常。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX ‘and ’1‘=’1</code><br>接着给参数赋值为and 1=2，页面报错。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX ‘and ’1‘=’2</code></p><ul><li>猜管理员账号表</li></ul><p>在末尾加上：<code>and exists (select * from admin)</code><br>我们的意思是猜测他有个admin表段。页面返回正常，我们猜对了。当然也可能错误返回，这时就要看猜测的本事了。</p><ul><li>猜测管理员表表中的字段</li></ul><p>我们再来猜他的管理员表中是否有一个ID段，在末尾加上：<code>and exists (select id from admin)</code><br>页面返回正常,说明他的admin表中有个id的字段。<br>我们继续： <code>and exists (select username from admin)</code>。这里的意思是看看他的admin表中是否有username字段，页面返回正常,说明在admin中有一个username字段<br>我们继续猜他放密码的字段： <code>and exists (select password from admin)</code>。返回正常的页面,说明他的admin表中有个password字段。<br>到此可以知道admin表中至少有如下三个字段：id,username,password，这种命名方式与普通程序员的命名方法一致。</p><ul><li>猜测用户名和密码的长度</li></ul><p>首先猜他的管理员的id值： <code>and exists (select id from admin where id=1)</code>，意思是看看他的admin表中是否有一个id=1的值。<br>返回了正常的页面,说明我们猜对了。<br>接着猜ID为1的用户名长度： <code>and exists (select id from admin where len(username)&lt;6 and id=1)</code><br>这里我们猜他的管理员长度小于6,返回了正常的页面,还好,名字不是太长,我们一个个来实验好了。<br><code>and exists (select id from admin where len(username)=5 and id=1)</code>，返回了正常的页面,说明用户名的长度我们已经猜出了为5。<br>用同样的方法，我们猜出了密码的长度是10，要添加的语句是：<code> and exists (select id from admin where len(password)=10 and id=1)</code><br>到此，用户名和密码的长度都已经猜出来了，下面要做的是猜出它们的每一位分别是多少。<br>方法是在后面加上： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,1,1))&lt;100)</code><br>我们这里做的意思是，猜测他的用户名的第一个字的ascii码值小于100。</p><blockquote><p>其中，asc函数的功能是将字符转换成ASCII码，mid函数的功能是截取username字段值的字串，从第1位开始，截取的长度是1</p></blockquote><p>返回了正常页面，说明的确如我们所料，接着： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,1,1))&lt;50)</code><br>返回错误信息，说明：50&lt;=第一个字的ascii码值&lt;100。接下来，我们用折半查找的思想： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,1,1))&lt;75)</code><br>接下来我们猜测第二位： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,2,1))&lt;100)</code><br>用折半查找的思想，采取上述方式，很快就能找到密码。</p><blockquote><p>注意：网站上密码多是以杂凑值处理，需要专用的哈希函数破解。尽管哈希函数是单向的，然而用户的密码是有限长度的，可以预先存储计算匹配，而非反向破解。</p></blockquote><p><strong>高级的注入</strong></p><ol><li>大小写绕过。</li><li>双写绕过。</li><li>等效语言表达绕过。</li><li>科学计数法、括号绕过。</li><li>浮点数、括号绕过。</li><li>内联注释绕过。</li><li>子查询、join联合绕过。</li></ol><h3 id="现有相关应对措施"><a href="#现有相关应对措施" class="headerlink" title="现有相关应对措施"></a>现有相关应对措施</h3><ol><li>对SQL请求的动态解析树，采用SQL引擎预先对SQL语法进行分析，生成该SQL语句的语法树。对客户端输入的参数中的SQL命令解析为字符串字面值参数，进而不会执行。</li><li>对用户输入的参数进行严格的匹配以及过滤。</li><li>设置用户操作数据库的权限。</li></ol><h2 id="数组越界访问漏洞"><a href="#数组越界访问漏洞" class="headerlink" title="数组越界访问漏洞"></a>数组越界访问漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>溢出与越界不完全相等</p><ul><li>数组越界分为读/写两种情况，而溢出漏洞属于越界写入。</li><li>一些溢出漏洞的本质是数组越界。</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#123;      int x[10];        cout &lt;&lt; x[10]; &#125;&#x2F;&#x2F;直观的数组越界可以在编译时较容易地检查出来，但是……&#123;      int i, x[10];        &#x2F;&#x2F;对i进行算术运算      cout &lt;&lt; x[i]; &#125;&#x2F;&#x2F;用法是允许的，存在越界的可能，但编译器无法指出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="举例与分析"><a href="#举例与分析" class="headerlink" title="举例与分析"></a>举例与分析</h3><p>CVE-2014-0160“OpenSSL数组越界访问漏洞”(Heartbleed心脏滴血) 。</p><p>成因–处理heartbeat response时没有检查包长度的合法性，直接分配相应大小的内存。</p><p>TLS和DTLS在处理心跳请求包逻辑中，从堆空间上申请的内存大小由type、length、request的数据长度和payload四个部分组成，其中type,length,payload字段分为占1byte，2byte，16byte，所以response的数据总是比request的多出来19byte。</p><p>length（心跳包的长度）是用户可控的，而payload（也是储存长度）是也是用户可控的，那么当payload长度大于心跳包的长度，那么就可以读取内存中心跳包后面的数据了。</p><p><strong>C语言的数组越界为何难以检查？</strong></p><ul><li>性能⟺安全。</li><li>指向数组元素的指针和数组本身是完全独立的。</li><li>指针运算的可行性。</li><li>用指针表示范围，不仅需要指针本身存在且可用，还需要指针指向的内存可用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全其他溢出漏洞</title>
      <link href="/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="本文大致内容"><a href="#本文大致内容" class="headerlink" title="本文大致内容"></a>本文大致内容</h2><ul><li>整数溢出<ul><li>数值计算的基本原理</li><li>整数溢出及其可能的后果</li></ul></li><li>格式化字符串漏洞<ul><li>类printf函数簇实现原理</li><li>格式化字符串攻击原理及潜在后果</li></ul></li></ul><p>在这一章节似乎只是在计算机中实现，更偏向于怎么将漏洞在计算机上实现，对于一些常见的编程中出现的漏洞，也似乎不能叫出现的漏洞吧，应该是编译器的漏洞。对一些边界问题的规定是否规范，还是任由编译器自己决定，决定着这个漏洞是否可以被实现。通过打印出一些内存中具体的值，为后来的其他溢出做了铺垫。</p><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><h3 id="数值计算的基本原理"><a href="#数值计算的基本原理" class="headerlink" title="数值计算的基本原理"></a>数值计算的基本原理</h3><ul><li>整数的表示</li></ul><p><strong>64位</strong><br>类型：short（16bit）、int（32bit）、long（64bit），8字节<br>带符号：-2^（n-1)-2^（n-1）-1、不带符号：0-2^n-1<br><strong>32位</strong><br>long（32bit），4字节</p><ul><li>带符号整数格式中的补码</li></ul><ol><li>带符号的正护士统一用补码表示（正整数和负整数都是）。</li><li>意义：符号位和数值域统一，加法和减法统一。</li></ol><blockquote><p>对于正数原码、反码以及补码是其本身。负数的原码是其本身，反码是对原码除符号位之外的各位取反，补码则是反码加1。</p></blockquote><ul><li>整数的加减法</li></ul><p><strong>CF是无符号数溢出标志，OF是有符号数溢出标志。</strong></p><p>CF/OF=1，则表示计算结果溢出。</p><ol><li>CF的判断<ul><li>加法<br>十进制角度，如果两个无符号数相加，结果大于阈值，则CF=1，否则CF=0。<br>二进制角度，如果两无符号数相加，最高位向前进位，则CF=1，否则CF=0。</li><li>减法<br>十进制角度，两无符号数相减，减数大于被减数，则CF=1，否则CF=0。<br>二进制角度，如果两无符号数相减，最高位向前有借位，则CF=1，否则CF=0。</li></ul></li><li>OF判断<ul><li>加法<br>十进制角度，两有符号数相加，结果不在范围内，则OF=1，否则OF=0。<br>二进制角度，如果两有符号数同号，得到的结果异号，则OF=1，否则OF=0。</li><li>减法<br>十进制角度，两有符号数相减，结果不在范围内，则OF=1，否则OF=0。<br>二进制角度，如果两有符号数异号，得到的结果与被减数符号相反，则OF=1，否则OF=0。</li></ul></li></ol><p>整数溢出的例子中需要注意</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int atoi(const char *nptr);&#x2F;&#x2F;用法：将字符串里的数字字符转化为整形数。返回整形值。&#x2F;&#x2F;注意：转化时跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(&#39;&#x2F;0&#39;)才结束转换，并将结果返回。void *memcpy(void *destin, const void *src, size_t n);&#x2F;*由src指向地址为起始地址的连续n个字节的数据复制到以destin指向地址为起始地址的空间内。　　函数返回一个指向destin的指针。说明    1. source和destin所指内存区域不能重叠，函数返回指向destin的指针。    2. 与strcpy相比，memcpy并不是遇到&#39;\0&#39;就结束，而是一定会拷贝完n个字节。    3. 如果目标数组destin本身已有数据，执行memcpy（）后，将覆盖原有数据（最多覆盖n）。如果要追加数据，则每次执行memcpy后，要将目标数组地址增加到你要追加数据的地址。注意，source和destin都不一定是数组，任意的可读写的空间均可。*&#x2F;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在C语言中的表示</li></ul><p>在C/C++语言中，char变量为一个字节，8位，signed char表示的范围：-128-127【-128在内存中的二进制表示为1000 0000，127在内存中的表示为0111 1111】；unsign char表示的范围：0000 0000-1111 1111，即0-255；<br>默认是signed还是unsigned取决于编译器。</p><p>因为size是字节数，所以要*8，这样unsigned取模刚好是对它的表示范围取模。<br>左边是无符号型全1，是最大值+1=0<br>右边是0111 1111 = 127，也是最大值，+1=128，实际上溢出了，超出了表示范围。1 000 0000=-128</p><blockquote><p>C语言中的表示不是很一样，如果取无符号，则只表示之前范围的非负数的那部分。</p></blockquote><h3 id="整数溢出及其可能的后果"><a href="#整数溢出及其可能的后果" class="headerlink" title="整数溢出及其可能的后果"></a>整数溢出及其可能的后果</h3><p><strong>例如</strong></p><ol><li>举例1</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/1.jpg"></p><p>若将MAX_LEN设置为32767，同时，假设buf的值总为2，实际结果：当len==32766时，line 6 造成len的值变为-32768，程序死循环</p><p>32767是signed short上限，len=32766时，+2溢出，如果不规定处理方式则变为最小值-32768。程序无法跳出循环。</p><ol start="2"><li>举例2</li></ol><p>又如：abs(-2147483648) &lt; 0</p><p>函数abs的功能 — 对于输入参数为正，返回其本身，否则返回其相反数。<br>然而，对于-2147483648（int类型的最大负数值），函数abs返回的是其本身。</p><p>可见，整数溢出至少可能产生以下一些后果</p><ul><li>产生逻辑谬误，造成程序在执行中卡死或者出错</li><li>为后续的缓冲区溢出充当引信</li></ul><p>一些防范整数溢出的编程习惯</p><ul><li>对整数溢出的检查必须出现在可能溢出的位置之前，否则就有可能不起作用</li><li>注意类型强制转换（或者说，注意指针的使用）</li><li>同等地重视上溢和下溢，两者都需要预先检查</li></ul><p><strong>整数溢出的防护</strong></p><ol><li>IntScope — 检测整数溢出本身</li></ol><p>利用符号执行、动态污点跟踪等分析运行时数据流，寻找异常。</p><ol start="2"><li>IntPatch — 检测并修复后续的缓冲区溢出漏洞</li></ol><p>针对：整数溢出到缓冲区溢出（IO2BO）</p><h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><h3 id="类printf函数簇实现原理"><a href="#类printf函数簇实现原理" class="headerlink" title="类printf函数簇实现原理"></a>类printf函数簇实现原理</h3><ul><li>类printf函数簇的第一个可利用点：参数不匹配时难以发现。<ul><li>printf()是一个参数长度可变函数，仅仅看参数数量无法发现问题。</li><li>为了查出不匹配，编译器需要了解printf()的运行机制，然而编译器通常不做这类分析。</li><li>若格式字符串在程序运行期间生成(如用户输入)，则编译器无法发现不匹配。</li></ul></li></ul><h3 id="格式化字符串攻击原理及潜在后果"><a href="#格式化字符串攻击原理及潜在后果" class="headerlink" title="格式化字符串攻击原理及潜在后果"></a>格式化字符串攻击原理及潜在后果</h3><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2.jpg"></p><blockquote><p>当printf在输出格式化字符串的时候，会维护一个内部指针，当printf逐步将格式化字符串的字符打印到屏幕，当遇到%的时候，printf会期望它后面跟着一个格式字符串，因此会递增内部字符串以抓取格式控制符的输入值。这就是问题所在，printf无法知道栈上是否放置了正确数量的变量供它操作，如果没有足够的变量可供操作，而指针按正常情况下递增，就会产生越界访问。甚至由于%n的问题，可导致任意地址读写。</p></blockquote><ol><li>举例1</li></ol><p>如果让str=“%x”，则会发生什么？<br>%x是printf规定的一种输出类型，unsigned int，输出无符号16进制数。<br>结果：通过构造异常字符串，可以实现对程序栈结构的任意读取。</p><p><strong>为什么程序员写的是错误的呢？</strong></p><p>他传入了一个他想要逐字打印的字符串。实际上该字符串被printf函数解释为一个格式化字符（formatstring），printf就会根据该字符串来决定printf函数中省略号参数表中参数的格式和类型，如果这个程序员想要打印的字符串中刚好有“%d”,“%x”之类的格式化字符，那么一个变量的参数值就从堆栈中取出。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char* argv[])&#123;    if(argc !&#x3D; 2)        return 0;    printf(argv[1]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当./a.out “hello world”时一切正常，但是当./a.out “%x”时，就会有莫名其妙的数字被打印出来了。因为后面没跟参数，但printf以为后面有个参数，就会把当前堆栈对应的4字节（应该是高地址）以%x打印。通过特定设计，可以打印特定位置内存信息。<br>很明显，攻击者至少可以通过打印出堆栈中的这些值来偷看程序的内存。但是有些事情就不那么明显了，这个简单的错误允许向运行中程序的内存里写入任意值。</p><ol start="2"><li>举例2</li></ol><p><strong>更进一步</strong><br>%s，printf规定的另一种输出类型，char <em>/wchar_t</em>，输出字符串。</p><p>结果：通过构造异常字符串，还有可能实现对任意内存的（大面积）读取。</p><ol start="3"><li>举例3</li></ol><p><strong>再进一步</strong><br>%n，特殊printf输出类型，int*，将此前已输出的串长度写入指针所指位置。</p><p>结果：通过构造异常字符串，可以实现对任意内存的任意改写。</p><blockquote><p>%n:该符号前输入的字符数量会被存储到对应的参数中去。<br>int i; printf (“12345%n”, &amp;i);<br>数字5（%n前的字符数量）将会被写入i中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对晨晨说的话</title>
      <link href="/2021/06/22/%E5%AF%B9%E6%99%A8%E6%99%A8%E8%AF%B4%E7%9A%84%E8%AF%9D/"/>
      <url>/2021/06/22/%E5%AF%B9%E6%99%A8%E6%99%A8%E8%AF%B4%E7%9A%84%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="对晨晨说的话"><a href="#对晨晨说的话" class="headerlink" title="对晨晨说的话"></a>对晨晨说的话</h2><p><img src="../%E5%AF%B9%E6%99%A8%E6%99%A8%E8%AF%B4%E7%9A%84%E8%AF%9D/1.JPG"></p><p>今天是星期三，我很想知道什么事情，这件事情在我的心里憋了很久，我一直提醒自己不要忘记，不要记起，不要回想。不要去追寻。在多少年前，我是过着什么样的生活，在大概十年前，我知道自己在做什么吗，十年前的这个时候，我可能现在早已经进入梦乡，或者是在做其他的事，具体什么事，也是在幻想生活的改变。</p><p>我期待明天，我期待每天的早晨，现在不是如此吗？现在也是，在早上我是不会有任何烦心的事情，我总能想起梦里的事情，梦里我怎么做，怎么说，我梦到了谁，昨晚梦到了谁，今晚我要梦到谁，做怎么样的梦。我的生活是由无数人的生活促就的，他们做的改变，他们的呼吸，他们的欢笑和哭泣，让远方的我有了如此的生活。</p><p>在这一天，我遇到了这个人。我很认定我自己是对的，因为我心动了，在自己经历过如此多的事情之后，我发现自己喜欢的是什么，讨厌的是什么，不屑的是什么，甚至追求的是什么都已经模糊。在我遇到她之前，我早上是八点十分起床的，我早上吃肉夹馍，中午吃快餐，晚上吃烩面。我有时还会打游戏，在虚拟世界里沉迷一小刻，我便开始幻想，为什么我自己不能有自己的幸福。为什么爱情要如此令我受折磨，在一个孤独的冰冷的世界遨游，我要归往的是哪里，我是会要做一个没有经历过青春的人吗？还是要在无数个不愿意睁开眼，知道世界上的某个角落的某个人仍旧孤孤零零寻找我的味道呢？</p><p>我遇到你，我想要对你说过许多话，但有很多是不足够表达我的心的。我想，我听，我思考。我最爱这样子，这样就可以慢慢规划以后的事情，我拒绝做一个精英，我想不断陪伴一个人成长。不是要面谈生意，我不愿牺牲爱情，我不愿在自己的心中磨灭对爱情的美妙的想象。你喜欢什么颜色，爱吃什么食物，喜欢冬天还是夏天，今天的天气如何，你的心情如何，有没有不舒服，有没有饿到肚子，有没有吃了不对胃口的饮食。这些问题困扰着我，我也不会知道，我不知道今天你在一棵树前停留许久，是在想，是在听，还是在发呆。想要一个人的依靠，想要一个人的照顾。</p><p>我不希望自己成为他人的迷茫点，在无数个夜晚，我都是怎么在想你，想你做什么，我怕失去你，也怕错过你。我总该想，要多和你说几句话，说有趣的事，吃可口的食物，吹凉飒的晚风，走在平常的街道，听夏日的蝉鸣。我又想在午后，吃完最后一口米饭，一起将碗筷收进厨房，看到时间还早，我不过是想靠你近一点，用纸巾擦去你嘴巴上的油。</p><p>生活如此，我梦想，幻想，还是想象。你存在吗？我不敢相信自己，我从来不会觉得自己有着足够的幸运遇到你，我知道过无数的人，无数的事。知道他们过着怎么样的生活，却没曾想终于愿意沉下心来为自己做打算，为我们的之后做安排。</p><p>夜没深，我也没有醒，希望我在梦里不会醒，你也不会从梦里走出来，在梦里，我很喜欢。喜欢你的发梢，你的脸庞，你的呼吸，你的心跳，最喜欢你无处不在的可爱。</p><p>你要吃掉我的心吗，晨晨，生活是美好的，就算眼前困惑。你要相信我。</p><p>–SS</p>]]></content>
      
      
      <categories>
          
          <category> 胜胜的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胜胜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全堆溢出</title>
      <link href="/2021/06/22/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/"/>
      <url>/2021/06/22/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/</url>
      
        <content type="html"><![CDATA[<p>这篇文章也是花了很久的时间才能说半抄半理解结束，其中有一些内容到现在还是不清楚，但愿自己慢慢思考。</p><span id="more"></span><ul><li><p>堆的构造与维护原理</p><ul><li>堆的场地和块</li><li>隐式/显示链表与堆的维护</li></ul></li><li><p>堆溢出</p><ul><li>linux系统典型堆溢出原理</li><li>现有应对策略和技术</li></ul></li></ul><h2 id="堆的工作原理"><a href="#堆的工作原理" class="headerlink" title="堆的工作原理"></a>堆的工作原理</h2><ul><li>堆与栈的区别<ul><li>栈：硬件支持；存储数据+控制流信息。</li><li>堆：操作系统的库函数支持；存储数据。</li></ul></li></ul><p>堆的创建和维护通过malloc实现。</p><p>堆内存是移动[Program Break]的位置产生的（通过brk中断），实际产生的堆比申请的堆还要大，这个连续的堆区域被称为[arena]。被主进程创建的，因此称为[main arena]。接下来申请会分配到这个arena的多余申请空间的部分。分配完毕后，它可以通过继续移动Program Break的位置扩容。扩容后，top chunk的大小也随之调整，将这块新增的空间圈进去。相应地，arena也可以在top chunk过大时缩小。top chunk是一个 arena位于最顶层的chunk。</p><blockquote><p>注意：非直接返还给系统，由malloc库函数管理，将其添加到bin。当用户再次调用，首先从bins查找是否有满足的，若没有才向操作系统申请新的堆空间，以提高整个效率。</p></blockquote><p>堆在栈创造之前便存在了，是程序运行便开始调用栈，而堆需要使用malloc函数才行。</p><h3 id="堆内存的建立"><a href="#堆内存的建立" class="headerlink" title="堆内存的建立"></a>堆内存的建立</h3><p>堆内存是使用mmap系统调用产生的，而非同主线程一样使用sbrk系统调用。用户请求的空间中略大（申请100kb，但实际映射到地址空间的有1Mb），只有132kb空间有读写权限，并成为该线程的堆内存。称之为[thread areana]。</p><p>当用户请求超过128kb，并且arena中没有足够的空间来满足用户的请求，内存将通过mmap系统调用分配（不再是sbrk），而不论请求是发自main arena还是thread arena。</p><h3 id="堆的工作原理-1"><a href="#堆的工作原理-1" class="headerlink" title="堆的工作原理"></a>堆的工作原理</h3><p>arena数量</p><ul><li>32位系统=2*内核数+1</li><li>64位系统=8*内核数+1</li></ul><p>单核32位系统，运行多线程程序—-1个主线程+3个用户线程，malloc如何令4个线程共享3个arena？</p><p>主线程分配主arena,线程1、2分别分配arena，那么线程3需要重复使用已分配好的arena.glibc malloc循环遍历所有可用的场地，如果lock成功（该 场地当前对应的线程并未使用堆内存），则将该场地供线程3使用。</p><p>如果没有找到可用的area，则将线程3的malloc操作阻塞，直到找到可用的为止。</p><ul><li><p>在[glibc malloc]中主要有3种数据结构：</p><ul><li><p>heap_info ——Heap Header—— 一个 thread arena 可以维护多个堆。每个堆都有自己的堆 Header（注：也即头部元数据）。什么时候 Thread Arena 会维护多个堆呢？ 一般情况下，每个 thread arena 都只维护一个堆，但是当这个堆的空间耗尽时，新的堆（而非连续内存区域）就会被 mmap 到这个 aerna 里；</p></li><li><p>malloc_state ——Arena header—— 一个 thread arena 可以维护多个堆，这些堆另外共享同一个 arena header。Arena header 描述的信息包括：bins、top chunk、last remainder chunk 等；</p></li><li><p>malloc_chunk ——Chunk header—— 根据用户请求，每个堆被分为若干 chunk。每个 chunk 都有自己的 chunk header；</p></li></ul></li></ul><p>Main arena 无需维护多个堆，因此也无需heap_info。当空间耗尽时，与 thread arena 不同，main arena 可以通过 sbrk 拓展堆段，直至堆段[碰]到内存映射段；</p><p>与 thread arena 不同，main arena 的 arena header 不是保存在通过 sbrk 申请的堆段里，而是作为一个全局变量，可以在 libc.so 的数据段中找到。</p><p>thread arena只含有一个malloc_state(即arena header)，却有两个heap_info(即heap header)。由于两个heap segments是通过mmap分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，libc malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了malloc_state，这样就构成了一个单链表，方便后续管理。</p><p><strong>堆块进化史</strong></p><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/1.jpg"></p><p>左上是allocated chunk格式，左下是free chunk格式，右边是整个堆内存组织成一个连续的已分配或未分配chunk序列。</p><p>堆内存中要求每个chunk的大小必须为8的整数倍，因此chunk size的后3位是无效的，为了充分利用内存，堆管理器将这3个比特位用作chunk的标志位，典型的就是将第0比特位用于标记该chunk是否已经被分配。</p><blockquote><p>这样的设计很巧妙，因为我们只要获取了一个指向chunk size的指针，就能知道该chunk的大小，即确定了此chunk的边界，且利用chunk size的第0比特位还能知道该chunk是否已经分配，这样就成功地将各个chunk区分开来。注意在allocated chunk中padding部分主要是用于地址对齐的(也可用于对付外部碎片)，即让整个chunk的大小为8的整数倍。</p></blockquote><p>上面的这种结构就叫做<strong>隐式链表</strong>。该链表隐式地由每个chunk的size字段链接起来，在进行分配操作的时候，堆内存管理器可以通过遍历整个堆内存的chunk，分析每个chunk的size字段，进而找到合适的chunk。</p><p>缺点：这种隐式链表效率其实是相当低的，特别是在内存回收方面，它难以进行相邻多个free chunk的合并操作。我们知道，如果只对free chunk进行分割，而不进行合并的话，就会产生大量小的、无法继续使用的内部碎片，直至整个内存消耗殆尽。因此堆内存管理器设计了带边界标记的chunk合并技术。</p><p><strong>出现问题</strong></p><ol><li>向前合并</li></ol><p>假设我们要释放的chunk为P，它紧邻的前一个chunk为FD，紧邻的后一个chunk为BK，且BK与FD都为free chunk。将P于BK合并在一起是很容易的，因为可以通过P的size字段轻松定位到BK的开始位置，进而获取BK的size等等，但是将P于FD合并却很难，我们必须从头遍历整个堆，找到FD，然后加以合并，这就意味着每次进行chunk释放操作消耗的时间与堆的大小成线性关系。</p><p>为了解决这个问题，Knuth提出了一种聪明而通用的技术——边界标记。</p><p>Knuth在每个chunk的最后添加了一个脚部(Footer)，它就是该chunk 头部(header)的一个副本，我们称之为边界标记。显然每个chunk的脚部都在其相邻的下一个chunk的头部的前4个字节处。通过这个脚部，堆内存管理器就可以很容易地得到前一个chunk的起始位置和分配状态，进而加以合并了。</p><p>但是，边界标记同时带来了一个问题：它要求每个块都包含一个头部和脚部，如果应用程序频繁地进行小内存的申请和释放操作的话(比如1，2个字节)，就会造成很大的性能损耗。</p><p>同时，考虑到只有在对free chunk进行合并的时候才需要脚部，也就是说对于allocated chunk而言它并不需要脚部，因此我们可以对这个脚部加以优化——将前一个chunk的已分配/空闲标记位存储在当前chunk的size字段的第1，或2比特位上，这样如果我们通过当前chunk的size字段知道了前一个chunk为free chunk，<em>那么就可得出结论</em>：当前chunk地址之前的4个字节为前一个free chunk的脚部，我们可以通过该脚部获取前一个chunk的起始位置；如果当前chunk的size字段的标记位表明前一个chunk是allocated chunk的话，<em>那么就可得出另一个结论</em>：前一个chunk没有脚部，即当前chunk地址之前的4个字节为前一个allocated chunk的payload或padding的最后部分。</p><ol start="2"><li>多线程时标志位不够</li></ol><p>随着技术的发展，特别是堆内存管理器添加对多线程的支持，前述的chunk格式已经难以满足需求，比如，我们需要标志位来标记当前chunk是否属于非主线程即thread arena，以及该chunk由mmap得来还是通过brk实现等等。但此时chunk size只剩下一个比特位未使用了，怎么办呢？这需要对chunk格式进行大手术！</p><p>首先思考：是否有必要同时保存当前chunk和前一个chunk的已分配/空闲标记位？</p><p>答案是否定的，因为我们只需要保存前一个chunk的分配标志位就可以了，至于当前chunk的分配标志位，可以通过查询下一个chunk的size字段得到。那么size字段中剩下的两个比特位就可以用于满足多线程的标志需求了。</p><p>PREV_INUSE(P): 表示前一个chunk是否为allocated。<br>IS_MMAPPED(M)：表示当前chunk是否是通过mmap系统调用产生的。  NON_MAIN_ARENA(N)：表示当前chunk是否是thread arena。</p><p><strong>当前的堆块的形态</strong></p><p>没必要保存chunk size的副本，也就是说Footer的作用并不大，但是如果前一个chunk是free的话，在合并的时候我们又需要知道前一个chunk的大小，怎么办呢？</p><p>将Footer从尾部移到首部，同时其不再保存当前chunk的size，而是前一个free chunk的size不就行了。同样的，为了提高内存利用率，如果前一个chunk是allocated chunk的话，这个Footer就作为allocated chunk的payload或padding的一部分。</p><p><strong>隐式/显式（bin）链表结构</strong></p><p>该结构体通过每个chunk的prev_size和size构成了隐式链表，而后续的fd, bk等指针并不是作用于隐式链表的，而是用于加快内存分配和释放效率的显示链表bin(还记得bin么？用于记录同一类型free chunk的链表)，并且这些指针跟prev_size一样只在free chunk中存在。</p><p><strong>bin的分类</strong></p><ul><li>fastbinsY，16-80字节，记录所有fastbins的数组。</li><li>bins，记录除了fastbins之外所有的bins。<ul><li>unsorted bin。</li><li>small bin。</li><li>large bin。</li></ul></li></ul><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/2.jpg"></p><p>在所有的 bins 中，fast bins 路径享有最快的内存分配及释放速度。</p><p><strong>堆的工作原理</strong></p><p>每个 fast bin 都维护着一条 free chunk 的单链表，采用单链表是因为链表中所有 chunk 的大小相等，增删 chunk 发生在链表顶端即可；—— LIFO。添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。需要注意的是，为了实现LIFO算法，fastbinsY数组中每个fastbin元素均指向了该链表的rear end（尾结点），而尾结点通过其fd指针指向前一个结点，依次类推。<br>chunk 大小：8 字节递增。 fast bins 由一系列所维护 chunk 大小以 8 字节递增的 bins 组成。也即，fast bin[0] 维护大小为 16 字节的 chunk、fast bin[1] 维护大小为 24 字节的 chunk。依此类推……  指定 fast bin 中所有 chunk 大小相同；</p><p>在 malloc 初始化过程中，最大的 fast bin 的大小被设置为 64 而非 80 字节。因为默认情况下只有大小 16 ~ 64 的 chunk 被归为 fast chunk 。</p><p>无需合并 —— 两个相邻 chunk 不会被合并。虽然这可能会加剧内存碎片化，但也大大加速了内存释放的速度！</p><p>malloc(fast chunk) ：初始情况下 fast chunck 最大尺寸以及 fast bin 相应数据结构均未初始化，因此即使用户请求内存大小落在 fast chunk 相应区间，服务用户请求的也将是 small bin 路径而非 fast bin 路径；初始化后，将在计算 fast bin 索引后检索相应 bin；</p><p>相应 bin 中被检索的第一个 chunk 将被摘除并返回给用户。<br>free(fast chunk) ：计算 fast bin 索引以索引相应 bin；free 掉的 chunk 将被添加到上述 bin 的顶端。  </p><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中(为什么，在什么情况下会发生这种事情呢？详情见后文)，系统就将这些chunk添加到unsorted bin中。为什么要这么做呢？这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。</p><p><strong>Unsorted bin的特性如下</strong></p><ul><li><p>unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。</p></li><li><p>Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。这就是前言说的特例了，不过特例并非仅仅这一个，后文会介绍。</p></li><li><p>小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。每个small bin也是一个由对应free chunk组成的循环双链表。第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 61*8 = 508字节。</p></li><li><p>大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。</p></li><li><p>鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行从大到小的排列：最大的chunk放在链表的front end，最小的chunk放在rear end。</p></li></ul><p><strong>top chunk</strong></p><p>当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。该chunk并不属于任何bin，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。</p><p>如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：</p><ol><li>用户请求的chunk；</li><li>剩余的部分成为新的top chunk。<br>否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</li></ol><p><strong>顶块的作用：救火队员</strong></p><ol><li>不属于任何bin</li><li>当前所有空闲块(无论那种bin)全都尺寸不合时，由顶块应急</li><li>顶块比请求尺寸大 — 分割供给使用，剩余部分为新顶块</li><li>顶块比请求尺寸小 — 全堆无适合块，扩展堆/分配新堆</li></ol><p>对于Last remainder chunk，我们主要有两个问题：<br>1)它是怎么产生的；<br>2)它的作用是什么？</p><ul><li><p>当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。</p></li><li><p>此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</p></li></ul><h4 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h4><p><strong>与栈溢出的区别</strong></p><ol><li>堆溢出方向=堆增长方向。</li><li>首先破坏（虚拟地址意义上的）下一个堆块的构造。</li></ol><p><strong>linux典型的堆溢出利用方式</strong></p><ol><li>攻击fast bin。</li><li>攻击unlink。</li></ol><p><strong>攻击fastbin</strong></p><p>攻击原理是在chunk被分配时，从队尾删除，并将当前chunk的fd写入到fastbin。下次分配就分配这个fd对应地址的chunk。<br>具体用法是chunk0写入溢出，覆盖相邻的chunk1的fd。当chunk1被分配时，被篡改的chunk1中的fd被写入fastbin。在chunk2被分配时就分配攻击者想攻击的内存地址。因为被分配的内存空间可写，攻击者因此实现对指定地址写入数据的目的。</p><p>可能是在内存有连续空间时，快速分配释放，使得buf0 buf1空间连续，这样在写入溢出时，就可以覆盖到相邻的未分配的buf1里面的fd地址。</p><p><strong>攻击unlink</strong></p><p>一旦涉及到free内存（非mmaped的chunks的回收机制），那么就意味着有新的chunk由allocated状态变成了free状态，此时glibc malloc就需要进行合并操作——向前以及(或)向后合并。</p><p>将previous free chunk合并到当前free chunk，叫做向后合并；将后面的free chunk合并到当前free chunk，叫做向前合并</p><p><strong>向后合并操作</strong></p><p>首先检测previous chunk是否为free，这可以通过检测当前free chunk的PREV_INUSE(P)比特位获得。</p><p><strong>如果为free的话，那么就进行向后合并</strong></p><p>将前一个chunk占用的内存合并到当前chunk。<br>修改指向当前chunk的指针，改为指向前一个chunk。<br>使用unlink宏，将前一个free chunk从双向循环链表中移除。</p><p><strong>向前合并操作</strong></p><p>首先检测next chunk是否为free。那么如何检测呢？通过查询next chunk之后的chunk的PREV_INUSE (P)。</p><p><strong>即可如果为free的话，那么就进行向前合并</strong></p><p>本质是将next chunk从双向链表中移除，合并到当前chunk。<br>在glibc malloc中，会将合并后的chunk(或因为不满足合并条件而没合并的chunk) ，放到unsorted bin中。</p><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/3.jpg"></p><ol><li><p>在代码3中存在一个堆溢出漏洞：如果用户输入的argv1的大小比first变量的666字节更大的话，那么输入的数据就有可能覆盖掉下一个chunk的chunk header——这可以导致任意代码执行。而攻击的核心思路就是利用glibc malloc的unlink机制。</p></li><li><p>程序在[4]处调用free(first)后，执行：</p><ul><li><p>向后合并：鉴于first的前一个chunk非free的，所以不会发生向后合并操作。</p></li><li><p>向前合并：先判断后一个chunk是否为free，若free则合并。</p></li></ul></li><li><p>prev_size =一个偶数，这样其PREV_INUSE位就是0了，即表示前一个chunk为free。</p><ul><li>size = -4</li><li>fd = free函数的got表地址address – 12；(简称为“free addr – 12”)。</li><li>bk = shellcode的地址Bitmap Flipping攻击。</li></ul></li><li><p>  nextchunk + nextsize计算得到指向下下一个chunk的指针，然后判断下下个chunk的size的PREV_INUSE标记位（判断是否为free）。    + nextsize=-4,进而导致next chunk的prev_size字段看做是next-next chunk的size字段。    + next chunk的prev_size字段设置为了一个偶数，低位为0进而判断next chunk为free。</p></li></ol><p><strong>注意</strong></p><p>既然next chunk为free，那么就需要进行向前合并，所以就会调用unlink(nextchunk, bck, fwd)函数。真正的重点就是这个unlink函数！</p><p><strong>上一段中描述的”前一个“与”后一个“chunk，是指的由chunk的prev_size与size字段隐式连接的chunk，即它们在内存中是连续、相邻的！而不是通过chunk中的fd与bk字段组成的bin(双向链表)中的前一个与后一个chunk，切记！</strong></p><p>fd = free函数的got表地址address – 12；(简称为“free addr – 12”)<br>bk = shellcode的地址。</p><p>调用unlink(nextchunk, bck, fwd)合并。</p><p>FD = nextchunk-&gt;fd = free addr– 12;<br>BK = nextchunk-&gt;bk = shellcode起始地址;<br>BK赋值给FD-&gt;bk，即（free add– 12）-&gt;bk = shellcode起始地址；<br>FD赋值给BK-&gt;fd，即(shellcode起始地址)-&gt;fd = free addr– 12;</p><p>最终，free add指向shellcode add,当程序在代码[5]处再次执行free的时候，就会转而执行shellcode。达到攻击效果</p><p><strong>Windows堆溢出攻击的主要形式</strong></p><ul><li>利用向量化异常处理（VEH）</li><li>利用系统默认异常处理函数（UEF）</li><li>Heap spray</li><li>Bitmap Flipping攻击</li><li>Bitmap XOR攻击</li><li>Heap Cache攻击</li></ul><h4 id="堆溢出的防御"><a href="#堆溢出的防御" class="headerlink" title="堆溢出的防御"></a>堆溢出的防御</h4><p>相比栈溢出，针对堆溢出的防御措施更易实用化<br>堆依靠系统库实现其维护，故堆保护=系统库升级</p><p><strong>针对unlink的保护</strong></p><ol><li><p>Double Free检测:该机制不允许释放已经处于free状态的chunk。因此，当攻击者将second chunk的size设置为-4的时候，就意味着该size的PREV_INUSE位为0，也就是说second chunk之前的first chunk(我们需要free的chunk)已经处于free状态，那么再free就报出double free错误。</p></li><li><p>next size非法检测: 检测next size是否在8到当前arena的整个系统内存大小之间。因此当检测到next size为-4的时候，就会报出invalid next size错误。</p></li><li><p>双链表冲突检测:执行unlink操作的时候检测链表中前一个chunk的fd与后一个chunk的bk是否都指向当前需要unlink的chunk。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们沉浸爱情</title>
      <link href="/2021/06/20/CC%E7%9A%84%E5%BF%AB%E4%B9%90/"/>
      <url>/2021/06/20/CC%E7%9A%84%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<h2 id="晨晨的周记一"><a href="#晨晨的周记一" class="headerlink" title="晨晨的周记一"></a>晨晨的周记一</h2><p><img src="../CC%E7%9A%84%E5%BF%AB%E4%B9%90/0.JPG"></p><p> 这一周和弟弟的联系感觉没有上一周多了，原因呢大概就是我忙着找工作弟弟忙着准备期末考试呢，不知道为什么每次到这种环节我的心底就会泛起涟漪，想着我们的联系变少了以后会不会更少了，想着我们的联系变少了感情会不会没有之前热烈了，想着我们的联系变少了会不会没有以前那么亲密无间了，这些想法一直在我脑海中徘徊挥之不去，一空闲下来就会在想他在干嘛呢，不知道是不是在忙，早上是在背单词吗，背完有记得吃早饭再去学习吗。中午想的是他要不要休息会不然等会子下午学习会想打瞌睡的等等。</p><p>有时候看我这边的天气的时候，也会点开他那边的天气看一下，想知道和我的是否一样，想知道那个他有没有受凉或者中暑，晚上睡觉时想和他说完晚安一起睡，还有挂电话想等他挂这都是我的小心思呢，觉得这样会很甜！</p><p>再说回自己我这个人其实对要什么不是很清楚，但是等事情来了我就知道我要的是不是他，我的第一天工作总体来说说不上满意也说不上不满意，只要是第一天没啥事情可做我有点闲不住，其次就是这个岗位据我观察目前就是一个话务员的职位，我想做的是资料员所以目前不是特别满意之后跟那个负责人沟通一下叭，但是这不是一个长久的岗位只是一个过度而已，我的志愿目前是考公务员，虽然不知道我能不能考的上但是我会尽自己的努力加油的！</p><p>想安安稳稳的和弟弟生活下去，希望一切顺遂。</p><p>–LC</p>]]></content>
      
      
      <categories>
          
          <category> 晨晨的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 晨晨 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个小实验</title>
      <link href="/2021/06/18/python%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/18/python%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>犯了一个错误，以后慢慢改吧！</p><pre class="line-numbers language-none"><code class="language-none">from torch.utils.data import DataLoader, random_splitfrom torchvision import transforms, datasets, modelsimport torch.nn as nnfrom torch.optim import SGDimport torchimport os#print(torch.cuda.is_available())#使用GPUdevice &#x3D; torch.device(&#39;cuda:0&#39;)#自定义数据集data_transform &#x3D; transforms.Compose([    transforms.Resize((224, 224)),    transforms.RandomHorizontalFlip(),    transforms.ToTensor(),    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])full_datasets &#x3D; datasets.ImageFolder(root &#x3D; &#39;.&#x2F;dataset&#39;, transform &#x3D; data_transform)#分为训练集和测试集train_size &#x3D; 1000test_size &#x3D; len(full_datasets) - train_sizetrain_datasets, test_datasets &#x3D; random_split(full_datasets, [train_size, test_size])#载入训练集和测试集batch_size_num &#x3D; 16load_train_datasets &#x3D; DataLoader(dataset &#x3D; train_datasets, batch_size&#x3D; batch_size_num, shuffle &#x3D; True)load_test_datasets &#x3D; DataLoader(dataset &#x3D; test_datasets, batch_size &#x3D; batch_size_num, shuffle &#x3D; True)#使用googlenet算法cnn &#x3D; models.googlenet(pretrained &#x3D; True)#将分类层的参数改为2features &#x3D; cnn.fc.in_featurescnn.fc &#x3D; nn.Linear(features, 2)#模型放入GPU中cnn &#x3D; cnn.to(device)#loss设置和梯度下降法lr_num &#x3D; 0.001loss_function &#x3D; nn.CrossEntropyLoss()optimizer &#x3D; SGD(cnn.parameters(), lr &#x3D; lr_num, momentum &#x3D; 0.9)#scheduler &#x3D; lr_scheduler.StepLR(optimizer &#x3D; optimizer, step_size &#x3D; 100, gamma &#x3D; 0.5)epochs &#x3D; 5for epoch in range(epochs):    loss_value &#x3D; 0.0    #scheduler.step()    #启用 BatchNormalization 和 Dropout    cnn.train()    for i, (datas_train, labels_train) in enumerate(load_train_datasets):        datas_train &#x3D; datas_train.to(device)        labels_train &#x3D; labels_train.to(device)                #优化器优化        optimizer.zero_grad()        outputs &#x3D; cnn(datas_train)        loss &#x3D; loss_function(outputs, labels_train)        loss.backward()        optimizer.step()        loss_value +&#x3D; loss.cpu().item()        correct &#x3D; 0    #每一个batch的loss求和除以batch的数量，就是该次epoch的平均loss    loss_value &#x3D; loss_value * batch_size_num &#x2F; train_size    cnn.eval()    #预测    acc &#x3D; 0    for datas_test, labels_test in load_test_datasets:        datas_test &#x3D; datas_test.to(device)        labels_test &#x3D; labels_test.to(device)            outputs_test &#x3D; cnn(datas_test)        prediction &#x3D; torch.max(outputs_test, 1)[1]        #同样的计算该次epoch的acc        acc +&#x3D; (torch.sum((prediction &#x3D;&#x3D; labels_test))).cpu().to(torch.float32)    print(&#39;epochs: &#123;&#125; |loss &#x3D; &#123;:.5f&#125; |accurcay &#x3D; &#123;:.5f&#125;&#39;.format(epoch + 1, loss_value, acc &#x2F; test_size))print(&#39;学习率:&#39;, lr_num, &#39;|Epochs:&#39;, epochs, &#39;|batch_size:&#39;, batch_size_num)os.system(&quot;pause&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 进步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的规划</title>
      <link href="/2021/06/18/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92/"/>
      <url>/2021/06/18/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="大学生职业与发展规划书"><a href="#大学生职业与发展规划书" class="headerlink" title="大学生职业与发展规划书"></a>大学生职业与发展规划书</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从我们出生到现在，面临重大的选择的时候我们都要借助他人的帮助进行选择，尤其是一些人生选择时刻，例如中考，选文理科，高考报考专业和自己将要进入的学校，很大一部分都是参照父母或者老师的意见。在进入人生的又一个选择的时候，转身，发现已经没有人在身后要求我们要怎么做，这时候我们只能根据自己的初心，自己的本性来做决定，就业或者是读研都是我们自己的选择，今天借此契机得以认真思考老师为我们所讲授的知识，并且能够为了我职业做一份大致的构画，以此激励自己成为自己想要成为的人。</p><p>以下分为四个部分来介绍我的职业生涯规划，分别是：</p><ul><li><strong>自我分析</strong></li><li><strong>确定职业生涯规划目标</strong></li><li><strong>成功标准</strong></li><li><strong>职业生涯规划书结束语</strong></li></ul><h3 id="一、自我分析"><a href="#一、自我分析" class="headerlink" title="一、自我分析"></a><strong>一、自我分析</strong></h3><h4 id="（一）认识自己的职业性格"><a href="#（一）认识自己的职业性格" class="headerlink" title="（一）认识自己的职业性格"></a>（一）认识自己的职业性格</h4><p>我是一个热情、活泼的男孩，自信而不张扬，正直而不呆板。在个人交流的圈子里，我用真诚对待每一个人，因为我相信那些爱别人的人会得到回报。我很乐意交朋友，希望能从我的朋友那里学到我所没有的东西。坚强的毅力,持之以恒的态度是我的特征,虽有些倔强,但是如果认为自己实在没能力完成任务,我会适时放弃。因为我认为适时放弃也是人生的一大智慧。冲动是我的主要缺点。我缺乏细致和冲动。我做事的时候从不用水拖泥带水，但有时我缺乏考虑。</p><p>我是一个完美主义者，我总是希望我能完美地完成它，尽管知道这是不可能的，但是我会朝着这个方向去做。</p><h4 id="（二）自己的兴趣爱好"><a href="#（二）自己的兴趣爱好" class="headerlink" title="（二）自己的兴趣爱好"></a>（二）自己的兴趣爱好</h4><p>总的来说我的兴趣和爱好还算比较广泛，喜欢读书、听音乐、听音乐、旅行、编程等。我善于表达自己的想法，表达我的意见和看法，我希望我能得到别人的认可。在学习的过程中，我会创造工作和休息相结合的条件，这样我就能更有效率地做事。我爱看传记与诗歌，喜欢与别人分享我在书中看到的知识，有时也会激烈的进行讨论，对于各种不同的价值观，我接受和而不同的思想方式，我认为这样才是一个真实的世界。尽管有时会因为生活的忙碌让自己无法有足够的事件来做自己喜欢的事情，我还是依旧对日子保持尽可能多的新鲜感。</p><h4 id="（三）自己的职业能力"><a href="#（三）自己的职业能力" class="headerlink" title="（三）自己的职业能力"></a>（三）自己的职业能力</h4><p>从某方面来讲，自己的感性能力和理性能力对半来分，只是在不同的场合而已，在做一些重要的事情时，我不会纵容任何一位熟悉的人偷懒或者逃避责任，面对不公正的行为都会坚定的保持自己的立场。在一些个人问题上，我始终保持开放的思想，认为不应该老古董对待变化中的世界，这样是不公平的。相反同时完成任务的时候，我甚至会选择更加具有挑战性的工作，用来提升自己的实力。</p><p>对于工作中的事情，比如自己的专业内的能力，保持中立的评价，只能维持在中等水平，对于一些困难的问题，自己无法得到答案，因为一些其他因素，可能自己也会失败和沮丧，而且面对未来，曾经有过小短时间的彷徨，时而转换了自己的目标，不知道如何发展，但也不至于停滞不前，到了如今，终于明确了自己的目标。</p><h4 id="（四）自我潜能"><a href="#（四）自我潜能" class="headerlink" title="（四）自我潜能"></a>（四）自我潜能</h4><ol><li><p>在自我潜能方面，由于参加了学生会和团委的工作，我发现我的社交能力与组织领导能力均有所提高，也具有一定的吃苦能力；</p></li><li><p>我的相关经历高中时的我曾担任过班长。也帮学校老师完成工作上的事情，在工作能力和勇气方面还有基础，所以面对上台演讲这类任务，只要准备的充分，个人不存在怯场或者过度紧张的表现；</p></li><li><p>个人品质 ：在个人品质方面，我拥有中国人最传统的道德底线与指标，具有不屈不挠的品质，并且对待老人和儿童保持礼貌，公共场合不喧哗，乐于帮助陌生人，尤其是在车站附近或者公交车地铁上帮助他人指引方向；</p></li><li><p>人生格言:幸福生活是留给奋斗过的人。</p></li></ol><p>综上所述，只要我选择了适合自己的，我就会是最好的。我明白我无法决定生命的长短，但我可以控制它的宽度，我无法控制天气，但我可以改变我的心情，明天我无法预测，但我今天可以用，我不能顺利，但我可以做任何事情。努力工作。</p><h3 id="二、确定职业生涯规划目标："><a href="#二、确定职业生涯规划目标：" class="headerlink" title="二、确定职业生涯规划目标："></a><strong>二、确定职业生涯规划目标：</strong></h3><p>通过前面的自我评估，我认为自己是外向并且内敛型的人。善于思考问题不仅是我的爱好，更是我的优势。在未来的学习和生活中，我相信在一次又一次的学习和生活中，我会不断地提高自己，并尽我最大的努力去保留知识。因为机会通常只有几秒钟，而且只对那些有准备的人，我计划我的生活。只要自己能够实现自己的规划，那就能够为自己的生活作保障，并且不后悔自己所做的选择。</p><h4 id="（一）大学期间"><a href="#（一）大学期间" class="headerlink" title="（一）大学期间"></a>（一）大学期间</h4><p>大学即将结束，但并不影响我加强对自己的进一步要求，在这一过程中，积极做好学生的本职工作，并且不偷懒，不懦弱，工作认真，学习努力。</p><ol><li><p>思想政治及道德素质方面：以马列主义、毛泽东思想、邓小平理论、”三个代表”重要思想为指导，树立正确的人生观、价值观、道德观、奋斗观、创业观，坚持正确的人生价值取向。定期提交对党的章程的学习、理解和实践，以及自己的言行和感受，争取通过审查，尽快加入中国共产党，积极参加党的活动。</p></li><li><p>社会实践与志愿服务方面： 适时参加社会调查活动。及时参与安全自愿献血、植树活动、青年志愿服务活动等公益事业。</p></li><li><p>科技学术创新创业方面:扎实学习专业技能,同时,充分利用校内图书馆、校外图书城及网络信息,开拓视野和知识范围,以此,激发、开拓思路,尝试设计开展学术创新、科技创新。</p></li><li><p>文体艺术、社团活动与身心发展方面：积极参加校内外文体艺术活动、校内社团活动、演讲赛、辩论赛、书画比赛等，以此充分锻炼胆量、能力，展示个人风采。积极参加身体锻炼，每周平均锻炼四次。</p></li><li><p>学业方面：平时，无非常特殊情况绝不迟到、请假，更不准旷课，保证好学习听讲时间及学习质量。除了上课时间，我们还应该充分利用课后时间。除去必要适可的身体锻炼、娱乐活动及休闲时间外，均应安心、踏实、专注地攻读职业方向类、专业类书籍和其它类别的实用书籍。学习时要注意预习、听课、复习、综合分析比较、用时比例。知识积累不仅要博大精深，还要专业化、精练，力求毕业时获得优秀毕业生的称号。</p></li><li><p>考研任务繁重，加紧有效的时间做好考研工作的安排，对于自己的前途和理想不迷路，积极实现自己的感兴趣的目标，通识课，数学和英语的学习人中而道远，同时加强自己在专业课方面的技能，不再在懒散中浪费时光。</p></li></ol><h4 id="（二）毕业后的职业生涯规划"><a href="#（二）毕业后的职业生涯规划" class="headerlink" title="（二）毕业后的职业生涯规划"></a>（二）毕业后的职业生涯规划</h4><p>在之前的考研前期准备过程中，我发现自己的目标不在于本专业，或者如果之后读研深造，继续完成本专业的学习会给我带来困扰，于是决定在考研的过程中进行一些小的方向性调整，这些小调整也是经过我个人的认真思考，由本科学习信息安全专业转向研究生的大数据应用技术。这可能是以此小跨考，均属于计算机相关专业，只是在纯粹计算机技术方面，自己有着极大的学科空白，这也源于自己在本科学习过程中的懒惰行为。不过在我的学习过程中发现自己对于计算机硬件的极大抵触性，而且由于d之后的选择的未知性导致我做出了此次选择。并且考研院校也由自己的学校变成了中部地区的中南大学，任重而道远。</p><p>有了明确的目标就应该加紧时间足够努力去冲刺，我会每周给自己制定学习计划，深知学习非一朝一夕之事，但是会是一朝一夕积累得来的经验，面对一些无法解决的难题，我会花费足够多的是时间去增强自己的能力。去中部地区读研首要原因是日后可能在中部地区发展，并且在中部生活。那很大程度需要自己积累人脉，如果报考本校之后极大可能会因为地域的原因导致自己在中部的发展滞后他人。加上在职业招聘平台的定向搜索，发现目前所学专业信息安全虽然有很大的空缺，但在定向搜索的区域，发现人才需要并不很大，这导致了自己之后的求职之路可能艰辛且漫漫。况且由于本人的兴趣问题，在本科学习过程中发现自己对于大数据的兴趣不断提升，在一次课堂上对于老师布置的作业有着格外的兴趣，觉得日后可能会专研此方向。</p><p>以上是短暂的几年的规划，长期的规划是，短期培养能力，进入公司不断提升自己，再在人才的管理方面花费少许精力，使得之后的转型更加便捷，后来便可以进入慢慢晋升的道路。希望漫漫长路，自己能够不辞辛苦得到的果实能有心爱的人一起分享。</p><h3 id="三、成功标准"><a href="#三、成功标准" class="headerlink" title="三、成功标准"></a><strong>三、成功标准</strong></h3><p>我的成功标准：一个人设定一个积极的目标，经过努力，有一个积极的收获，就是成功。每个阶段中只要自己尽心尽力能力也得到了发挥都会自我的提高即使目标没有实现做的事至少自己努力过拼搏过我不会给自己后悔的理由。</p><p>成功之路有许多条，成功的定义也有许多种，只要在理想的指引下，真正做了自己想做的事情，真正实现了自己的人生的价值，就是一种成功，一种超越，就应该为此感到自豪和快乐。</p><h3 id="职业生涯规划书结束语"><a href="#职业生涯规划书结束语" class="headerlink" title="职业生涯规划书结束语"></a><strong>职业生涯规划书结束语</strong></h3><p>身为大学生的我们，应该珍惜这来之不易的学习机会。不是每个人都可以在大学里度过他一生中最美好的日子。人的大学时光一生中也就有一次,不把握好,将来自己一定回追悔莫及。</p><p>有了目标，才有动力。这份大学生职业生涯规划书给了我一个明确的学习目标和职业规划。我将按照上述内容完成自己的学习任务和工作任务，使我的生活更有意义。</p><p>这是我自己的职业生涯规划。有一个好的计划，就有了一个好的开端，其实这不是一件简单的事情，但只要有努力工作，就会有成就。现实是变化的，计划也应要跟着有所改变。我们务必保持清醒的头脑，及时处理我们碰到的困难。每个人都有自己的理想，不过要实现自己的这个理想还是得依靠自己的努力付出才行，无论你的理想有多美好，没有辛勤的汗水都是不可能实现的。天下没有免费的午餐，一个人，要想有所作为，必须拿出勇气，必须付出努力，必须学会去为自己的梦想拼搏，奋斗。成功,不相信眼泪成功,不相信颓废成功不相信幻影,未来,要靠自己去打拼!</p>]]></content>
      
      
      <categories>
          
          <category> 要成功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生涯规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
