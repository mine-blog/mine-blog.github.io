<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++程序设计3</title>
      <link href="/2022/04/02/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"/>
      <url>/2022/04/02/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/</url>
      
        <content type="html"><![CDATA[<h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序设计2</title>
      <link href="/2022/03/31/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
      <url>/2022/03/31/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/</url>
      
        <content type="html"><![CDATA[<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>类和对象。<br>类是面向对象程序设计的最基本的概念，是C++最强有力的特征，是进行封装和数据隐藏的工具，它将数据与操作紧密地结合起来。对象是类地实例，面向对象程序设计中的对象来源于现实世界，更接近人们的思维。</p><p>结构体与类</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;结构体的举例#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;&#x2F;&#x2F;建立结构体struct Complex &#123;double real;double image;void init(double r, double i)&#123;real &#x3D; r;image &#x3D; i;&#125;double abscomplex()&#123;double t;t &#x3D; real * real + image * image;return sqrt(t);&#125;&#125;;int main()&#123;Complex A;&#x2F;&#x2F;创建一个结构体变量A.init(4, 3);&#x2F;&#x2F;初始化cout &lt;&lt; &quot;复数的绝对值是：&quot; &lt;&lt; A.abscomplex() &lt;&lt; endl;&#x2F;&#x2F;使用定义的算法return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++提供了一种比结构体类型更安全有效的数据类型————类。类与结构体的廓形是十分相似。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;&#x2F;&#x2F;建立类class Complex &#123;double real;double image;void init(double r, double i)&#123;real &#x3D; r;image &#x3D; i;&#125;double abscomplex()&#123;double t;t &#x3D; real * real + image * image;return sqrt(t);&#125;&#125;;int main()&#123;Complex A;A.init(4, 3);&#x2F;&#x2F;出错了cout &lt;&lt; &quot;复数的绝对值是：&quot; &lt;&lt; A.abscomplex() &lt;&lt; endl;&#x2F;&#x2F;出错了return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++将类的成员分为两类：私有成员和公有成员。私有成员只能被类内的成员函数访问，而不能被类外的成员访问；公有成员既可以被类内的成员函数访问，也可以被类外的对象访问。默认情况下，类的成员是私有的，结构体中的成员是公有的。<br>这里表示的私有和公有可以用来正常运行</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;&#x2F;&#x2F;创建类class Complex &#123;private:double real;double imag;public:void init(double r, double i)&#123;real &#x3D; r;imag &#x3D; i;&#125;double abscomplex()&#123;double t;t &#x3D; real * real + imag * imag;return sqrt(t);&#125;&#125;;int main()&#123;Complex A;&#x2F;&#x2F;cout &lt;&lt; &quot;real 是：&quot; &lt;&lt; A.real;&#x2F;&#x2F;出错，私有变量&#x2F;&#x2F;cout &lt;&lt; &quot;imag 是：&quot; &lt;&lt; A.imag;&#x2F;&#x2F;出错，私有变量A.init(4, 3);&#x2F;&#x2F;出错了cout &lt;&lt; &quot;复数的绝对值是：&quot; &lt;&lt; A.abscomplex() &lt;&lt; endl;&#x2F;&#x2F;出错了return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>public和private称为成员访问限定符，用它们来声明各成员的访问属性。每个成员访问限定符下面又都可以有数据成员和成员函数。数据成员和成员函数一般都称为类的成员。<br>成员函数的定义，成员函数既可以定义成普通的成员函数，也可以定义成内联成员函数。</p><p>第一种定义方法：在类声明中只给出成员函数的原型，而将成员函数的定义放在类的外部。这种方法比较简明，能够直到类的信息而不会导致类的长度过长。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Point&#123;public:void setpoint(int, int);int getx();int gety();double getlen();private:int x, y;&#125;;void Point::setpoint(int i, int j)&#123;x &#x3D; i;y &#x3D; j;&#125;int Point::getx()&#123;return x;&#125;int Point::gety()&#123;return y;&#125;double Point::getlen()&#123;int l &#x3D; getx();int w &#x3D; gety();return sqrt(l * l + w * w);&#125;int main()&#123;Point p;p.setpoint(6, 4);cout &lt;&lt; &quot;长为：&quot; &lt;&lt; p.getx() &lt;&lt; endl;cout &lt;&lt; &quot;宽为：&quot; &lt;&lt; p.gety() &lt;&lt; endl;cout &lt;&lt; &quot;总长度为：&quot; &lt;&lt; p.getlen() &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员函数的第二种定义方法：将成员函数直接定义在类的内部。减小了函数的开销，提高执行效率，但是却增加了编译后代码的长度，所以只有相当简短的成员函数才定义为内联函数。这里搞成隐式内联函数，只有代码量比较小的时候才用。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Point&#123;private:int x, y;public:void setpoint(int i, int j)&#123;x &#x3D; i;y &#x3D; j;&#125;int getx()&#123;return x;&#125;int gety()&#123;return y;&#125;double getlen()&#123;int l, w, len2;l &#x3D; getx();w &#x3D; gety();len2 &#x3D; l * l + w * w;return sqrt(len2);&#125;&#125;;int main()&#123;Point p;p.setpoint(6, 4);cout &lt;&lt; &quot;长为：&quot; &lt;&lt; p.getx() &lt;&lt; endl;cout &lt;&lt; &quot;宽为：&quot; &lt;&lt; p.gety() &lt;&lt; endl;cout &lt;&lt; &quot;总长度为：&quot; &lt;&lt; p.getlen() &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员函数的第三种定义方法：为了书写清晰，在类声明中只给出成员函数的原型，而将成员函数的定义放在类的外部。但是在类内函数原型声明前或在类外定义成员函数前冠以关键字inline，以此显式说明这是一个内联函数。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Point&#123;private:int x, y;public:inline void setpoint(int i, int j);inline int getx();inline int gety();inline double getlen();&#125;;inline void Point::setpoint(int i, int j)&#123;x &#x3D; i;y &#x3D; j;&#125;inline int Point::getx()&#123;return x;&#125;inline int Point::gety()&#123;return y;&#125;inline double Point::getlen()&#123;int l, w, len2;l &#x3D; getx();w &#x3D; gety();len2 &#x3D; l * l + w * w;return sqrt(len2);&#125;int main()&#123;Point p;p.setpoint(3,4);cout &lt;&lt; &quot;长为：&quot; &lt;&lt; p.getx() &lt;&lt; endl;cout &lt;&lt; &quot;宽为：&quot; &lt;&lt; p.gety() &lt;&lt; endl;cout &lt;&lt; &quot;总长度为：&quot; &lt;&lt; p.getlen() &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在声明函数原型和定义函数时同时些inline，也可以在其中一处声明inline，效果是相同的，都能按照内联函数处理。使用inline定义内联函数时，必须将类的声明和内联成员函数的定义都放在一个文件里，否则编译时无法进行代码置换。<br>对象的定义及使用。</p><p>类与对象的关系，通常我们把具有共同属性和行为的事物构成的集合叫做类。<br>可以使用以下两种方法定义对象。第一，在声明类的同时，直接定义对象，即在声明类的右花括号后。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Point&#123;private:int x, y;public:inline void setpoint(int i, int j);inline int getx();inline int gety();inline double getlen();&#125;point1,point2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二，在声明类之后，在使用时再定义对象。定义对象的格式与定义基本数据类型的格式类似。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Point&#123;private:int x, y;public:inline void setpoint(int i, int j);inline int getx();inline int gety();inline double getlen();&#125;;Point p;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对象中成员的访问，无论是数据成员还是成员函数，只要是公开的，在类的外部都可以通过类的对象进行访问。访问对象中的成员通常有三种方法。<br>第一，通过对象名和对象选择符访问对象中的成员。<br>第二，通过指向对象的指针访问对象中的成员。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Date&#123;public:int year;&#125;;int main()&#123;Date d, * ptr;ptr &#x3D; &amp;d;d.year &#x3D; 12;cout &lt;&lt; ptr-&gt;year &lt;&lt; endl;return 0;&#125;&#x2F;*以下三个语句的效果是一样的d.year(*ptr).yearptr-&gt;year*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三，通过对象的引用访问对象中的成员，如果为了一个对象定义一个引用，也就是为这个对象起了一个别名。因此完全可以通过引用来访问对象中的成员，其方法与通过对象名来访问对象中的成员事项同的。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Date&#123;public:int year;&#125;;int main()&#123;Date d1;d1.year &#x3D; 2;Date&amp; d2 &#x3D; d1;cout &lt;&lt; d1.year &lt;&lt; endl;cout &lt;&lt; d2.year &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类的作用域和类成员的访问属性。<br>在类的作用域内，一个类的任何成员函数可以不受限制地房屋内该类地其他成员。而在类地作用域之外，对该类的数据成员和成员函数的访问则要受到一定的限制，有时甚至是不允许的，这主要与类成员的访问属性有关。</p><p>构造函数和析构函数。<br>构造函数是属于某一个类的，它可以由用户提供，也可以由系统自己生成。与构造函数对应的是析构函数，当撤销类的对象时，析构函数就回收存储空间，并做一些善后工作。可以由用户提供，也可以自己生成。</p><p>对象的初始化和构造函数。<br>类是一种抽象的数据类型，它不占存储空间，不能容纳具体的数据。因此在类声明中不能给数据成员赋初值。与使用变量一样，使用对象时也应该先定义，后使用。在定义对象时，对数据成员赋初值，称为对象的初始化。在定义对象时，如果某一数据成员没有被赋值，则它的值是不可预知的。</p><p>在建立对象的同时，采用构造函数给数据成员赋初值，通常有两种方式。<br>第一，类名与构造函数名相同，”实参表”是为构造函数提供的实际参数。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Complex&#123;private:int real, imag;public:Complex(int r, int i)&#x2F;&#x2F;成员函数&#123;real &#x3D; r;imag &#x3D; i;&#125;double abscomplex()&#123;int t;t &#x3D; real * real + imag * imag;return sqrt(t);&#125;&#125;;int main()&#123;Complex A(3, 4);cout &lt;&lt; A.abscomplex() &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二，使用new运算符动态建立对象的方式。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Complex&#123;private:int real, imag;public:Complex(int r, int i)&#x2F;&#x2F;成员函数&#123;real &#x3D; r;imag &#x3D; i;&#125;double abscomplex()&#123;int t;t &#x3D; real * real + imag * imag;return sqrt(t);&#125;&#125;;int main()&#123;Complex *pa &#x3D; new Complex(3, 4);cout &lt;&lt; pa-&gt;abscomplex() &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造函数的名字必须要与类名相同，否则编译程序将把它当作一般的成员函数来处理。构造函数没有返回值，在定义构造函数时，是不能说明它的类型的，甚至说明为void类型也不行。构造函数的函数体可以写在类体内，也可写在类体外。<br>构造函数的主要作用是用来对对象进行初始化，用户根据初始化的要求设计函数体和函数参数。构造函数一般声明为公有成员，但它不需要被显式调用，他是定义对象的同时被自动调用的，而且只执行一次。同时构造函数可以不带参数。</p><p>用成员初始化列表对数据成员初始化。这种方法不在函数体内用赋值语句对数据成员初始化，而是在函数首部实现的。即原来的函数首部的末尾加一个冒号，然后列出成员初始化列表。成员初始化列表写法方便，简练，尤其当需要初始化的数据成员较多时更显优越性。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;这个初始化好奇怪呀，没有搞懂为什么是这样#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class A&#123;public:A(int x1) :x(x1), rx(x), pi(3.14)&#x2F;&#x2F;用成员初始化列表对引用类型的数据成员进行初始化&#123;&#125;void print()&#123;cout &lt;&lt; &quot;x&#x3D;&quot; &lt;&lt; x &lt;&lt; &quot; rx&#x3D;&quot; &lt;&lt; rx &lt;&lt; &quot; pi&#x3D;&quot; &lt;&lt; pi &lt;&lt; endl;&#125;private:int x;int&amp; rx;&#x2F;&#x2F;整型变量的引用const double pi;&#125;;int main()&#123;A a(10);a.print();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据成员是按照它们在类中声明的顺序进行初始化的，与他们在成员初始化列表中对列出的顺序无关。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class D&#123;public:D(int i) :mem2(i), mem1(mem2 + 1)&#123;cout &lt;&lt; &quot;mem1 is &quot; &lt;&lt; mem1 &lt;&lt; endl;cout &lt;&lt; &quot;mem2 is &quot; &lt;&lt; mem2 &lt;&lt; endl;&#125;private:int mem2, mem1;&#x2F;&#x2F;声明的顺序&#x2F;&#x2F;int mem1,mem2;  &#x2F;&#x2F;这时候的运行结果不同&#125;;int main()&#123;D d(15);&#x2F;&#x2F;输出16，15return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造函数的重载。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Date&#123;public:&#x2F;&#x2F;构造的内联函数，在简单函数中可以使用inline Date();inline Date(int y, int m, int d);inline void showDate();private:int year;int month;int day;&#125;;inline Date::Date()&#123;year &#x3D; 2022;month &#x3D; 4;day &#x3D; 2;&#125;inline Date::Date(int y, int m, int d)&#123;year &#x3D; y;month &#x3D; m;day &#x3D; d;&#125;inline void Date::showDate()&#123;cout &lt;&lt; &quot;今天是：&quot; &lt;&lt; year &lt;&lt; &quot;年&quot; &lt;&lt; month &lt;&lt; &quot;月&quot; &lt;&lt; day &lt;&lt; &quot;日&quot; &lt;&lt; endl;&#125;int main()&#123;Date date,date1(2021,3,12);date.showDate();date1.showDate();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面也是一个重载的实例。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;&#x2F;&#x2F;class类class timer&#123;public:timer()&#123;seconds &#x3D; 0;&#125;timer(char* t)&#123;seconds &#x3D; atoi(t);&#125;timer(int t)&#123;seconds &#x3D; t;&#125;timer(int min, int sec)&#123;seconds &#x3D; min * 60 + sec;&#125;int gettime()&#123;return seconds;&#125;private:int seconds;&#125;;int main()&#123;int t;char a[] &#x3D; &quot;123&quot;;timer time(a);t&#x3D;time.gettime();cout &lt;&lt; &quot;时间是：&quot; &lt;&lt; t &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>带默认参数的构造函数。如果构造函数在类的声明外定义，那么默认参数就应该在类内声明构造函数原型时指定，而不能在类外构造函数定义时指定。如果构造函数的全部参数都制定了默认值，则在定义对象时可以指定一个或几个实参，也可以不给出实参，这时的构造函数也属于默认构造函数。在一个类中定义了全部时默认参数的构造函数后，不能再定义重新构造函数。</p><p>析构函数也是一种特殊的成员函数，它执行与构造函数相反的操作，通常用于执行一些清理任务，如释放分配给对象的内存空间等。<br>析构函数的特点：</p><ul><li>析构函数名与类名相同，但它签名必须加一个波浪号。</li><li>析构函数不返回任何值。在定义析构函数时，是不能说明它的类型的，甚至说明为void型也不行。</li><li>析构函数没有参数，因此不能够重载。</li><li>撤销对象时，编译系统会自动地调用析构函数。</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;&#x2F;&#x2F;class类class Complex&#123;private:double real, imag;public:Complex(double r &#x3D; 0.0, double i &#x3D; 0.0);~Complex();double absComplex();&#125;;Complex::Complex(double r, double i)&#123;real &#x3D; r;imag &#x3D; i;cout &lt;&lt; &quot;调用构造函数。&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;系统默认定义过Complex::~Complex()&#123;cout &lt;&lt; &quot;调用析构函数。&quot; &lt;&lt; endl;&#125;double Complex::absComplex()&#123;double t;t &#x3D; real * real + imag * imag;return sqrt(t);&#125;int main()&#123;Complex c(3,4);cout &lt;&lt; &quot;长度是：&quot; &lt;&lt; c.absComplex() &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个类必须有一个析构函数，若没有显式地定义一个析构函数，编译系统会自动生成一个默认析构函数。除了在主函数结束或调用exit函数后，系统会自动调用析构函数，以下两种系统也会调用析构函数。<br>一、如果一个对象被定义在一个函数体内，则当这个函数被调用结束时，该对象将被释放，调用析构函数。<br>二、若一个对象使用new运算符动态建立，在使用delete运算符释放它时，delete会自动调用析构函数。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序设计1</title>
      <link href="/2022/03/30/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11/"/>
      <url>/2022/03/30/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11/</url>
      
        <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>简单的C++程序</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;可以包含注释代码int main()&#123;    int x, y, sum;    cout &lt;&lt; &quot;请输入两个整数：&quot; &lt;&lt; endl;    cin &gt;&gt; x;    cin &gt;&gt; y;    sum &#x3D; x + y;    cout &lt;&lt; &quot;sum&#x3D;x+y&#x3D;&quot; &lt;&lt; sum &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++程序的结构特性：</p><p>面向对象的程序</p><ul><li>类的声明部分</li><li>类的使用部分</li></ul><p>运算符”&gt;&gt;”允许用户连续输入一连串数据，例如：</p><p><code>cin &gt;&gt; x &gt;&gt; y;</code></p><p>运算符”&lt;&lt;”允许用户连续输出一连串数据，例如：</p><p><code>cout &lt;&lt; sum &lt;&lt; x &lt;&lt; y &lt;&lt; endl;</code></p><p>可以输出为十六进制，十进制，八进制等形式。</p><p><code>cout &lt;&lt; hex &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; dec &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; oct &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; endl;</code></p><p>结构、联合、枚举。</p><p><code>struct,union,enum;</code></p><p>更灵活更安全的方式定义常量：const。</p><p><code>const int LIMIT = 100;</code></p><p>常量LIMIT是有类型的，占用存储单元，有地址，可以用指针指向它，但不能修改它。</p><p>const也可以和指针一起使用，有三种：指向常量的指针，常指针，指向常量的常指针。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const char* name &#x3D; &quot;chen&quot;;&#x2F;&#x2F;不能改变指针所指的常量，但是可以修改指针的指向name &#x3D; &quot;zou&quot;;&#x2F;&#x2F;这句是对的char* const name_new &#x3D; &quot;cheng&quot;;&#x2F;&#x2F;理论上是可以的，但是为什么出错了？name_new[3] &#x3D; &#39;c&#39;;const char* const name_ano &#x3D; &quot;li&quot;;&#x2F;&#x2F;都不能修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C++中，如果函数调用的位置在函数定义之前，则要求在函数调用之前必须对所调用的函数作函数原型声明，以说明函数的名称，参数类型与个数，以及函数返回值的类型。目的是确保C++编译程序检查。</p><p>内联函数：在函数说明前冠以关键字”inline”，该函数就被声明为内联函数，又称内置函数。每当程序中出现对该函数的调用时，C++编译器使用函数体中的代码插入到调用该函数语句处，同时用实参取代形参，以便在程序运行时不再进行函数调用。</p><p>这是一种用时间换空间的方式，只有简单的函数，并且频繁使用的时候才可能会用，如果函数过于复杂，就算定义为内联函数，但也会转化为普通函数运行。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;声明inline int box(int i, int j, int k);&#x2F;&#x2F;定义inline int box(int i, int j, int k)&#123;    return i * j * k;&#125;int main()&#123;    int a, b, c;    cout &lt;&lt; &quot;请输入三个整数：a,b,c&quot; &lt;&lt; endl;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    cout &lt;&lt; &quot;输出结果是：&quot; &lt;&lt; box(a, b, c) &lt;&lt; endl;&#x2F;&#x2F;使用box函数    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用内联函数代替宏定义，就能消除宏定义的不安全性。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define double1(x) x*2&#x2F;&#x2F;正常double1(2);double1(5);&#x2F;&#x2F;出错double1(1 + 2);inline int double2(int x);inline int double2(int x)&#123;    return 2 * x;&#125;&#x2F;&#x2F;正常double2(1 + 2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>带有默认参数的函数。</p><p>函数的重载：只要函数的参数类型不同，或者参数的个数不同，或者两者兼而有之，两个或者两个以上的函数可以使用相同的函数名。当两个或者两个以上的函数公用一个函数名时，称为函数的重载。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;操作数的数据类型不同#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;声明函数int square(int i);long square(long i);float square(float i);&#x2F;&#x2F;定义函数int square(int i)&#123;return i * i;&#125;long square(long i)&#123;return i * i;&#125;float square(float i)&#123;return i * i;&#125;int main()&#123;int num1;long num2;float num3;cout &lt;&lt; &quot;请输入三个数分别为num1,num2,num3：&quot; &lt;&lt; endl;cin &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;cout &lt;&lt; &quot;输出num1的平方：&quot; &lt;&lt; square(num1) &lt;&lt; endl;cout &lt;&lt; &quot;输出num2的平方：&quot; &lt;&lt; square(num2) &lt;&lt; endl;cout &lt;&lt; &quot;输出num3的平方：&quot; &lt;&lt; square(num3) &lt;&lt; endl;cout &lt;&lt; &quot;结束！&quot; &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;还有这种变量的数量不同而使用的重载#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;声明函数（重载）int multi(int a, int b);int multi(int a, int b, int c);&#x2F;&#x2F;定义函数int multi(int a, int b)&#123;return a * b;&#125;int multi(int a, int b, int c)&#123;return a * b * c;&#125;int main()&#123;&#x2F;&#x2F;使用重载函数int num1, num2,num3;cout &lt;&lt; &quot;输入num1,num2,num3的值是多少！&quot; &lt;&lt; endl;cin &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;cout &lt;&lt; &quot;num1xnum2&#x3D;&quot; &lt;&lt; multi(num1, num2) &lt;&lt; endl;cout &lt;&lt; &quot;num1xnum2xnum3&#x3D;&quot; &lt;&lt; multi(num1, num2, num3) &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作用域运算符”::”</p><p>通常情况下，如果有两个同名变量，一个是全局的，另一个是局部的，那么局部变量在其作用域内具有较高的优先权，他将屏蔽全局变量。</p><p>如果希望在局部变量的作用域内使用同名的全局变量，可以在该变量前加上”::”，此时表示该变量使用的是全局变量的值。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int avar&#x3D;20;int main()&#123;int avar;avar &#x3D; 25;cout &lt;&lt; &quot;局部变量avar：&quot; &lt;&lt; avar &lt;&lt; endl;cout &lt;&lt; &quot;全局变量avar：&quot; &lt;&lt; ::avar &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无名联合。<br>强制类型转换。</p><p>运算符new和delete<br>删除数组时，使用此方式：</p><p><code>delete []p;</code>//p是指数组的名称即指针变量名</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;int* p;&#x2F;&#x2F;p &#x3D; new int;&#x2F;&#x2F;*p &#x3D; 10;p &#x3D; new int(10);cout &lt;&lt; *p &lt;&lt; endl;cout &lt;&lt; *(p + 4) &lt;&lt; endl;delete p;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用<br>建立引用的作用是为变量另起一个名字，变量的引用通常被认为是变量的别名。当声明一个引用时，必须同时用另一个变量的名字来将它初始化。即声明它代表哪一个变量，是哪一个变量的别名，这样对一个引用的所有操作，实际上都是对其所代表的变量的操作，就如同对一个人来说，即使有三四个名字，其实是同一个人，用这三四个人所做的事情，其实就是那一个人所做的事情。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;直接利用j变量指示i变量，两者其实是一个地址空间int main()&#123;int i;int&amp; j &#x3D; i;i &#x3D; 30;cout &lt;&lt; &quot;i&#x3D;&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;j&#x3D;&quot; &lt;&lt; j &lt;&lt; endl;j &#x3D; 80;cout &lt;&lt; &quot;i&#x3D;&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;j&#x3D;&quot; &lt;&lt; j &lt;&lt; endl;cout &lt;&lt; &quot;变量i的地址：&quot; &lt;&lt; &amp;i &lt;&lt; endl;cout &lt;&lt; &quot;变量j的地址：&quot; &lt;&lt; &amp;j &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;两中方式都挺好（引用和指针）int main()&#123;int i &#x3D; 15;&#x2F;&#x2F;直接将i的地址赋给iptrint* iptr &#x3D; &amp;i;&#x2F;&#x2F;用rptr引用i（iptr和i表示的是一个空间）int&amp; rptr &#x3D; i;cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; endl;cout &lt;&lt; &quot;iptr is &quot; &lt;&lt; *iptr &lt;&lt; endl;cout &lt;&lt; &quot;rptr is &quot; &lt;&lt; rptr &lt;&lt; endl;&#x2F;&#x2F;尝试更改一个地址中的值即可i &#x3D; 39;cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; endl;cout &lt;&lt; &quot;iptr is &quot; &lt;&lt; *iptr &lt;&lt; endl;cout &lt;&lt; &quot;rptr is &quot; &lt;&lt; rptr &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用作为函数参数<br>下面两种方法得到的效果是一样的，需要熟练掌握。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;void swap(int* p, int* q);&#x2F;&#x2F;这里的p，q是指针类型的整型，即是地址值void swap(int* p, int* q)&#123;int temp;temp &#x3D; *p;*p &#x3D; *q;*q &#x3D; temp;&#125;int main()&#123;int a &#x3D; 5, b &#x3D; 10;cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; &quot;b&#x3D;&quot; &lt;&lt; b &lt;&lt; endl;swap(&amp;a, &amp;b);&#x2F;&#x2F;交换cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; &quot;b&#x3D;&quot; &lt;&lt; b &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;实际上这种方式比较常用，安全性较高并且，比较容易编写#include &lt;iostream&gt;using namespace std;void swap(int&amp; p, int&amp; q);&#x2F;&#x2F;这里的p，q都是整型变量void swap(int&amp; p, int&amp; q)&#123;int temp &#x3D; p;p &#x3D; q;q &#x3D; temp;&#125;int main()&#123;int a &#x3D; 5, b &#x3D; 10;cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; &quot;b&#x3D;&quot; &lt;&lt; b &lt;&lt; endl;swap(a, b);&#x2F;&#x2F;交换cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; &quot;b&#x3D;&quot; &lt;&lt; b &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用引用返回函数值。<br>这个感觉有点难想，到底这个函数返回的是一个整型。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int a[] &#x3D; &#123; 1,3,5,7,9 &#125;;int&amp; index(int i);int&amp; index(int i)&#123;return a[i];&#125;int main()&#123;index(2) &#x3D; 25;cout &lt;&lt; index(2) &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然第一章的学习结束了，但是还有很多没搞懂的地方，之后学习应该会花费更多时间去学习！</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（四）</title>
      <link href="/2022/01/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2022/01/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统（四）"><a href="#操作系统（四）" class="headerlink" title="操作系统（四）"></a>操作系统（四）</h2><h3 id="并发执行问题"><a href="#并发执行问题" class="headerlink" title="并发执行问题"></a>并发执行问题</h3><p><strong>进程同步与通讯、进程死锁</strong><br>两个层次的并发需求</p><ul><li>应用编程要利用操作系统对并发的支持（进程或线程），安排可并行事务并发执行。</li><li>操作系统核心程序也要尽可能地并发运行。</li></ul><p>计算任务存在可并行部分。</p><p><strong>并发编程三种方法</strong></p><ul><li>程序员写顺序程序，用自动识别工具识别可并行成分后，组织使用操作系统地进程或线程实现并发。</li><li>有程序员识别可并行成分，用并发程序设计语言设计并发程序，由编译系统安排使用进程或线程。</li><li>在传统语言基础上，利用操作系统地进程或线程“系统调用”设计并发程序。</li></ul><p><strong>并发程序设计语言–并发语句</strong></p><ul><li>是在传统高级语言基础上增加描述并发地语句。</li><li>语法形式<br>Parbegin S1；S2； …Sn； Parend；<br>Si（i=1，2，…，n） 是单个语句<br>Parbegin和Parend之间的语句可以并发执行</li><li>并发语句示例</li></ul><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/1.jpg"></p><p><strong>并发语句描述手段地优缺点</strong></p><ul><li>并发语句Parbegin/Parend的结构化特征非常好。</li><li>但存在描述能力不强的缺点，即存在着用Parbegin/Parend语句无法描述的并发有限关系。</li></ul><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/2.jpg"></p><p><strong>并发执行机制</strong></p><ul><li>实现并发执行，需要通过操作系统支持的进程或线程机制。</li><li>操作系统提供进程（线程）创建，结束和同步的系统调用，可直接提供给用户编写并发程序，或由并发语言编译器将并发语言的语句转化为对操作系统的系统调用。</li></ul><p><strong>与进程相关的系统调用</strong></p><ul><li>fork（）：创建一个新进程。该系统调用执行完成后，系统已创建了一个子进程，该子进程逻辑复制（共享）了父进程的程序，复制了父进程的数据段和栈段。也就是说不管是父进程还是子进程，在被调度后，都从系统调用的返回点开始运行，父进程系统调用的返回值是子进程的进程标识pid；子进程的返回值是0，子进程从trap指令后一条指令开始运行。 </li><li>exec类系统调用：改变进程映像，将原有映像作废，用新的执行文件初始化进程映像。该类系统调用有6种不同形式：<br>int execl(const char *path, const char *arg, …);<br>int execlp(const char *file, const char *arg, …);<br>int execle(const char *path, const char *arg, const char *envp[]);<br>int execv(const char *path, const char *argv[]);<br>int execve(const char *path, const char *argv[], const char *envp[];<br>int execvp(const char *file, const char *argv[]);</li><li>exit（status）：进程结束。该系统调用发出后，操作系统将从系统中删除调用exit的进程。</li><li>wait（&amp;status）：等待子进程结束。当有多个子进程时，任一个子进程结束即将控制返回调用者，并将子进程调用exit（status）时的status值送到&amp;status指针所指单元中。在控制返回调用者时，同时将所等到的子进程pid作为wait（）系统调用函数的返回值。</li><li>waitpid（pid，…）：等待pid所指定的进程结束。</li></ul><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/3.jpg"></p><p><strong>进程的互斥与同步</strong></p><ul><li>同步关系（亦称直接制约关系）<br>指完成同一任务的伙伴间进程，因需要在某些位置上协调它们的工作而等待、传递信息所产生的制约关系。</li><li>互斥关系（亦称间接制约关系）<br>即进程间因相互竞争使用独占型资源（互斥资源）所产生的制约关系。</li></ul><p><strong>同步与临界段问题</strong></p><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/4.jpg"><br><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/5.jpg"><br><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/6.jpg"></p><p>临界资源：一次仅允许一个进程使用的资源。<br>临界段：相关进程必须互斥执行的程序段。</p><h3 id="同步与互斥实现方法"><a href="#同步与互斥实现方法" class="headerlink" title="同步与互斥实现方法"></a>同步与互斥实现方法</h3><p><strong>利用临界段的硬件方法</strong></p><p>利用处理机提供的特殊指令实现临界区加锁，常见硬件指令有：</p><ol><li>屏蔽中断（单CPU系统）</li><li>“Test_and_Set”指令（多CPU）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（三）</title>
      <link href="/2022/01/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/01/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统（三）"><a href="#操作系统（三）" class="headerlink" title="操作系统（三）"></a>操作系统（三）</h2><h3 id="进程描述与进程状态变化"><a href="#进程描述与进程状态变化" class="headerlink" title="进程描述与进程状态变化"></a>进程描述与进程状态变化</h3><p><strong>进程描述</strong></p><p>进程：是系统中占用处理机及争夺其他系统资源的实体。程序必须在进程中运行。进程运行必须在进程中运行。进程运行必须有栈用于保存现场。</p><p><strong>进程的引用</strong></p><ul><li>为了能实现同一作业的作业步并发。</li><li>在作业某作业步等I/O时，另一逻辑上可并发作业步能使用CPU运行。</li><li>引入进城后，逻辑上可并发的作业步在不同进程中运行。处理机能在进程间切换。</li></ul><p><strong>程序与进程的区别</strong></p><ul><li>相同的程序可以在两个以上的进程中运行（如可以创建多个进程运行相同网页浏览器程序）。</li><li>程序文件存放在磁盘中，运行时读入内存；而进程时在系统运行期间动态创建的，生命周期不会跨越系统运行周期。</li><li>程序只有程序语句及有初值数据变量和无初值变量；而进程一般有要处理的输入数据。</li></ul><p><strong>进程并发时共享资源的问题</strong></p><ol><li>进程定义<br>进程：是有独立功能的程序关于某个数据集合的一次运动活动。</li></ol><p>特点</p><ul><li>动态性：可动态创建，结束，也可是静态进程</li><li>并发性：可以被调度轮流占用处理机运行</li><li>独立性：有独立空间</li><li>制约性：因访问共享数据或进程间同步而产生制约</li></ul><p>组成：管理进程用的PCB表以及进程映像</p><ul><li>执行程序及处理数据，及存放程序和数据的内存空间；</li><li>执行程序用的栈（含用户栈和核心栈）；</li><li>进程描述管理信息及运行要用的其他系统资源。</li></ul><ol start="2"><li>进程控制块PCB与进程映像<br>进程映像：进程执行程序，数据，栈。进程映像是进程存放于内存的对象，如何存放在内存取决于存储管理机制。<br>进程控制块PCB：系统管理控制进程运行用的数据结构。</li></ol><p><strong>PCB含有以下三大类信息</strong></p><ul><li>进程标识信息。如本进程的标识；本进程的产生者标识（父进程标识）；进程所属用户标识。</li><li>处理机状态信息保存区（栈式结构）。实质就是核心栈。保存进程进入操作系统内核的运行现场信息：<ul><li>通用寄存器：数据、地址寄存器。</li><li>控制和状态寄存器：如程序计数器（PC）；处理机状态字（PS）。</li></ul></li><li>进程控制信息<ul><li>调度和进程状态信息，用于操作系统调度进程占用处理机的信息。</li><li>进程间通讯信息，为支持进程间的通讯相关的消息队列，消息等，这些信息存在接收方的进程控制块中。</li><li>存储管理信息。包含有描述进程映像存储空间的数据结构。</li><li>进程所用资源。说明由进程打开，使用的系统资源，如打开的文件等。</li><li>链接信息，如就绪进程链等。</li></ul></li></ul><p><strong>进程的创建与结束等系统调用</strong></p><p><strong>创建处理过程</strong></p><ul><li>接受进程运行所需参数：如进程初始优先级，执行程序及输入参数等参数。</li><li>请求分配进程描述PCB空间，得到一个内部数字进程标识。</li><li>用接收的参数初始化PCB表。</li><li>产生用于描述进程空间的数据结构，用执行程序文件初始化的进程空间，建立程序段，数据段，用户栈短等。</li><li>用进程运行输入参数设置核心栈处理机现场保护区，造一个进程运行栈帧。</li><li>置好父进程等关系域。</li><li>将进程支撑就绪状态。</li><li>将PCB表挂入就绪队列，等待时机被调度运行。</li></ul><p><strong>进程结束处理过程</strong></p><ul><li>将进程状态改到结束状态</li><li>关闭所有打开文件，设备</li><li>释放进程程序文件关联和其他资源</li><li>进行相关信息统计</li><li>清理其相关进程的链接关系，如在linux中，将该结束进程的所有子进程连接到1号进程，作为1号进程的子进程，并通知父进程自己已结束</li><li>释放进程映像空间</li><li>释放进程控制块（PCB）</li><li>调进程调度于切换程序</li></ul><p><strong>进程等待系统调用</strong></p><p>如waitpid系统调用。进程发出此系统调用阻塞于内核等待pid所指进程婞结束。</p><p><strong>进程状态及变化</strong></p><p>状态信息在PCB表中，用于进程调度。主要状态如下：<br>运行状态（running）：进程正在处理机上运行。<br>就绪状态（ready）：进程获得了除处理机之外的一切所需资源，一旦得到了处理机即可运行。<br>阻塞或等待状态（blocked）：进程正在等待某一时间而暂停运行时，如等待某资源称为可用，等待某资源为可用，等待输入/输出完成。<br>创建状态（new）：进程正在被创建，还没到就绪状态之前的状态。<br>结束状态（exit）：进程正在从系统中消失时的状态，这是因为进程结束或其他原因流产所导致的。</p><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/1.jpg"></p><p><strong>状态变化解释</strong></p><ul><li>空–&gt;创建：新进程被产生来执行程序。</li><li>创建–&gt;就绪：当进程被创建完成，初始化后，一切就绪准备运行时变到就绪态。</li><li>就绪–&gt;运行：处于就绪状态的进程被进程调度程序选中后，在处理机上运行。</li><li>运行–&gt;结束：当进程调度用“进程结束”系统调用或者因错流产，当前运行进程会由操作系统做结束处理。</li><li>运行–&gt;阻塞：当进程请求某资源且必须等待时，如，当进程请求操作系统服务，而操作系统得不到所需的资源，或进程请求输入/输出，操作系统已启动外设，但输入/输出尚未完成，或进程要与其他进程通讯，进程准备接受对方还未发出的消息时都会被阻塞。</li><li>阻塞–&gt;就绪：当进程等待的事件（如IO结束中断）发生时，进程从阻塞变到就绪。</li><li>运行–&gt;就绪：进程在其运行过程中，分给它的处理机事件片用完而被剥夺CPU；在可剥夺的操作系统中，当有更高优先级的进程就绪，在进程准备从内核返回用户态运行时进程调度可以将正运行进程从运行状态改变到就绪状态，让更高优先级进程占用CPU。</li></ul><p><strong>挂起</strong></p><p>进程在挂起（Suspend）状态意味着进程没有占用内存空间，处在挂起状态的进程映像在磁盘上。</p><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/2.jpg"></p><h3 id="进程调度与切换"><a href="#进程调度与切换" class="headerlink" title="进程调度与切换"></a>进程调度与切换</h3><p><strong>进程执行</strong></p><p>系统模型：内核程序嵌入进程运行。<br>执行模式（态）：进程可在用户态和核心态下运行。<br>进程模式切换：一个进程既运行用户态程序，在系统调用和中断转换到核心态时运行操作系统核心程序。<br>进程切换：指进程进入操作系统核心后因为自身等事件或由更迫切需要运行的进程就绪而让出处理机，处理机专区运行其他进程。</p><p><strong>进程切换过程</strong></p><ul><li>保存处理机的上下文，包括程序计数器PC、处理机状态字PS、其他寄存器。</li><li>修改当前运行程序的进程控制块内容，包括将进程状态改成其他状态。</li><li>选择另一个进程（按照调度算法）。</li><li>修改被调度进程的进程控制块，包括把其状态改变到运行态。</li><li>恢复被选进程（上次切换出处理机时）的处理机现场，按原保护的程序计数器值重置程序计数器PC，运行新选进程。</li></ul><p>进程调度特指选择进程占用处理机。</p><p><strong>调度的含义</strong></p><ul><li>什么是调度：操作系统管理了系统的有限资源，当有多个进程（或多个进程发出的请求）要使用这些资源时，因为资源的有限性，必须按照一定的原则选择进程（请求）来占用资源。这就是调度。</li><li>调度目的：控制资源使用者的数量或选取资源使用者占用资源。</li></ul><p><strong>几种不同调度的例子</strong></p><ul><li>高级调度：选取输入井中的作业（仅限于批作业调度），生成根进程，开始执行作业步。目的是控制系统资源的进程数。</li><li>中级调度：选取进程占用内存或有资格占用内存，又称进程滚入滚出。</li><li>低级调度：选取进程占用处理机，又称进程调度。</li><li>I/O请求调度：设备驱动程序选取I/O请求执行。</li></ul><p><strong>进程调度方式</strong></p><blockquote><p>注：进程调度在核心态运行。</p></blockquote><p>非剥夺：只有当处理机上的进程主动放弃处理机（阻塞或结束）时才重新调度。<br>剥夺调度：当进程运行时可以被操作系统以某种原则剥夺其处理机。</p><p><strong>引起进度调度因素</strong></p><ol><li>进程主动放弃处理机<ul><li>正在执行的进程执行完毕。操作系统在处理“进程结束”系统调用后应请求重新调度。</li><li>正在执行的进程发出I/O请求。当操作系统内核驱动启动外设I/O后，在I/O请求没有完成前要将进程编程阻塞状态，应该请求重新调度。</li><li>正在执行的进程要等待其他进程或系统发出的事件时。如等待另一个进程通讯数据，这时操作系统应将现运行程序挂到等待队列，并且请求重新调度。</li><li>正在执行的进程暂时得不到所要的系统资源。如要求独占资源，但不能被其他进程占用，这时等待的进程应该阻塞到等待队列上，并且请求重新调度。</li></ul></li><li>为支持可剥夺的进程调度方式，有新进程就绪时（这时申请进行进程调度，新进程才可能剥夺老进程）<ul><li>当中断处理程序处理完中断，如I/O中断引起某个阻塞进程编程就绪状态时，应该申请重新调度。</li><li>当进程释放独占资源，引起其他等待该资源进程从阻塞状态进入就绪状态时，应该申请重新调度。</li><li>当某进程发“发送消息”系统调用，导致等待该消息的进程就绪时。</li><li>其他任何原因引起有进程从其他状态变成就绪状态，如进程被中调选中时。</li></ul></li><li>为支持可剥夺调度，即使没有新就绪进程，为了让所有就绪进程轮流占用处理机，可在下述情况下申请进行进程调度<ul><li>当时钟中断发生，时钟中断处理程序调用有关时间片的处理程序，发现正运行进程时间片到，应请求重新调度。以便让其他进程占用处理机。</li><li>在按进程优先级进行调度的操作系统中，任何原因引起进程的优先级发生变化时，应请求重新调度。如进程通过系统调用自愿改变优先级时或者系统处理时钟中断时，根据各进程等待处理机的时间长短而调整进程的优先级。</li></ul></li></ol><p><strong>调度与切换时机</strong></p><ul><li>当发生引起调度条件，且当前进程无法继续满足运行下去时（如发生各种进程放弃处理机的条件）可以马上进行调度与切换。</li><li>当中断处理结束或系统调用处理结束返回被中断进程的用户态程序执行前，若申请调度标志置上，即可马上进行进程调度与切换。如果操作系统支持这种情况下运行调度程序，即实现了剥夺方式的调度。</li><li>实时系统还有其他调度与切换时机。如中断处理结束返回系统调用处理时。</li></ul><p><strong>进程调度算法</strong></p><p>调度算法要求：高资源利用率、高吞吐量、用户满意等原则</p><ul><li>FCFS：谁先到就绪队列，将处理机分给谁。</li><li>短进程优先：取一个下次所需运行时间最短的进程（该算法能使平均等待时间最短）。</li><li>最高响应比优先法：响应比R定义如下：R=（W+T）/T=1=W/T（W为等待时间，T为下次所需运行时间）</li><li>优先级调度：选优先级最高的进程占用处理机，（优先级也可动态改变）。</li><li>轮转调度法：以先来后到的次序+时间片轮转。</li><li>多级反馈队列调度法：设置多条就绪队列，进程被调度执行后，在被剥夺或放弃处理机后而再就绪时可以改变其就绪队列。</li></ul><p><strong>作业与进程的关系</strong></p><ul><li>作业：是用户对计算机的一次独立的使用过程。</li><li>进程：是分配计算机资源的单位，是用户任务运行的实体，作业可包含多个进程（至少一个）。</li><li>批处理系统作业与进程关系：作业调度程序没选择一道作业运行时，首先为该作业创建一个根进程，该进程执行作业控制预压解释器程序，再解释器执行作业步时可根据需要创建多个子进程。</li></ul><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/3.jpg"></p><p>分时系统作业与进程的关系：把用户的一次上机过程看成是一个交互作业（内部表示及外部特征都有别于批作业），系统为每个中断设备生成一个进程，该进程运行终端命令解释器。进程在解释执行命令时还可以创建多个子程序。<br>支持分时与批处理的系统作业提交办法：用户可以通过交互式命令提交子作业。</p><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/4.jpg"></p><p><strong>线程引入</strong></p><ul><li>轻权线程的引入：同一作业的不同进程之间会有许多的协作，需要进行数据交换，单进程有自己独立的存储空间，互相不干扰。如果要进行进程间数据交换，则需要操作系统相关系统调用进行交换，为了方便进程间交换数据，一种共享存储空间的进程概念应运而生，我们称它为轻权进程。</li><li>线程的引入：随着共享内存多CPU计算机的发展，迫切需要加速进程的运行速度，事实上进程中运行的程序也是有可并行执行的语句。因为进程内程序执行的顺序性，不吭你实现进程内可并行成分的并行执行。为此，线程的概念呼之欲出。在一个进程中可包含多个可以并发（并行）执行的线程。系统按进程分配所有出CPU以外的系统资源（如内存，外设，文件等），而程序则依赖线程运行，系统按线程分配CPU资源。引入县城后，进程概念内涵改变了，进程只作为除CPU以外系统资源的分配单位，不再以进程为单位占用CPU。</li></ul><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/5.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）</title>
      <link href="/2022/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统（二）"><a href="#操作系统（二）" class="headerlink" title="操作系统（二）"></a>操作系统（二）</h2><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><p><strong>中断/异常（陷入）</strong></p><p>中断的引入：实现多道程序设计。因通道已经能独立与CPU工作，多道程序可以让CPU和通道（设备控制器）之间的并行。</p><ul><li>当CPU启动通道（或设备）进行输入输出后，通道可以独立工作，CPU既可以转去做其他任务；</li><li>通道（或设备）输入输出完成后，通道通过向CPU发中断告诉CPU此次输入输出结束，让CPU继续执行原任务输入输出后的程序。</li></ul><p>异常（陷入）引入：实现异常情况处理。当下述情况发生，CPU中断当前的执行流程，转到相应的错误处理程序或陷入处理程序。</p><ul><li>CPU执行指令时本身出现算术溢出，零做除数，取数时的奇偶错，访存指令或虚存缺页等。</li><li>执行了一条所谓“trap指令”，用于实现系统调用。</li></ul><p><strong>中断/异常（陷入）处理</strong>：系统发生某个异步/同步事件后，CPU暂停正在执行的程序，转去执行处理该事件程序，处理完成后返回暂停点继续。</p><p><strong>中断/异常（陷入）分类</strong></p><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/1.jpg"></p><p>中断（狭义）与异常（陷入）的区别</p><ul><li>中断：与正执行指令无关，可以屏蔽。</li><li>异常或陷入：与正执行指令有关，不可屏蔽。</li></ul><p><strong>中断的分级与屏蔽</strong></p><p>中断寄存器：寄存中断事件的全部触发器。<br>中断位：每个触发器称为一个中断位，当发生某个中断事件时相应位被置上。<br>中断序号：给中断的一个顺序编号。<br>中断响应：由硬件在执行每一条指令的最后时刻判断是否有中断，有则转入操作系统的中断处理程序。<br>中断优先级：中断的优先程度。原则上，高、低优先级中断同时到先响应高级中断。高级中断可以打断低级中断处理程序的运行，同级中断同时到达，则按位序响应。</p><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/2.jpg"></p><p><strong>中断优先级设计原则</strong></p><ul><li>从提高资源利用率的角度考虑：高速设备的中断优先级高，慢速设备的中断优先级低。</li><li>在交互式系统中也可以考虑用户相应满意原则。</li><li>实时系统中，实时设备优先。</li></ul><p>举例：某机上的UNIX系统把中断级别分为：<br>时钟中断：中断优先级＝6级<br>磁盘中断：中断优先级＝5级<br>终端等其它外设中断：中断优先级＝4级</p><p><em>处理机优先级：指处理机正运行程序可响应中断的级别。在中断处理程序运行前设置。即当处理机处理某一优先级时，只允许处理及去相应比该优先级高的中断，而屏蔽低于或等于该优先级的中断。</em></p><p>中断屏蔽：指禁止处理机响应中断或禁止中断出现。<br>中断屏蔽的软件实现方法：由软件按中断优先级约定，在响应某级中断时置屏蔽寄存器，屏蔽那些同等级和低级的中断。</p><p><em>问：如何设计包含时钟、磁盘、键盘、鼠标的中断优先级及在你的设计下磁盘中断处理时如何设置屏蔽寄存器？</em></p><p><strong>中断/异常（陷入）响应和处理</strong></p><ul><li>中断响应：CPU能够在每条机器指令执行周期内的最后时刻扫描中断寄存器，查看是否有中断信号。若无中断信号，CPU继续执行程序的后续指令，否则CPU停止执行当前程序的后续指令，转入操作系统内的中断处理程序。这一过程称为中断响应。</li><li>异常响应：异常（陷入）是在执行指令的时候，由指令本身的原因发生的，CPU中指令的执行逻辑发现了异常（陷入）转入操作系统内的异常（陷入）处理程序。</li></ul><p><strong>几个基本概念</strong></p><ol><li><p>断点和恢复点</p><ul><li>PC：程序计数器。指向马上要执行的拿一条指令。</li><li>断点：检测到中断时，处理机刚执行完的那条指令地址。</li><li>恢复点：指中断那一刻确保被中断程序能继续运行的有关信息。如PC,通用寄存器，其他特殊寄存器等。</li></ul></li><li><p>核心态与用户态<br>核心态（系统态，监督方式，管态）：允许特权指令执行的状态，在此状态下可访问系统空间，也可访问用户空间。<br>用户态（用户态，用户方式，目态）：一般程序所运行的状态，只访问用户程序程序空间。<br>PS(PSW)：处理机状态字，又叫程序状态字。寄存处理机运行状态的寄存器，包含：</p><ul><li>当前处理机运行态</li><li>处理机优先级</li><li>各种控制位（如外中断赋能位）</li></ul></li><li><p>中断向量<br>中断向量：一片存放中断处理程序入口地址和程序运行所需处理机状态自己的内存单元。<br>中断向量由操作系统初始化程序进行设置，硬件按中断号，异常（陷入）剋行的不同通过中断向量表散转到相应处理程序。</p></li></ol><p>中断/异常（陷入）处理的一般过程</p><ul><li>中断，异常（陷入）进入</li><li>保存现场</li><li>分析原因，转中断/异常（陷入）处理程序</li><li>恢复现场</li></ul><p><strong>某机UNIX中断处理详细过程</strong></p><ol><li><p>中断，异常（陷入）进入</p><ul><li>硬件自动将当前PC，PS存入暂存寄存器。</li><li>硬件按中断号从指定的中断向量单元中取出新的PC，PS内容装入PC，PS寄存器。</li><li>将原PC，PS保存到现场保护区栈。</li></ul></li><li><p>保存现场</p></li></ol><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/3.jpg"></p><p><strong>一个现场区栈帧的形成过程（原则：用寄存器之前寄存器原内容先入栈）</strong></p><ul><li>硬件将暂存PC，PS压栈，且根据中断类将中断向量表中的新的PS，PC值送PS，PC寄存器。</li><li>中断入口第一条为转总控程序指令，该特殊转移指令将r0压栈且将中断处理程序地址存入r0。</li><li>由总控程序将心得PS压栈（因其中有陷入号信息）。</li><li>由总控将r1，r6压栈（r6中为栈指针，此时是上一栈帧顶）。由总控从新的PS低五位截取trap号进入栈。</li><li>总控在转响应中断（trap）处理程序时，将返回地址压栈。</li><li>由各中断或trap处理程序先将r5，r4，r3，r2压栈，返回总控时恢复r2，r3，r4，r5。</li></ul><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/4.jpg"></p><ol start="3"><li>分析原因，转中断/异常（陷入）处理程序<br>总控程序直接根据r0（已存放好中断程序的入口地址）内容转子，进行中断（陷入）处理。转子时已将返回地址压栈（转子指令自动）。</li></ol><blockquote><p>注：中断处理通常是向设备控制器发下一个I/O请求，并就绪原等I/O结束的进程。异常（陷入）处理包含操作系统系统调用处理，或异常时进程结束处理。</p></blockquote><ol start="4"><li>恢复现场（总控程序）</li></ol><p><strong>回退到核心态时</strong></p><ul><li>退栈</li><li>执行rtt指令，该指令自动将栈帧中保存的原PC，PS值装入PC，PS寄存器</li></ul><p><strong>回退到用户态时</strong></p><ul><li>低调（进程调度）</li><li>退栈</li><li>执行rtt指令。该指令自动将栈帧中的PC，PS值装入PC，PS寄存器</li></ul><p><strong>总结</strong><br>中断/异常（陷入）引起系统内核程序运行</p><ul><li>中断处理可嵌套</li></ul><p>中断/异常（陷入）响应和处理过程 </p><ul><li>硬件保存PC、PSW</li><li>软件继续保存现场</li><li>中断/异常处理</li><li>（进程调度）恢复现场 </li></ul><h3 id="操作系统运行模型与用户接口"><a href="#操作系统运行模型与用户接口" class="headerlink" title="操作系统运行模型与用户接口"></a>操作系统运行模型与用户接口</h3><p><strong>一、操作系统核心的主要功能模块</strong></p><ul><li>系统初始化模块：准备系统运行环境，最后创建进程运行命令解释程序/程序管理器。</li><li>进程管理模块：处理进程类系统调用（如进程创建/结束、进程间通讯等）；进程调度。</li><li>存储管理模块：配合进程管理分配进程内存空间；处理存储类系统调用（如动态增加进程空间）；虚存系统缺页时调入页面处理。</li><li>文件管理模块：处理文件类系统调用。</li><li>外设管理模块：负责外设驱动，中断处理。</li></ul><p><strong>操作系统三种运行模型</strong></p><ul><li>独立运行的内核：用户程序与核心程序在分离的运行环境中运行，核心程序作为一个独立的特殊执行单位运行，有自己独立的运行栈，用户进程通过中断/陷入机制启动核心程序运行（已请求包方式传递用户请求）。</li></ul><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/5.jpg"></p><ul><li>嵌入用户进程执行模式（类函数调用）：操作系统核心程序通过中断/陷入机制启动运行，但运行于被打断进程的核心栈上，内核程序执行并发性好。</li></ul><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/6.jpg"></p><ul><li>微内核模式：核心程序只包含中断处理，系统调用总控，进程调度等功能，其他功能由用户运行的系统程序实现，这种结构开销很大。</li></ul><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/7.jpg"></p><p><strong>二、系统调用</strong></p><p>凡是涉及操作系统管理资源的操作必须由系统调用实现。</p><p><strong>主要系统调用</strong></p><ol><li>进程管理<ul><li>创建进程   pid=fork()</li><li>终止进程   exit(status)</li><li>等待子进程结束  pid=waitpid(pid,…)</li><li>替换进程映像  s=execve(name,…)</li></ul></li><li>文件管理<ul><li>创建文件 fd=creat(name,…)</li><li>打开文件 fd=open(name,…)</li><li>读文件  n=read(fd,buffer,nbyte)</li><li>写文件 n=write(fd,buffer,nbyte)</li><li>移动文件指针 pos=lseek(fd,offset,…)</li><li>关闭文件 s=close(fd)</li></ul></li><li>存储管理：动态申请/释放进程空间等</li><li>其他：设置/获得事件等</li></ol><blockquote><p>注：用户编程时不一定直接调用“系统调用”接口函数，而是调用更高层的库函数，如win32的API函数、C库函数等。</p></blockquote><p><strong>自陷指令（trap）</strong></p><ul><li><p>系统调用是一种特殊形式的转子方法，他导致处理机态的变化。为了方便编程，提供系统调用接口库，由苦衷的接口函数来执行trap，用户程序库调用库的接口函数。</p></li><li><p>系统调用库接口函数汇编程序包含</p><ul><li>（传给核心的参数按约定填入寄存器）trap指令</li><li>（从约定的寄存器中获得核心返回值）</li></ul></li><li><p>处理机执行trap指令会导致控制转到操作系统内核的trap处理程序的入口，trap处理程序获得参数，按系统调用入口表散转到各处理程序。</p></li><li><p>参数传递的一般形式</p><ul><li>用约定寄存器传递系统调用号等参数</li></ul></li></ul><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/8.jpg"></p><p><strong>命令语言与窗口用户界面</strong></p><p><em>命令语言（在批处理系统中是作业控制语言）</em></p><ul><li>它是控制作业流程的用户操作界面，有语言解释器解释执行命令。</li><li>linux启动一个命令解释器执行的过程：<ul><li>系统启动时1号进程为终端生成一个tty进程，让其运行登陆程序。</li><li>用户输入ID及口令，验证完用户后，转去执行shell永陵解释器</li><li>由解释器处理用户输入命令</li></ul></li></ul><p><strong>shell解释器流程（功能：解释执行shell命令）</strong></p><ul><li>调用“从终端读”系统调用接受输入命令</li><li>直接处理一些控制语句，简单命令</li><li>对不识别的命令关键字，到PATH环境变量所指目录中找到与命令关键字同名执行代码文件，产生子进程运行该程序</li><li>等子进程结束后转1</li></ul><p>实用程序；服务程序；自己开发程序都可以通过敲入对应的终端命令而运行的。</p><p><strong>系统主要的实用程序</strong></p><ul><li>编辑器。供用户建立和修改文本文件。它会提供一组内部编辑命令。</li><li>编译器和装配器。实现编译源程序、链接模块、装配目标程序等功能。</li><li>文件及文件系统相关的实用程序。文件的拷贝，打印，文件系统装卸等。</li><li>显示系统进程，资源状态的实用程序。</li><li>用户管理。如用户加入删除，口令修改。</li></ul><p><strong>用户命令与系统调用的关系</strong></p><ul><li>用户命令对应的实用程序（包括命令解释器本身）在用户态运行，而系统调用处理程序在核心态运行；</li><li>实用程序在运行过程中可能会调用“系统调用”；</li><li>用户命令时用户操作接口，系统调用时用户与操作系统之间的编程接口。</li></ul><p><strong>图形化的用户界面</strong></p><ul><li>所有命令行都用图符，菜单来表示，参数则通过对话框，提示用户选择或输入。</li><li>命令解释器变成了图形化的程序管理器。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）</title>
      <link href="/2022/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统（一）"><a href="#操作系统（一）" class="headerlink" title="操作系统（一）"></a>操作系统（一）</h2><h3 id="计算机概述"><a href="#计算机概述" class="headerlink" title="计算机概述"></a>计算机概述</h3><p><strong>操作系统的地位</strong></p><ul><li>计算机系统管理中心（类比社会中的政府）</li><li>在计算机系统中不可缺少，用户不可能上机使用计算机资源</li><li>关乎计算机系统的安全</li><li>最复杂最精确的人工开发的online管理系统</li></ul><p><strong>什么是操作系统</strong></p><p>为什么引入操作系统？方便用户编程及操作，提高资源利用程度。</p><p><strong>计算机系统软件构成</strong></p><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/1.jpg"></p><p>狭义操作系统包含程序：操作系统内核。<br>广义操作系统包含程序：操作系统内核，用户态运行的命令解释器（程序管理器）和系统调用库，及许多提供系统常用功能的使用程序，库程序。</p><p>操作系统及其他软件放在磁盘上，要运行的时候放在内存里。</p><p><strong>三角度看操作系统</strong></p><ol><li><p>操作系统作为特殊子程序</p><ul><li>操作系统内核为用户层的程序提供了系统调用接口</li><li>系统调用是特殊的公共子程序调用，用户不需要重复编写实现公共的程序而只要调用相应系统调用即可。</li></ul></li><li><p>操作系统作为资源管理者</p><ul><li>让计算机资源被多任务同时使用：为了使硬件资源充分发挥它们的作用，必须允许多用户任务同时使用计算机，以便让不同的资源由不同的用户任务尽可能的同时使用。</li><li>举例：当一个用户任务将文件数据从磁盘读出送往内存缓冲区时，另一个用户任务程序在处理机上运行。这样处理机、内存、磁盘都忙起来了。</li></ul></li></ol><p><strong>两种资源共享使用的方法</strong></p><p>空分：针对存储资源而言，存储资源的空间可以被多个用户（进程）以分割的方式占用。<br>时分：由多个用户任务分时得用该资源，除了处理机资源外，还有很多其他的资源也必须分时地使用，如输入输出控制器、网卡等。时分又区分独占式和分时式。</p><p><strong>时分共享两种不同的使用方法</strong></p><ul><li><p>独占式共享，独占表示某用户任务占用该资源后，执行了对资源的多个操作，使用了一个逻辑完整的周期。<br>举例：多用户任务独占式共享使用打印机，是指多用户任务分时段共享使用该打印机，但某用户任务使用打印机时，执行了多条打印指令，打印了一个逻辑完整的对象（如完整的文件）。用户任务需要在执行打印指令前申请独占该打印机资源，执行完打印指令后释放。</p></li><li><p>分时式共享，也就是说用户任务占用该资源无需使用一个逻辑上的完整周期，或者说一次使用就是一个完整周期。<br>例1：对处理机的使用，只要运行现场保存好了，用户程序随时都可以被剥夺CPU，下次该用户程序再次占用CPU时恢复现场就可以继续运行。<br>例2：磁盘的输入输出，当一个用户任务让磁盘控制器执行了一条输入输出请求后，其它用户任务也可向磁盘控制器发输入输出请求，系统并不要求某个用户任务的几个输入输出请求之间不能插入其它任务的输入输出。 </p></li></ul><ol start="3"><li>操作系统组织用户的多任务（以进程方式）使用计算机</li></ol><p><strong>引入并发概念</strong></p><ul><li>程序执行，操作系统需给程序及程序数据安排存放空间。</li><li>为了能提高资源利用率，增加并发度，还必须能让多个程序能分时占用处理机。</li><li>要能让一个程序还没运行完就让另一个程序占用CPU运行，就必须保存上一个程序的运行现场。</li></ul><p><strong>进程机制</strong></p><ul><li>因此必须要对各个程序的执行进行描述和控制。</li><li>利用数据结构保存程序执行的状态、现场、标识等各种信息，能分时调度某个程序占用CPU运行，这就是进程机制。</li></ul><p><strong>总结</strong></p><p>操作系统是软硬资源的控制中心,它以尽量合理有效的方法组织多个任务共享使用计算机的各种资源并提供编程接口和操作接口。</p><h3 id="操作系统发展历史与现状"><a href="#操作系统发展历史与现状" class="headerlink" title="操作系统发展历史与现状"></a>操作系统发展历史与现状</h3><p><strong>操作系统的发展历史</strong></p><ul><li>单道批处理时代（50年代）</li><li>多道批处理，分时，实时系统时代（60年代初）</li><li>多方式系统时代（60-70年代）</li><li>PC操作系统、网络系统和多机系统时代（70年代后）</li></ul><p>史前年代：计算机刚问世,除硬件和应用软件外,几乎没有中间层软件，没有操作系统，用户独占机器，由系统操作员操作机器。</p><p><strong>监督程序</strong></p><p>引入目的：减少操作员手工操作。<br>基本思想：操作员把若干作业合成一批，安装在输入设备上，启动常驻内存的监督程序，然后由监督程序依次顺序启动这批作业，单道方式运行。</p><p><strong>引入概念</strong></p><p>作业：用户的一次上机行为。<br>作业步：作业的执行步骤。<br>作业控制语言：用于说明作业如何执行的语言。<br>作业控制说明书：用作业控制语言编写的作业执行程序。<br>普通指令：用户程序监督程序都可包含的指令，如算术、逻辑运算指令等。<br>特权指令：只有监督程序才可包含的指令，如屏蔽中断指令等。<br>方式/态：指处理机能否执行特权指令的状态。在核心方式（态）除能执行普通指令外还能执行特权指令。在用户方式（态）下只能执行普通指令。<br>系统调用（广义指令）：由监督程序提供给用户调用的系统功能。<br>TRAP机制：硬件支持进入监督程序的机制。如执行trap指令实现系统调用（与转子指令类比）。<br>系统空间：监督程序所占内存（0-K）。<br>用户空间：供用户程序使用的内存（K+1-N）。<br>存储保护：限制用户程序访问系统空间。硬件提供一个界地址寄存器，每次执行访存指令时，如果处理机在用户态下，则判断访问是否越界。<br>定时器中断：为处理作业超时引入。在对丁时间间隔到时，系统暂停当前程序之运行，去进行时间相关的处理，如看作业是否已超过其运行期限。</p><p><strong>早期批处理系统中的监督程序工作流程</strong></p><ol><li>判断输入设备上是否由待输入作业，没有则等待；</li><li>从设备上输入一道作业；</li><li>控制作业运行<ul><li>取作业说明书中一条语句，解析执行，如果是“作业终止”语句，则删除该作业，转1</li><li>如果是一条执行性语句，则在主存中建立相应程序运行环境，传递好参数，转去执行该程序（变到用户态运行）</li><li>在用户态程序运行过程中，如发生中断事件（如系统调用/定时器中断），立即转监督程序，待中断事件处理结束后，用户态程序继续执行</li><li>用户态程序结束后，转a</li></ul></li></ol><p>监督程序功能：输入用户作业，解释执行作业控制说明书，提供系统调用。<br>监督程序与操作系统的区别：监督程序不具并发机制。监督程序知识省去了作业步和作业转接的人工开销。</p><p><strong>专用操作系统（60年代初躲到批处理，分时，实时系统时代）</strong></p><ul><li>多道批处理</li><li>分时系统</li><li>实时系统</li></ul><p><strong>一、多道批处理系统</strong></p><p>引入：源于外设的智能化和磁盘的出现。<br>目的：让计算机各部件并行运行。<br>特点：在单道批处理系统的基础上引入缓存机制，SPOOLing技术，多道程序设计技术。</p><ol><li><p>输入输出缓冲，利用缓冲技术，使针对一个缓冲区的数据处理和针对另一个缓冲区的I/O并行运行。</p></li><li><p>SPOOLing技术（假脱机输入输出技术）</p></li></ol><ul><li><p>基础</p><ul><li>I/O中断：由I/O不见操作完成后通知处理机去运行相应的处理程序。</li><li>通道：能够自主控制外设与贮存并行交换数据的I/O装置（控制器）。</li><li>磁盘：随机存取的存储设备。</li></ul></li><li><p>SPOOLing的基本思想：用磁盘设备作为主机的直接输入输出设备，即主机从磁盘选取作业运行，结果也存在于磁盘中。相应的通道则负责磁盘与慢速外设的传输。利用通道和中断机制，作业的输入输出与作业在处理及上的运行并行。</p></li></ul><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/2.jpg"></p><ol start="3"><li>多道程序设计</li></ol><p>基本思想：内存同时保持多道程序（作业），处理机（单处理机）以交替的方式（并发）处理多道程序。从宏观上看，已有多道程序开始运行并且尚未结束，从微观上看，某一时刻处理机只运行某道作业。</p><p><img src="../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/3.jpg"></p><p>现场保护/恢复：指处理机从一个作业向另一个作业切换时进行的程序运行用寄存器值保护/恢复。</p><p>多道批处理开始引入操作系统的基本特征：</p><ul><li>并发：在单处理机情况下指多道程序分时占用处理机运行。</li><li>共享：指并发运行程序对系统的硬软资源的空分与时分使用。</li></ul><p><strong>二、分时系统</strong></p><p>目的：实现计算机各部件并行运行+用户与自己作业及时交互。<br>基础：终端设备（键盘与显示器）出现。<br>交互式系统：操作系统提供终端命令语言及语言解析器，用户通过终端指导作业运行。</p><p><em>分时系统：交互式系统与多道程序设计结合的产物。</em></p><p>分时系统特点：并发性、交互性、共享性、独立性。</p><p><strong>三、实时系统</strong></p><p>实时系统：能满足要求快速响应作业运行的多道程序设计系统。</p><p><em>实时系统主要性能指标和功能：</em></p><ul><li>时钟分辨度：有更高的始终终端频度，可更精确计时，更快进行作业调度。</li><li>多级中断机制：保证要求快速响应中断的及时处理。</li><li>作业分级：保证实时作业无条件优先运行。</li></ul><p><strong>多方式系统时代（60-70年代）</strong></p><p>多种方式操作系统：同时具有批处理，分时，实时功能的系统。</p><p><strong>并行与分布式操作系统及发展（80-）</strong></p><p>网络及分布式操作系统：支持互联网和分布处理的系统。<br>多机操作系统：支持共享内存多处理机SMP的系统。<br>window操作系统：支持友好的用户界面的系统。</p><p><strong>操作系统的发展趋势</strong></p><p>嵌入式操作系统：主要伴随着个人数字助理PAD,掌上电脑，手机，机顶盒，智能家电等设备的发展，对操作系统在实时性和所占空间大小权衡上提出了新的要求。<br>虚拟机系统：在计算机系统中虚拟出多台计算机系统。<br>MPP并行操作系统的研究：如建立在基于共享主存的多处理机系统(MP)及用上千个微处理器实现基于分布式存储的大规模并行处理机系统(MPP)的操作系统，系统突出特征是提供各类并行机制。例如并行文件系统，并行I／O控制，多处理机分配和调度，处理机间的通讯和同步，用户任务的并行控制等。<br>网络与分布式操作系统的研究：就目前情形而言，网络系统的研究也还方兴未艾，基于Client／Server模型的分布式系统也已不断走向应用，目前云计算平台如火如荼，完全透明分布式系统还未成型，仍将是研究的热点问题。</p><p><strong>内核保护是操作系统安全的重要保证，程序并发（并行）运行是操作系统的精髓。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>晨晨的周记</title>
      <link href="/2021/08/06/%E6%99%A8%E6%99%A8%E7%9A%84%E5%91%A8%E8%AE%B0/"/>
      <url>/2021/08/06/%E6%99%A8%E6%99%A8%E7%9A%84%E5%91%A8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="晨晨的新生活"><a href="#晨晨的新生活" class="headerlink" title="晨晨的新生活"></a>晨晨的新生活</h2><p><img src="../%E6%99%A8%E6%99%A8%E7%9A%84%E5%91%A8%E8%AE%B0/1.JPG"></p><h3 id="周记一"><a href="#周记一" class="headerlink" title="周记一"></a>周记一</h3><p>已经是上上个星期的事情了，我还拖欠了两篇周记，enmmmme怎么说呢，具体点一点的事物已经记得不是很清楚了，只能大概回忆一下阐述一下当时较为深刻的感受，那是波比来的第一周，那几天说实话挺兴奋的，也期待他来，但是后来他告诉我还没买票时我内心其实有点焦急，跟他说让他赶紧买不然没票了，我自己手上也没有停下动作，马上转去看票，结果可想而知已经没票了，我当时跟他说要不之后再来，他说再不来可能之后也没时间能过来了，我就在想那你不早点买票，结果他跟我说不买票是因为我每次都跟他说，种种不利的因素，要么他没心情来了。要么就是我这边有事情没办法陪他，我当时心里气的要死，眼泪已经在的打转了，一点话都不想跟他说了，所以说这一切怪我是吧，由于在公司，当时又是午休时间已经1点了，我想着算了既然来不了那也没办法那就再说吧，但还是没忍住流泪了，旁边坐着同事不想被他看到就靠在臂弯里偷偷擦，过了没几分钟手机连续振了好几下，我知道估计是他给我发消息了，我把手机拿起来一看他已经买了票，我偷偷笑了一下想着他还是想来的，看着他臭屁自恋的话，说怎么可能有他办不到的事情呢，我心想呵呵，但还是抑制不住雀跃的心情，感觉那天下午都过得很快。</p><p>周六起了个早床去接他，以前老埋怨我不去找借口，哪里是我不想去哼，不是天没亮就是快10多点了，还是我从来没去过的飞机场，还得走好远晚上又荒无人烟的，想想就可怕，典型的凶案现场好吗？因为之前说过改票了，所以知道他会迟到一会，我想着穿什么衣服，化个好看的妆，第一次见面得精致点，然后搞好之后给他发消息他说还没，之前8点说到武昌了，他让我十点多出门，我答应了然后想着之前他说过喜欢花刚好早到了一点，就去买了一束花，结果就迟了点然后地点我还搞错了，笑死人，我看到他时他还没看到我，也不知道眼睛长哪了，明明感觉往这边看了一眼，结果就是看不到，然后我慢慢靠近他终于看到了，我脸上戴了口罩，然后揭口罩的时候被夸了说比之前好看，超级开心！但是嘴巴上还在赌气说怎么我以前不好看吗，然后和他一起回家，休息了一会就出去吃东西了，又去了五一吃了上次没有吃到的湘菜，辣辣的很下饭，晚上骑上了心爱的小摩托，开始我载他但是他老说我危险驾驶老和尚念经，我就让他来了，他动作慢吞吞的我在后面笑yue了，停车后买了点水果一起走回了家。</p><p>第二天本来说好的去长沙的水上世界，偏偏天气不好真的有毒，我都好几个月没见过雨了好吗，excuse me乌鱼子，然后转战去了昭山的水上乐园，正好那边没怎么下，玩的也很开心，一开始还有点不敢玩那种恐怖的项目，后来感觉有点上瘾，那个地方不能带吃的我们就没有带，我们家那位差点没被饿死，都没力气了已经，晚上有个小插曲，我们吵架了，没错我自己都没想到，这算是线下第一次这样吧，具体我就不说了，不想回忆吵架的事情，后来和好了，去吃了牛肉饼炸鸡，没吃完打包回来了，开心！又是圆满的一天。</p><p>红豆生南国，春来发几枝……​​​​​​​</p><h3 id="周记二"><a href="#周记二" class="headerlink" title="周记二"></a>周记二</h3><p>接下来的一周就简单多了，我去上班然后他在家里面搞学习，然后我们晚上会在外面吃一顿饭，吃过肥肠、小龙虾、牛排、披萨等等一些，那一周算是我过过最舒适的一周，每天早上一睁眼就能看到他，亲亲一下然后去上班，在上班的时候又会期待下班两个人独处的时光，怎么说呢，我感觉还挺不错的但是不知道他是不是有点不适应，房子确实小了点，他可能有点活动不开，再就是他附近不是特别熟悉，我感觉没我在家会不会饿肚子，有点小担心，估计只能饿了吃点零食啦，那周是真的很充实，有点向往以后他过来的生活了，之后在家这样过了几天之后，周末他要走了，前面说的牛排就是星期五晚上吃的，他可能是看我想吃，就在网上找个一家评分比较好的餐厅，吃的还行吧。笑死我一直跟他说咱要不下次吃豪客来吧，便宜还好吃，他也笑着说觉得，我觉得他满足了我所有想要的仪式感，我以前并不是追求仪式感的一个人，后来他让我觉得有些仪式感还是很不错的。</p><p>周六本来定好的票，由于河南的洪水不得不改道了，幸好他提前察觉了，嘿嘿还挺靠谱有时候，不过有时候挺不靠谱的，比如他的眼镜被自己压坏了随手放床上结果没看到，啪嗒坏了，眼镜腿直接掉了，又得换新的了，说他浪费钱吧，气死了，最后一天临走前，我做了一顿饭给他，平常老给他拍照片，来了一个星期了他也没吃过，中午去买了菜，他估计早饿了，本来让他吃点东西先垫垫，他估计怕吃了等会子吃不下我做的饭了，强忍着没吃，真是个小懒虫，我让他出去就真走了，也不说帮我削皮啥的，我赶他走不是怕他热嘛，大直男我忙活了两个多小时，还嫌我慢了，不过我做饭确实慢了点再加上做了两个荤菜，耗费的时间就更多了，吃完了饭送他到火车站走了，我回去的时候才得知他买的硬座，这个笨蛋也不早告诉我一声，虽然只有硬座了，但是至少能给他买个枕头啥的吧，唉折腾了他一晚上，下午才到估计累的够呛，我上次回来也这样，果然恋爱是一件累但是也很甜的事情！</p><p>河南加油挺过去，冲冲冲！</p><h3 id="周记三"><a href="#周记三" class="headerlink" title="周记三"></a>周记三</h3><p>转眼又到了明天应该上班的时候了，感觉时间真的过得好快啊，不管是工作还是闲暇的时光总是快的让人抓不住，确实古人的名言写的是对的，真的有种时不待我的感觉，这周五刚好是我工作满了一个月的日子，enmmmm怎么说呢，相比起我一个月前的青涩，现在的我显得熟练了很多，虽然还是时常有出错的地方，但是少了之前看着文件的手足无措，多了一份自信心，周五下班时如往常一样多待了一会，不知道为什么走的时候心里有种意犹未尽的感觉，可能是逐渐体会到了这份工作的乐趣吧，想想我之前刚来入职时，好奇我以后的工作内容，就看了我同事做的东西，当时我的心里还觉得这有什么难得，我肯定能应付来，现在想想真可笑，要被自己打脸了，这个确实没有我当初想的那么容易，果然是内行看门道，外行看热闹，不进来根本不知道到底难在何处，之前基本完全是小白，都是问的同事再加上自己摸索，现在会偶尔问问组长了，虽然有时候还是不够细心会被骂的狗血淋头，但是自己明显觉得在往前走，还是很开心的，骂吧骂吧挨骂了我才能多长点记性，没关系忍忍就过去了，来的这一个月大家都说我时间挑的好，没加什么班，目前手上的这个项目快结束了，下个项目要得急，月底就得交稿，所以我下周开始可能会比较忙了，要加班了，不知道会不会通宵有点小慌张哈哈，但是我会尽力去做的，而且又不是我一个人还有大家呢。</p><p>周末爸爸给我寄来了一些东西，一些日常的菜啊剁辣椒小鱼还有充电线啥的，快递很给力一晚上就到了，给爷爷打了电话问候了一声，本来想打视频的可惜姑姑不在，有家人记挂确实挺幸福的，马上要迎来国庆和中秋了，要计划着回去一趟了陪陪他们，还有远方的小波比，你这段时间过得好不，有没有吃好睡好，别天天埋头学习哦，还是得适当休息会，虽然确实考研很难，尤其是好学校的研究生更难，当时我相信你可以的哦，大约还有137天哦，别紧张相信你自己就行，毕竟未来的路还长着这只是人生的一小段而已哈哈，你天天跟我说别孤独啊，我不会的呢，我还怕你孤独呢，不过你有事情可做应该还好，嘿嘿我其实很满足啦，现在的生活，偶尔和你通通电话，每天早安晚安的问候，这次看的那个万箭穿心确实那个女主挺狠的，不过我想可能她自己知道结果，当时的她会选择离婚的，这样对双方都好，我不会这样啦，你别怕我这么多电视剧不是白看的，我知道只有内宅平了才能平天下的道理，每个人负责的职责都不一样，我会好好负责我那一part，你往前冲就好，你没有对不起我，我就不会对不起你的，所以别怕，加油冲哦波比，人家也和你一起呢！</p>]]></content>
      
      
      <categories>
          
          <category> 晨晨的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 晨晨 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>晨晨的新工作</title>
      <link href="/2021/07/08/%E6%99%A8%E6%99%A8%E7%9A%84%E6%96%B0%E5%B7%A5%E4%BD%9C/"/>
      <url>/2021/07/08/%E6%99%A8%E6%99%A8%E7%9A%84%E6%96%B0%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="晨晨的新工作"><a href="#晨晨的新工作" class="headerlink" title="晨晨的新工作"></a>晨晨的新工作</h2><p><img src="../%E6%99%A8%E6%99%A8%E7%9A%84%E6%96%B0%E5%B7%A5%E4%BD%9C/1.jpg"></p><p>在匆匆忙忙中结束了上周的一周，心情感觉很激动但是也透着慌张，因为上周的周五我结束了上一份的工作，怎么说呢上一份的工作对我来说就是一个过渡，当时去的时候心里满怀期待，我应聘的岗位是资料员，结果我不知道是他们的说辞还是什么。莫名其妙我就成了电话员，其实当时心里是气愤的，一直到上岗的那刻都没被告知都只说是资质被停办了，所以我们做不了资料，但是很显然据我这几天的了解我感觉他们最近招人，一个是因为毕业季能招到大量新鲜血液，再一个就是以这个为借口然后先把我们骗过来做这个，等我们适应能适应就适宜适应不了可以走人，反正与他们而言并没啥损失，因为我们不满五天是没有工资的，就相当于打白工嘛，然后我利用这个空子当做了一个过渡期，既然他们先这样那我也没啥好愧疚，大家都各取所需罢了。</p><p>我按照约定提前几天跟领导打了招呼，跟他说了要辞职的事情，本来我一开始心底还有些忐忑但是不知道是由于信号还是什么原因，我压根听不到他说话，他可能也发现了这个问题所以有些话也就没问了就说了一句好，这让我心中不禁松了一口气，说了句再见草草挂断了电话，当时的心情还是很激动的感觉自己解决了一桩麻烦事，早上醒来看到自己已被移除群聊，感觉有种不舒服的感觉随即一想，算了本来就知道是这种结局，与其自己动手不如经由他人之手，还少了桩事。</p><p>今天星期一新的一周又开始了，今天没去上班想着刚来缓冲一下，不过已经跟那边说好了，明天去上班，刚刚晚上跟新同事吃了个饭，还是挺开心又交了个新朋友，这个女生性格还挺开朗的，相处还挺好个子小小的感觉好小只好可爱还有小虎牙呢！刚刚晚上约好明天中午一起去食堂吃饭，估计刚进公司有可能是她主带我，我们组还有一个男生感觉他可能有点内向不太爱说话，所以估计是跟女生交集多一点，现在心情还是有点小紧张的，毕竟明天就要上班了，希望明天一切顺利吧，加油加油。</p><p>上周和胜胜感觉还是有点争执笑死，但是已经以往好多了，我记忆中最深刻的话语是我们下次吵架了就别删了免得麻烦，我当场笑死，因为我们两都知道彼此是重视感情的人，虽然吵架的时候都是键盘侠比谁吵的都凶，甚至一度闹到要分手的局面但没过多久就又和好了，我觉得适当的吵架和争执是正常的，当时暴露的问题当时解决还挺好，有些东西放冷了引起双方冷战了事情就要升级了，最重要我们还是异地见不到面理解不了对方最本真的意思，所以在我看来这种小吵吵也还挺好，我其实挺害怕在一起没吵过的，而且现在我们已经不会闹得很严重了，他也学会了在吵架的时候适当的让着我哄着我一点了，不会像以前刚开始那样一吵架就是直男发言很戳心，我本来就感情脆弱容易引起情绪波动，其实我有时候也挺直的，不能都怪他。我好好工作他好好考研和他一起好好加油吧！</p><p>本周规划：上班时间跟着前辈认真学习，下班时间等锅子到了我就开始学学做饭，晚上做饭给自己中午也可以带饭过去，一方面省钱一方面也能自己锻炼厨艺我总会要有自己能动手的时候，现在还有时间慢慢学，我们两个大吃货每次见面大头的钱都在住宿和吃饭，现在好了解决了蛮大一部分，慢慢学会厨艺给我们家小馋虫做饭吃，再一个就是没事了要开始学习了，我只会可能会考这边的编制之类的，虽然主要以工作为主咯，但是我也不会放弃的学习的，毕竟多一个机会嘛，现在就走一步看一步吧！好好开始我之后的青春年华……</p><p>愿眼有星辰大海 心有繁花似锦 愿流年不负 愿岁月可期，不负自己也不负他。</p><p>—-LC</p>]]></content>
      
      
      <categories>
          
          <category> 晨晨的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 晨晨 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以前的记录</title>
      <link href="/2021/07/04/%E4%BB%A5%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/07/04/%E4%BB%A5%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="假装自己记录了"><a href="#假装自己记录了" class="headerlink" title="假装自己记录了"></a>假装自己记录了</h2><h3 id="记录一"><a href="#记录一" class="headerlink" title="记录一"></a>记录一</h3><p><img src="../%E4%BB%A5%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BD%95/1.JPG"></p><p>宋体小四，这是在word上我认为打字显示很舒服的设置，尤其是要加粗。今天是换了一间自习室进行学习，以至于觉得之前的几天学习效率极低。思考一下，可能是教室有许多面熟之人，加上眼前总有一些小动静。静不下心来，有会考虑到一些其他问题，导致一天的学习时间实际上很少。</p><p>不过换了一个新鲜环境就不必拘泥于其他问题，而且在五楼学习还不用考虑太多问题的烦恼，想在门口呼吸新鲜空气也大可不必在乎其他人的眼光，甚至，有时可以和晨晨能在合适的时候趴在栏杆上聊一些天，讲一讲生活。</p><p>没有想到太多的生活，最近一段时间，或者说是自从大三上的结束后，自己结束了以前的玩闹的心态，开始做正事，也没有算很正经的事，一直以来该做的事情罢了。前几天可能是比较累，加上睡眠不是很足吗？或者是由于水分补充不足？躺在床上休息的时候，半梦半醒的时候，我在想是不是自己在做梦？</p><p>为什么很真实，脑子多想后，世界就变得很复杂，并非物理世界的复杂，是心里世界的复杂。总幻想有时不清楚哪里是虚构，哪里是真实。走在路上也成谜一样。我便想，如果这是一场梦，我也愿意把自己做好，但谁知这是不是一场梦。醒来就是另一件事了。醒来的时候发现自己在睡眠舱已经离开原来所在的星球好远，一切只是可悲的科学实验。</p><p>那我的人生比较不一般，是在梦里的虚拟空间。如此也是仅仅娱乐自己，放松大脑。趁机荒唐时间，看看诗集。勉强做一些事，有时觉得自己做的还算足够，但是回到宿舍洗完澡，头脑放轻松便开始迷糊以下，这时候晨晨便发消息过来，问，波比回宿舍了吗？还是在自习啊？我今日有一些累，想让宝贝去打会游戏，自己也就可以稍微放空心情，看会视频，我不喜欢被事情或者人催着做什么事情，只要我愿意去做，那便不用担心我不会去做。事实有时候觉得自己对晨晨没有足够好，我都觉得自己的不称职。</p><p>但目前情况没办法将事情讲清楚，也有很多麻烦事，只活在理想中是不足够的。爱情令人容光焕发，面包使人享受爱情。我不但渴求爱情，又对面包如此饥渴。在我眼前摆着，我又不愿意去思考，只顾着说要吃饱肚子，晨晨有时便会因此被冷落。</p><p>如果在之前的一段时间认识，我可能会有大不一样的想法和行为，磨砺了我的想法和行为，思考也趋于理性，有感性的那一面的时候也是她在照顾我。</p><p>西安最近天气是怎么样的，问我，可能我也不是很清楚，早上九点左右便不再仰望天空，伏案或者戴上耳机，等到合适时候，出门吃午餐。看天气最近都是阴沉，偶尔有阳光，是昨天吧。出去取快递，买了一箱脱乳糖牛奶，这么甜，本想甚至喝一杯奶茶。后来作罢，有意识的控制自己的糖分，不可让自己太甜，甜腻会让晨宝更加喜欢。</p><p>晚上的时候会思考很多，有些人是最初会很有缘的相遇吧。就像两个朋友有缘的相遇，那也是令人感到很舒服的，只是两个人能不能长久还是要很多的机缘巧合，从小到大来，我交过很多朋友，有一些非常快的离开我的世界，有的甚至会在毕业后再也不会联系。最初还会很惋惜，后来再也不会。</p><p>走在路上，看到有的人三三两两一起去自习，爽朗开心，好像男人在一起或者同性在一起都较为高兴，大家都交谈玩笑。但谈恋爱一些事情发生变化，男人变了，女人变了。</p><p>觉得因为恋爱放弃健康的社交是极其愚蠢的行为，恋人，家人，朋友，自己。大可不必。好久没有写，乱七八糟，不过不在乎，是给晨宝还有自己读的。<br>最近读了好多诗歌。摘抄一条。</p><blockquote><p>卷纸<br>将爱情比作一种卷纸<br>一开始你闻闻它的气味<br>摸一摸它的质地<br>你撕开一个边角沿着纹路扯下一张<br>两张 紧接着是三张四张<br>它被你渐渐匆忙的手扯下<br>你一开始沿着纹路扯下<br>这很有仪式感<br>紧接着不再看 一次次扯下<br>扯下一张两张三张十张<br>不再数数<br>扯下一段是一段<br>用它擦桌子擦鼻子擦坐便器<br>擦你生活的污染部分<br>你感到脏了就用它擦掉<br>纸用尽了 只剩下一只纸筒<br>你拿在手里 轻蔑地捏一下<br>但你还是有太多污染部分来不及处置啊<br>你从垃圾桶 地上 桌上捡起<br>一张两张三张揉成一团的<br>脏了一遍又一遍的纸</p></blockquote><h3 id="记录二"><a href="#记录二" class="headerlink" title="记录二"></a>记录二</h3><p>现在是三月十三日，我已经很久没有出去玩耍。是自己懒惰了吗，可能没有晨晨也会是这样吧。只是不会有现在这样的充实。</p><p>我曾经多少次想我的恋人是什么样子，会不会是那种娇小让我一下子搂在怀里，或者是那种强势有思想主张，和我声声探讨事情的真相，说出自己的看法。我绝对要找到自己的那位眼中是我，心里转满了我，真诚善良的她。又或者是眼前有着无数的愿望，但愿意和我分享，不知道的事情勇敢说出口，自信，勇敢。</p><p>等到我遇见了她，我才认定这么久的等待完全是我的一种人生磨砺，如果没有认识这么多人，我哪会有如此幸运。</p><p>哎，不知道为什么在宿舍里会如此发困。我不愿待在宿舍里了！</p><p>过了一天，我换了个教室进行自习，今天的学习还算很舒服呢，学习了好多。哎，今天发一篇公众号吧！</p>]]></content>
      
      
      <categories>
          
          <category> 胜胜的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胜胜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们吵架了</title>
      <link href="/2021/06/27/%E6%99%A8%E6%99%A8%E7%9A%84%E5%BF%AB%E4%B9%90%E5%8A%A0%E4%B8%80/"/>
      <url>/2021/06/27/%E6%99%A8%E6%99%A8%E7%9A%84%E5%BF%AB%E4%B9%90%E5%8A%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="晨晨的周记二"><a href="#晨晨的周记二" class="headerlink" title="晨晨的周记二"></a>晨晨的周记二</h2><p><img src="../%E6%99%A8%E6%99%A8%E7%9A%84%E5%BF%AB%E4%B9%90%E5%8A%A0%E4%B8%80/1.JPG"></p><p>再过大概4个小时即将结束这一周，这一周感觉跟上周的工作日差不多，但是这周和胜胜发生了口角，吵架原因大概就是我周四的晚上跟着贝姐姐出了一趟门，当时确实时间挺晚的，贝姐姐的弟弟突然发了个消息过来问她去不去玩，当时她在考虑估计有可能会拒绝，因为已经11点多了而且明天还得上班，后来她弟弟突然发了个消息说今天是他生日，当时的我有点怀疑，说怎么会这么巧，后来问了贝姐姐一些信息，说真有可能，他没必要拿这个骗我们，当时确实有点急着走，所以这边回了弟弟一个我去了，可能是由于担心吧，一路上弟弟都在跟我说，但是估计不知道是我们两谁急了，突然就开始吵起来了，然后某个人的话题就在往一个人要照顾好自己这方面引，我就很气，本来都还好的我知道他是因为担心我，所以一路上都在解释也没怎么生气，他这几句话听的我瞬间就来火气了，我有种自我保护意识了，他说我也说，反正你不在乎我了，我也不怕跟你分手了，就一路吵到了餐馆，直到要回去了，都还在吵，因为很气所以我说的有些话可能也挺狠的，害！我本来也不想谁让你老说这种引导话题，最后还说是不是我想分了，我怎么可能想哼，我想的话你怎么可能还在，晚上回来说了晚安就睡了，这是真把我气到了，你说话可狠了，幸好之后和好了，不然我就再也不理你啦，都快气死了，每次都是前几天好甜，一吵架就闹得要分手，直男每次生气吵架都不让让人家。</p><p>周末去找了两天的房子累惨了，虽然每次都下午才出门，回来基本上都将近两万步了，长沙就是个火炉真的好热啊，都是35度晒死我们俩啦，还得到处跑，要么跟着中介、要么自己联系。好想赚钱啊，就能不这么辛苦了，但总体老说还是挺圆满的，虽然房子还是没租好还在考虑当中，顺便吐槽一句长沙已经被新环境垄断了（微笑），你们真棒，总之这周开心，下周继续努力生活吧，要天天开心哦胜胜，永远爱你哦(比）！！！</p><p>–LC</p>]]></content>
      
      
      <categories>
          
          <category> 晨晨的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 晨晨 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>返回导向编程</title>
      <link href="/2021/06/27/%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/06/27/%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>主题目录</strong></p><ul><li>栈溢出</li><li>返回导向编程<ul><li>动机</li><li>前身</li><li>原理</li><li>图灵安全</li></ul></li><li>地址空间随机化防护</li></ul><h2 id="栈的工作原理"><a href="#栈的工作原理" class="headerlink" title="栈的工作原理"></a>栈的工作原理</h2><ol><li>简介</li></ol><p>调用函数将在栈上创建一个结构化空间，称为栈帧。<br>锚点：函数被调用时的栈指针位置，可用于对函数的局部数据寻址/返回到调用者。</p><p><img src="../%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B/1.jpg"></p><ol start="2"><li>栈溢出</li></ol><p><img src="../%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B/2.jpg"><br><img src="../%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B/3.jpg"></p><ol start="3"><li>基于栈溢出的典型代码注入攻击</li></ol><ul><li>通过栈溢出，劫持位于栈帧中的函数返回地址</li><li>直接将被劫持的返回地址指向被溢出的栈区</li><li>溢出过程在被指向的位置上写入shellcode</li></ul><ol start="4"><li>针对代码注入的防护机制</li></ol><p>** 数据执行保护**</p><ul><li>一些别名：W⊕X，NX-bit</li><li>机制：对内存页面增加一个标识bit，使之要么可改写，要么可执行</li></ul><p><strong>经典代码注入的核心思想</strong></p><ul><li>利用逻辑异常，在程序数据中混入代码。</li><li>劫持控制流，使得指令指针从数据段读取指令。</li><li>所需弱点：读取指令时，CPU无法区分目标内存区域的性质（代码？数据？）。</li></ul><p><strong>针对上述特点，DEP的防御思路</strong><br>引入新的硬件安全属性，支持CPU在执行时区分代码和数据区域。<br><strong>缺点</strong></p><ul><li>既然注入Shellcode无法执行，进程和动态库的代码段怎么也要执行吧，具有可执行属性，那攻击者能否利用进程空间现有的代码段进行攻击，答案是肯定的。</li><li>若不试图执行数据区内容，则不能发现/阻止溢出，也无法防范溢出的其他后果。</li></ul><ol start="5"><li>DEP与return-to-libc攻击</li></ol><p><strong>绕过DEP</strong><br>DEP客观存在，注入类攻击如何下手？</p><p>代码重用（code reuse）攻击—-异常数据的注入仍然可以实施。</p><p>既然代码无法直接注入，那么就利用进程空间中已经存在的代码。不管所利用代码原本的用途为何，通过注入的异常数据控制其为攻击者服务，最先出现的此类手段：return-to-libc攻击。</p><p><strong>DEP核心思想</strong></p><p>缓冲区溢出的常用攻击方法是用 shellcode 的地址来覆盖漏洞程序的返回地址，使得漏洞程序去执行存放在栈中 shellcode。</p><p>为了阻止这种类型的攻击，一些操作系统使得系统管理员具有使栈不可执行的能力。这样的话，一旦程序执行存放在栈中的 shellcode 就会崩溃，从而阻止了攻击。</p><p><strong>return-to-libc核心思想</strong></p><p>攻击者采用缓冲区溢出改写返回地址为一个库函数的地址，并且将此库函数执行时的参数也重新写入栈中。</p><p>当函数调用时获取的是攻击者设定好的参数值，此库函数实际上就帮助攻击者执行其恶意行为。</p><p>更复杂的攻击还可以通过 return-into-libc 的调用链（一系列库函数的连续调用）来完成。</p><p><strong>return-to-libc局限性</strong><br>攻击者可用的指令序列只能为应用程序中已存在的函数,所以这种攻击方式的攻击能力有限。</p><p>从函数—-&gt;指令，不再局限于将漏洞程序的控制流跳转到库函数中，而是可以利用程序和库函数中识别并选取的一组指令序列。攻击者将这些指令序列串连起来，形成攻击所需要的 shellcode 来从事后续的攻击行为<br>可行吗？</p><p><strong>绕过DEP新利用点</strong><br><strong>复杂指令集（complex instruction set computing，CISC）</strong><br>指令变长（目的：以最短的代码长度压缩最多的指令内容），CPU串行地读取指令，依据上下文区分操作码/操作数等成分。<br>典型：x86指令构架</p><p><strong>CISC所存在的问题</strong></p><ul><li>代码中一个字节的含义取决于上下文。</li><li>同一数值在单字节/双字节操作码中出现，意义不同。</li><li>同一数值作为指令中的不同元素（如操作码/立即数）时，意义不同。</li><li>原则上，任何一个字节都可能是一条指令的起始。</li></ul><h2 id="返回导向编程"><a href="#返回导向编程" class="headerlink" title="返回导向编程"></a>返回导向编程</h2><p><strong>挑战</strong><br>ROP挑战在于，需要在整个内存代码空间中“搜索”我们需要的gadgets，而后“拼接”。</p><p>代码均是合法的，常规方法难以检测。已有实验室提出包括扫描可利用的代码、将代码结合的constructor，使用一套专用的语言，进而将语言编译成对应代码片段之和的编译器，并给出计算实际代码地址的加载器。</p><h2 id="地址空间随机化防护"><a href="#地址空间随机化防护" class="headerlink" title="地址空间随机化防护"></a>地址空间随机化防护</h2><ol><li>增强软件系统的多样性（安全性）</li></ol><p>通过地址空间随机化増强系统的多样性，同一个程序在不同的机器上，内存布局不一样，在同一台计算机上，两次运行的内存布局也不同。</p><p>Ｒet2libc攻击、ROP攻击利用基于每一个gardget的地址己知并且不会变化的前提。</p><p>地址空间随机化(ASLR）技术通过将程序代码段加载到一个随机的基址，代码段中每一条指令的地址都发生了变化。如果ROP等攻击方法仍然将控制流劫持到原来gardget的地址就会导致攻击失败，ASLR技术在目前主流的操作系统上都有相应的实现。</p><ol start="2"><li>如何将地址空间随机化</li></ol><p>系统将进程的用户空间划分为三个区域，可执行区域（代码区（部分可随机化代码），初始化数据和未初始化数据），映射区（堆，动态库和共享内存）和栈区。</p><p>对于32位系统来说，并不能在整个４Ｇ的地址空间中进行随机化，栈区基址第4-23位可随机化，映射区基址第12-27位可被随机化，可执行区也是12-27位可被随机化。</p><p>32位线性地址，高四位为全局页表，如果应用随机化则会影响到高位内存的映射能力，产生大量内存碎片，低12位考虑页对齐操作。</p><ol start="3"><li>ASLR的局限性</li></ol><p>在32位系统上，ASLR对于代码段只有16位的随机化强度，这样的随机化强度远远不够，平均只需要32768次（最坏情况是2的16次方）尝试即可攻破一个采用ASLR防御技术的系统。</p><p>实验结果，采用暴力尝试的方法用ROP技术攻击部署了ASLR的机器上的Apache Http Server，平均耗费216秒即可攻击成功。</p><p>仅仅对代码段的基地址进行随机化，指令间的相对位置并没有改变，易受到信息泄露攻击的威胁。</p><ol start="4"><li>细粒度ASLR的实施</li></ol><ul><li>程序在加载时自我随机化</li><li>通过虚拟机进行动态随机化</li><li>操作系统的随机化</li></ul><ol start="5"><li>ASLR总结</li></ol><ul><li>ASLR通过给内存布局的偏移做了随机化工作。</li><li>ASLR增加了漏洞利用的难度，不解决漏洞本身。</li><li>64位操作系统中，ASLR能够提供更大的熵（可随机的地址范围更大），因而具有很好的防利用效果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息论期末</title>
      <link href="/2021/06/27/%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/"/>
      <url>/2021/06/27/%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/</url>
      
        <content type="html"><![CDATA[<p>根据老师画的80分的知识点复习。</p><ol><li>熵的概念</li></ol><p>离散集的平均自信息—-熵</p><p>熵是接收的每条消息中包含的信息的平均量，又被称为信息熵、信源熵、平均自信息量。这里，“消息”代表来自分布或数据流中的事件、样本或特征。熵的单位通常为比特，但也用Sh、nat、Hart计量，取决于定义用到对数的底。<br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/1.jpg"><br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/2.jpg"><br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/6.jpg"><br>熵的性质：对称性、非负性、确定性、扩展性。<br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/3.jpg"><br>示例<br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/7.jpg"></p><ol start="2"><li>平均互信息的概念</li></ol><p>互信息量<br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/9.jpg"><br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/8.jpg"><br>定义<br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/4.jpg"><br>性质：非负性、对称性<br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/5.jpg"></p><ol start="3"><li>信息处理不等式</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/10.jpg"><br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/11.jpg"><br>对观测数据的任何处理都会带来信息损失。绝对不会使信息增加。处理的越细致，信息的损失越小。但是处理的代价就越高。</p><p>当消息经过多级处理后，随着处理器数目的增多，输入消息与输出消息之间的平均互信息量趋于变小。</p><ol start="4"><li>信源编码定理</li></ol><p>在信息论中，香农的信源编码定理确立了数据压缩的限度，以及香农熵的操作意义。</p><p>信源编码定理表明不可能把数据压缩得码率比信源的香农熵还小，又不丢失信息。但是有可能使码率任意接近香农熵，且损失的概率极小。</p><p>码符号的信源编码定理把码字的最小可能期望长度看作输入字的熵和目标编码表的大小的一个函数，给出了此函数的上界和下界。</p><ol start="5"><li>信道编码定理</li></ol><p>只要信息传输速率小于信道容量，就存在一类编码，使信息传输的错误概率可以任意小。 </p><p>设R是信息传输的速率，C是离散无记忆信道的信道容量，ε&gt;0是任意小的数，则只要R&lt;C就总存在码字长为N，码字数为M=2NR的分组码使译码的平均差错概率Pe&lt;ε。</p><ol start="6"><li>信息量的计算</li></ol><ol start="7"><li>霍夫曼编码的计算</li></ol><ol start="8"><li>准对称信道容量的计算</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/12.jpg"><br><img src="../%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%9C%9F%E6%9C%AB/13.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全模糊测试</title>
      <link href="/2021/06/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/06/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><strong>主体目录</strong></p><ul><li>模糊测试介绍<ul><li>模糊测试概述</li><li>简单示例</li><li>模糊测试步骤</li></ul></li><li>模糊测试案例<ul><li>常见的模糊测试</li><li>XSS 模糊测试</li></ul></li></ul><h2 id="模糊测试介绍"><a href="#模糊测试介绍" class="headerlink" title="模糊测试介绍"></a>模糊测试介绍</h2><h3 id="模糊测试概述"><a href="#模糊测试概述" class="headerlink" title="模糊测试概述"></a>模糊测试概述</h3><ol><li>定义</li></ol><p>模糊测试（Fuzz testing/fuzzing）是一种发现安全漏洞的有效的测试方法，在安全性测试中越来越受到重视，模糊测试将随机的坏数据插入程序，观察程序是否能容忍杂乱输入。<br>模糊测试是不合逻辑的，只是产生杂乱数据攻击程序，采用模糊测试攻击应用程序可发现其他采用逻辑思维来测试很难发现的安全漏洞。<br>2. 模糊测试的本质<br><strong>跳出程序员制定的规则圈圈</strong><br>Fuzz技术的思想就是利用“暴力”来实现对目标程序的自动化测试，然后监视检查其最后的结果，如果符合某种情况就认为程序可能存在某种漏洞或者问题。<br>暴力指利用不断地向目标程序发送或者传递不同格式的数据来测试目标程序的反应。</p><blockquote><p>我们可以把模糊测试理解成为一种能自动进行”rough attack”尝试的工具。之所以说它是”rough attack”,是因为Fuzz往往可以触发一个缓冲区溢出的漏洞，但却不能实现有效的exploit。测试人员需要实时地捕捉目标程序抛出的异常、发生的崩溃和寄存器等信息，综合判断这些错误是不是真正的可利用漏洞。</p></blockquote><ol start="3"><li>模糊测试特点</li></ol><ul><li>测试的用例通常具备某种攻击性的畸形数据，用以触发各种类型的漏洞。</li><li>具备较好的自动化测试能力。</li><li>“暴力（蛮力）”攻击方法。</li><li>很少出现误报。</li><li>能够快速找到真正的漏洞，操作简单。</li><li>通常不是进行功能性测试，而是检查系统处理错误的能力，比如：“入侵”、 “破坏” 、 “崩溃”。</li><li>不能保证系统中已经没有漏洞，即使我们用Fuzz找到了100个严重的漏洞，系统中仍然可能存在第101个漏洞。</li></ul><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><ol><li>模糊测试方式</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/1.jpg"></p><h3 id="模糊测试步骤"><a href="#模糊测试步骤" class="headerlink" title="模糊测试步骤"></a>模糊测试步骤</h3><ol><li>模糊测试常规步骤</li></ol><p><strong>典型模糊测试过程</strong></p><ul><li>识别测试目标</li><li>识别用户输入</li><li>生成Fuzz测试数据</li><li>执行Fuzz测试数据</li><li>监视异常</li><li>确定可利用性</li></ul><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/2.jpg"></p><ol start="2"><li>模糊测试的主要方法</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/3.jpg"></p><ol start="3"><li>模糊测试类型</li></ol><p><strong>本地模糊测试器</strong></p><ul><li>命令行模糊测试器</li><li>环境变量模糊测试器</li><li>文件格式模糊测试器</li></ul><p><strong>远程模糊测试器</strong></p><ul><li>网络协议模糊测试器（简单协议、复杂协议）</li><li>Web应用模糊测试器</li></ul><p><strong>内存模糊测试器</strong><br><strong>模糊测试框架</strong></p><h2 id="模糊测试案例"><a href="#模糊测试案例" class="headerlink" title="模糊测试案例"></a>模糊测试案例</h2><h3 id="常见模糊测试"><a href="#常见模糊测试" class="headerlink" title="常见模糊测试"></a>常见模糊测试</h3><p><strong>典型模糊测试</strong></p><ul><li>文件Fuzz测试</li><li>协议Fuzz测试</li><li>组件Fuzz测试</li><li>Web Fuzz测试</li></ul><ol><li>文件Fuzz测试</li></ol><p><strong>盲模糊测试</strong><br><strong>操作</strong><br>在随机位置插入随机的数据以生成畸形文件。<br><strong>事实</strong><br>现代软件往往使用非常复杂的私有数据结构，数据结构越复杂，解析程序的逻辑就越复杂，越容易出错。<br><strong>结果</strong><br>产生测试用例的策略缺少针对性、大量测试用例无效、难以发现复杂解析器深层逻辑的漏洞。</p><p><strong>智能模糊测试</strong><br><strong>复杂数据结构特征</strong></p><ul><li>拥有一批预定义的静态数据</li><li>数据结构的内容是可以动态改变的</li><li>数据结构之间是嵌套的</li><li>数据中存在多种数据关系(size of,point to,reference of,CRC)</li><li>有意义的数据被编码或压缩，甚至用另一种文件格式来存储，这些格式的文件被挖掘出来越来越多的漏洞。</li></ul><p><strong>Smart Fuzz应运而生</strong></p><ul><li>面向逻辑(Logic Oriented Fuzzing)</li></ul><p><strong>测试目标是解析文件的程序逻辑，而不是文件本身。</strong><br>明确测试用例正在试探的是哪一层的解析逻辑，即明确测试“深度”以及畸形数据的测试“粒度”。<br>生成畸形数据时可以具有针对性的仅仅改动样本文件的特定位置，尽量不破坏其他数据依赖关系，这样使得改动的数据能够传递到测试的解析深，而不会在上层的解析器中被破坏。</p><ul><li>面向数据类型(Data Type Oriented Fuzzing)</li></ul><p><strong>面向数据类型：测试中可以生成的数据。</strong><br>算术型：包括以HEX、ASCII、Unicode、Raw格式存在的各种数值。<br>指针型：包括Null指针、合法/非法的内存指针等。<br>字符串型：包括超长字符串、缺少终止符(0x00)的字符串等。<br>特殊字符：包括#，@，’，&lt;,&gt;,/,,../等等。<br>面向数据类型测试是指能够识别不同的数据类型，并且能够针对目标数据的类型按照不同规则来生成畸形数据。<br>跟Blind Fuzz相比，这种方法产生的畸形数据通常都是有效的，能够大大减少无效的畸形文件。</p><ul><li>基于样本(Sample Based Fuzzing)</li></ul><p><strong>测试前首先构造一个合法的样本文件（模版文件），这时样本文件里所有数据结构和逻辑必然都是合法的。</strong><br>以这个文件为模板，每次只改动一小部分数据和逻辑来生成畸形文件，这种方法也叫做“变异”(Mutation)。<br>对于复杂文件来说，以现成的样本文件为基础进行畸形数据变异来生成畸形文件的方法要比上面两种的难度要小很多，也更容易实现。<br>漏报：不能测试样本文件里没有包含的数据结构。<br>为了提高测试质量，就要求在测试前构造一个能够包含几乎所有数据结构的文件（比如文字、图像、视频、声音、版权信息等数据）来作为样本。<br>2. 协议模糊测试<br><strong>协议：网络通信（双方或多方）的约定，网络系统的核心灵魂。</strong></p><blockquote><p>多数网络协议细节未公开</p></blockquote><p>多种类型的漏洞出现，如拒绝服务、缓冲区溢出、格式化字符串<br>协议解析的软件通常较复杂，需要反复进行数据的读取和处理。<br><strong>协议逆向工程</strong></p><ul><li>Network Trace，利用网络流量来推测网络协议。</li><li>Tainted Data，对实现网络协议的服务器程序进行二进制的动态跟踪分析，通过跟踪二进制文件对报文的处理流程对报文进行解析。以动态污点分析技术为基础。</li></ul><p><strong>FTP协议模糊测试</strong></p><ul><li>File Transfer Protocol，基于TCP，其工作模式采用客户端/服务器的模式，也就是C/S模式。</li><li>客户连接FTP服务过程：建立连接、传送数据和释放连接。</li><li>基本原理就是通过对FTP协议中的命令及命令参数进行脏数据替换，构造畸形的FTP命令并发送给被测试FTP服务程序。</li></ul><ol start="3"><li>组件模糊测试</li></ol><ul><li>组件提取</li><li>组件接口分析</li><li>构造测试用例</li><li>测试驱动、异常跟踪</li><li>结果分析</li></ul><ol start="4"><li>Web模糊测试</li></ol><p><strong>特殊形式的网络协议模糊测试，测试方法如下</strong></p><ul><li>设置目标环境</li><li>输入</li><li>GET、POST、HEAD 、PUT 、DELETE 、TRACE 、CONNECT 、 OPTIONS</li><li>请求URL</li><li>异常检测</li></ul><p><strong>主要的Web漏洞</strong></p><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/4.jpg"></p><p><strong>Web模糊测试异常检测</strong><br>HTTP 状态码、Web服务器错误消息、中断连接、日志文件、时间日志、调试器。</p><h3 id="XSS模糊测试"><a href="#XSS模糊测试" class="headerlink" title="XSS模糊测试"></a>XSS模糊测试</h3><p>对于XSS的漏洞挖掘过程，其实就是一个使用Payload不断测试和调整再测试的过程，这个过程我们把它叫做Fuzzing。</p><p>同样是Fuzzing，有些人挖洞比较高效，有些人却不那么容易挖出漏洞，除了掌握的技术之外，比如编码的绕过处理等，还包含一些技巧性的东西，掌握一些技巧和规律，可以使得挖洞会更加从容。</p><p>Fuzzing（模糊测试）是挖掘漏洞最常用的手段之一，不止是XSS，应该可以说Fuzzing可以用于大部分类型的漏洞挖掘。通俗可以把这种方式理解为不断尝试的过程。</p><ol><li>XSS模糊测试关键</li></ol><ul><li>检测输入点<br>寻找数据入口，比如说GET/POST数据，或者Header头部里的UA/Referer/Cookie，再或者URL路径等等，这些都可以成为输入入口<br>转换为比较形象点的说法，比如看到一个搜索框，你可能会在搜索框里提交关键词进行搜索，那么这里可能就发生了一个GET或者POST请求，这里其实就是一个输入点。</li><li>潜在注入点检测：判断输入点是否可以成功把数据注入到页面内容。</li></ul><p>对于提交数据内容但是不输出到页面的输入点是没有必要进行Fuzzing的，因为即使可以提交攻击代码，也不会产生XSS。</p><p>在潜在注入点的检测通常使用的是一个随机字符串，比如随机6位数字，再判断这6位数字是否返回输出在页面，以此来进行判断。</p><p>为什么不直接使用Payload进行判断呢？因为Payload里包含了攻击代码，通常很多应用都有防火墙或者过滤机制，Payload中的关键词会被拦截导致提交失败或者不会返回输出在页面，但这种情况不代表不能XSS，因为有可能只是Payload不够好，没有绕过过滤或者其他安全机制，所以采用无害的随机数字字符就可以避免这种情况产生。</p><p>先验证可注入，再调整Payload去绕过过滤；而随机的目的在于不希望固定字符成为XSS防御黑名单里的关键词。</p><ul><li>生成Payload和进行攻击验证：Payload的好坏决定了攻击是否可以成功。</li></ul><p>而对于不同情况的注入点，需要使用的Payload也是不同的，比如，注入的位置在标签属性中还是标签事件中，使用的Payload是不同的，<br>标签属性中：如<code>&lt;a href=&quot;注入位置&quot;&gt;test&lt;/a&gt;，Payload：&quot;&gt;&lt;/a&gt;&lt;script&gt;alert(0)&lt;/script&gt;&lt;a  href=&quot;</code><br>标签事件中：<code>&lt;img href=&quot;a.jpg&quot; onload=&quot;注入位置&quot;&gt;, Payload：alert(0)</code></p><blockquote><p>Payload的生成就是一个不断Fuzzing和不断调整的过程，根据注入位置上下文代码的结构、内容以及应用过滤机制等不断调整和不断提交测试的过程。</p></blockquote><ol start="2"><li>XSS模糊测试一些技巧</li></ol><p>类似QQ、微信这种一号多用的情况，可以想象你的微信昵称、QQ昵称或者签名等，在不同的应用、网页中登录，你的昵称就会在不同的地方显示，这些昵称在微信、QQ本身不会导致问题的产生，但到了其他页面呢？也许就会导致问题的产生。</p><p>登录和注册是大部分网站的必备功能，当你在未登录状态下访问一些需要需要登录态的页面，比如个人中心，会自动跳转到登录或者注册页面要求你登录，然后这个时候的登录URL其实会带有一个跳转URL，这是为了方便你登录后直接跳转到你原来访问的页面，是一个比较好的用户体验的设计。由于功能设计上的缺陷，没有对跳转的URL进行判断或者判断有问题，于是可以导致直接跳转到其他网站或者产生XSS。当然，不止是登录，注册功能也存在同样问题</p><p>盲打：常规的XSS攻击是通过页面返回内容中JS攻击代码的生效与否来判断XSS的攻击是否成功；而对于一些网页功能，比如反馈，我们可以发现，不管你提交什么内容，返回的内容都是”感谢您的反馈”类似的语句，并不会根据你提交的内容而在页面中显示不同的内容，对于这样的内容提交点，就无法通过页面反馈判断攻击代码是否注入成功，那么就可以通过XSS盲打。</p><p>XSS盲打一般通过XSS盲打平台，在XSS盲打平台建立项目，会生成项目攻击链接，实际上就是一个类似JS文件的访问链接，这个JS文件中其中至少包含一个功能，那就是向盲打平台发送GET/POST请求传输数据回来，比如Cookie，这样的话，类似在反馈页面提交的攻击代码一旦生效，就等于JS代码被执行，那么就会向盲打平台返回数据，那就说明攻击成功了；假如一直没有返回数据，那就说明提交的攻击代码没有执行或者执行出问题，也就证明攻击失败。</p><p>类似于这样的功能，如果存在XSS，一般会在什么地方什么时候出发攻击代码呢？管理人员在后台审核这些内容的时候，所以说一般XSS盲打如果成功，往往可以获得对应功能管理后台的地址以及管理员的Cookie，假如管理后台没有做访问的限制，就能用对应管理员的Cookie登录上去</p><p>不管是来自哪里的内容，都应该有自己的过滤机制，而不能完全的信任其实总结一句话就是：任何的输入都是有害的。</p>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息与内容安全</title>
      <link href="/2021/06/25/%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/"/>
      <url>/2021/06/25/%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="信息与内容安全概述"><a href="#信息与内容安全概述" class="headerlink" title="信息与内容安全概述"></a>信息与内容安全概述</h2><ol><li>网络安全的定义</li></ol><p>网络安全是融合<strong>物理域、信息域、认知域和社会域</strong>，以及互联互通的技术基础设施网络为平台，通过无线电、有线电信道传递信号信息，控制实体行为的信息活动空间。<br>2. 信息内容安全的定义</p><ul><li>信息内容安全是信息安全在<strong>法律、政治、道德层次</strong>上的要求，是语义层次的安全。我们要求信息内容是安全的，就是要求信息内容在政治上是健康的， 在法律上是符合国家法律法规的，在道德上是符合中华民族优良的道德规范的。</li><li>广义的信息内容安全既包括信息内容在政治、法律和道德方面的要求，也包括<strong>数据的获取，信息内容的分析与识别，数字图像视频内容安全，多媒体信息隐藏，隐私保护</strong>等诸多方面。</li></ul><ol start="3"><li>人工智能发展进阶</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/1.jpg"></p><ol start="4"><li>人工智能、机器学习和深度学习之间的关系</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/2.jpg"><br>5. 深度学习的3个步骤</p><ul><li>神经网络</li><li>多种方式模拟</li><li>挑选最优方式</li></ul><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/3.jpg"></p><h2 id="网络信息内容的获取与表示"><a href="#网络信息内容的获取与表示" class="headerlink" title="网络信息内容的获取与表示"></a>网络信息内容的获取与表示</h2><ol><li>三原色原理</li></ol><p>光学三原色：红蓝绿。</p><ol start="2"><li>信息内容表示—-视觉信息</li></ol><p>彩色图像—-&gt;灰度图像<br>Y=(R+G+B)/3<br>3. 视频</p><p>视频就是其内容随时间变化的一组动态图像，所以又叫运动图像或活动图像。</p><ol start="4"><li>计算机看的原理：视觉余像</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/4.jpg"><br>5. 视觉特征表达</p><ul><li>颜色特征</li><li>纹理特征</li><li>局部二值特征</li><li>梯度直方图特征</li><li>局部特征</li></ul><ol start="6"><li>文本特征表达</li></ol><p><strong>1-of-N Encoding(One-hot Encoding)</strong><br><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/5.jpg"><br><strong>怎么将文本表达成变量</strong></p><ul><li>词频</li><li>文档频数</li><li>词频-逆文档频数(TF-IDF)</li></ul><p>词频(TF)=某个词在文章中的出现次数/文章的总词数<br>逆文档频率(IDF)=log(语料库的文档总数/(包含该词的文档数+1))<br>TF-IDF = TF * IDF<br>7. 音频特征表达<br><strong>MFCC</strong><br><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/6.jpg"></p><h2 id="深度学习基础（重要）"><a href="#深度学习基础（重要）" class="headerlink" title="深度学习基础（重要）"></a>深度学习基础（重要）</h2><ol><li>反向传播</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/20.jpg"></p><ol start="2"><li>卷积神经网络</li></ol><p><strong>卷积的计算：矩阵对应位置先乘再加。</strong><br><strong>池化：最大池化，最小池化，平均池化。</strong><br><strong>全连接前馈网络</strong><br><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/19.jpg"><br>3. 理解神经网络<br><strong>神经网络可视化</strong><br>GoogLeNet<br>4. 经典神经网络结构<br><strong>LeNet-5</strong><br><strong>AlexNet</strong><br><strong>VGGNet</strong><br><strong>ResNet</strong></p><h2 id="生成对抗网络"><a href="#生成对抗网络" class="headerlink" title="生成对抗网络"></a>生成对抗网络</h2><ol><li>GAN的种类</li></ol><ul><li>GAN</li><li>ACGAN</li><li>BGAN</li><li>CGAN</li><li>DCGAN</li></ul><ol start="2"><li>GAN的基本思想</li></ol><p>向量—-&gt;生成器—-&gt;图像（高维度向量）<br>图像—-&gt;判别器—-&gt;范围（较大的值代表是真，较小的值代表是假）<br>3. 算法</p><ul><li>初始化生成器和判别器</li><li>每轮迭代<ul><li>固定生成器，更新判别器</li><li>固定判别器，更新生成器（生成器试图愚弄判别器）</li></ul></li></ul><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/7.jpg"><br>4. 生成对抗网络原理</p><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/8.jpg"></p><h2 id="在线社交网络分析"><a href="#在线社交网络分析" class="headerlink" title="在线社交网络分析"></a>在线社交网络分析</h2><ol><li>在线社交网络定义</li></ol><p>在线社交网络是一种在信息网络上由社会个体集合及个体之间的连接关系构成的社会性结构，包含<strong>关系结构、网络群体和网络信息</strong>三个要素。<br>2. 在线社交网络的三个维度</p><ul><li>结构</li><li>群体</li><li>信息</li></ul><ol start="3"><li>在线社交网络分析定义</li></ol><p>在线社交网络分析是指从<strong>网络结构、群体互动、信息传播</strong>三个维度，基于信息学、数学、社会学、管理学、心理学等多学科的 融合理论和方法。为理解人类各种社交关系的形成、行为特点分析以及信息传播的规律提供一种可计算的分析方法。</p><ol start="4"><li>社交网络群体行为</li></ol><p><strong>群体极化产生的条件可概括为4点</strong></p><ul><li>必须有激发事件出现</li><li>群体内的个人能看到前人的选择</li><li>群体信息缺乏</li><li>群体有一定同质性</li></ul><ol start="5"><li>在线社交网络信息传播规律</li></ol><ul><li>影响力模型</li><li>传染模型</li></ul><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/9.jpg"></p><h2 id="信息过滤"><a href="#信息过滤" class="headerlink" title="信息过滤"></a>信息过滤</h2><ol><li>信息过滤模型</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/10.jpg"><br>2. 信息过滤VS信息检索</p><ul><li>信息过滤可以看成广义信息检索的一部分。</li><li>信息过滤过滤出不相关的数据，而信息检索选择相关的数据项查询。</li><li>信息检索可以认为面向一次性的查询而使用，而信息过滤是面向用户的长期需求的重复使用。</li><li>信息过滤中信息源动态，用户需求 (采用User Profile来表示)相对静态；信息检索信息源相对静态，用户需求(采用Query来表示)动态变化</li><li>信息过滤用户要对系统有所了解，信息检索不需要。</li><li>信息过滤一般要关注用户建模，涉及用户隐私问题，信息检索不涉及。</li></ul><ol start="3"><li>信息过滤VS信息分类</li></ol><ul><li>信息过滤可以采用信息分类中的分类算法。</li><li>信息分类中的分类通常不会变化。相对而言，信息过滤的用户偏好会动态调整。</li></ul><ol start="4"><li>信息过滤VS信息提取</li></ol><ul><li>信息提取是从无格式数据源中抽取相关字段的过程。比如抽取恐怖事件的时间、地点、人物等字段。</li><li>信息过滤中要关注相关性，信息提取不太关注相关性，而只关注相关的字段。</li></ul><ol start="5"><li>信息过滤分类体系</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/11.jpg"><br>基于感知的过滤，也称为基于内容的过滤。<br>基于社会的过滤，也称为基于协同的过滤。<br>6. AC自动机</p><ul><li>基本思想</li></ul><p>在预处理阶段，AC自动机算法建立了三个函数，<strong>转向函数goto，失效函数failure和输出函数output</strong>，由此构造了一个树型有限自动机。在搜索查找阶段，则通过这三个函数的交叉使用扫描文本，定位出关键字在文本中的所有出现位置。</p><ul><li>特点</li></ul><p>扫描文本时完全不需要回溯，时间复杂度为O(n)，与关键字的数目和长度无关。</p><ul><li>树型有限自动机</li></ul><p>树型有限自动机包含一组状态，每个状态用一个数字代表。状态机读入文本串y中的字符，然后通过产生状态转移或者偶尔发送输出的方式来处理文本。<br>树型有限自动机的行为通过三个函数来指示：<strong>转向函数g，失效函数f和输出函数output。</strong></p><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/12.jpg"></p><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/18.jpg"></p><h2 id="网络舆情分析"><a href="#网络舆情分析" class="headerlink" title="网络舆情分析"></a>网络舆情分析</h2><ol><li>网络舆情概念</li></ol><p>网络舆情：是指以互联网为载体所表达的公众情绪，究其本质是社会情绪在互联网这个可见载体上的公共表达。<br>2. 网络舆情的特征</p><ul><li>自发性</li><li>指向性</li><li>时效性</li><li>情绪性</li><li>片面性</li></ul><ol start="3"><li>网络舆情的演化</li></ol><ul><li>形成期</li><li>高涨期</li><li>波动期</li><li>消退期</li></ul><h2 id="对抗攻击与防御"><a href="#对抗攻击与防御" class="headerlink" title="对抗攻击与防御"></a>对抗攻击与防御</h2><ol><li>攻击想做什么</li></ol><p><strong>愚弄分类器，使得分类器不能正常识别并且分类。</strong><br>2. 攻击的损失函数<br><strong>训练—-&gt;无目标攻击—-&gt;目标攻击</strong><br>约束：不能被发现。<br><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/21.jpg"><br>3. 如何攻击<br><strong>梯度下降</strong><br><strong>攻击方法：FGSM（快速梯度符号法）</strong><br>4. 白盒和黑盒</p><p>在前面的攻击中，我们固定网络参数𝜃而寻找最优的输入𝑥。</p><ul><li>为了攻击，我们需要知道网络参数𝜃。这样的攻击叫白盒攻击(White Box Attack)。</li><li>如果我们不将模型公布是不是就安全?绝大多数API不能提供网络参数的。不行，因为黑盒攻击(Black Box Attack)是可能的。</li><li>如果你有目标网络的训练数据，训练一个代理网络(proxy network)，否则，从目标网络获取输入输出对。</li></ul><ol start="5"><li>One Pixel Attack（一像素攻击）VS一般的攻击</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/22.jpg"><br>6. 2种类型的防御</p><ul><li>被动防御(Passive defense)：在不修改模型的情况下找到攻击图像。</li><li>主动防御(Proactive defense): 训练一个对对抗攻击具有鲁棒性的模型。</li></ul><ol start="7"><li>总结</li></ol><p><strong>攻击: 在给定网络参数的情况下，攻击非常容易。</strong></p><ul><li>即使是黑盒攻击也是可能的</li><li>防御：主动防御和被动防御</li><li>未来：自适应攻击和防御</li></ul><h2 id="视觉内容伪造与检测"><a href="#视觉内容伪造与检测" class="headerlink" title="视觉内容伪造与检测"></a>视觉内容伪造与检测</h2><ol><li>Deepfake事件</li></ol><p>图像内容伪造<br>2. 内容伪造方法</p><ul><li>虚假人脸生成</li><li>人脸替换<ul><li>原始Deepfake方法</li><li>基于GAN的Deepfake方法</li></ul></li><li>人脸编辑<ul><li>属性编辑</li><li>表情重演</li><li>跨模态</li></ul></li></ul><ol start="3"><li>检测伪造方法</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/13.jpg"><br><strong>挑战</strong></p><ul><li>单个工具对付各种攻击的效率将越来越低</li><li>深度学习的方法可解释性</li></ul><h2 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h2><ol><li>什么是异常检测</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/15.jpg"><br>给定一组训练数据，我们想找到一个检测输入x与训练数据是否相似的方程。<br>2. 异常检测是二分类分类器<br>3. 如何使用分类器</p><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/16.jpg"></p><ol start="4"><li>检测框架示例</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/17.jpg"></p><ol start="5"><li>评价准则</li></ol><ul><li>准确率</li></ul><p>准确率不是一个好的评价准则，因为一个系统可以有很高的准确率，但是并不影响检测错误。</p><ol start="6"><li>自编码器</li></ol><p><img src="../%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/14.jpg"><br>训练和测试的时候都经过编码、译码的过程，发现测试图片有较大的重组损失的，将其认定为虚假照片。<br>7. 基于生成对抗网络（GAN-Based）</p><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>已经考完试了，感觉出的题还好吧。只是并不像划重点那么多，大概总结一些供学弟学妹们备考。选择题填空题正常，注意填空题会出多一些对抗网络内容，GAN的公式，还有BP神经网络的概念，信息过滤什么的没有出。可能是第一年，之后也可能会出的，计算题常规，一道计算卷积，一道AC自动机，简答题讲了一些基本的概念，最后一道大题说的第二个实验内容，要求设计一种模型来检测Deepfake虚假人脸，是对实验的理解。总体难度还是有的，看平时对于这部分的理解。只靠期末考试的复习是不足够的，希望学弟学妹们好好学习！不过还是可以达到中等分数，考研的同学可以依据自己的目标进行选择做法。</p>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息与内容安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全基础</title>
      <link href="/2021/06/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/06/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ol><li>计算机安全概念<br>计算机安全核心地位的3个关键目标：机密性、完整性、可用性。<br>还有2个：真实性、可计量性。</li><li>OSI安全框架</li></ol><ul><li>安全攻击<ul><li>主动攻击<br>包含数据流的改写和错误数据流的添加。<br>划分4类：假冒、重放、改写消息、拒绝服务。</li><li>被动攻击<br>包含2种主要形式：消息内容泄露和流量攻击。<br>对抗被动攻击的重点是防范而不是检测。</li></ul></li><li>安全服务<ul><li>认证<ul><li>对等实体认证</li><li>数据源认证</li></ul></li><li>访问控制</li><li>数据机密性</li><li>数据完整性</li><li>不可抵赖性<ul><li>源</li><li>目的地</li></ul></li></ul></li><li>安全机制</li></ul><p>安全服务实现了安全策略， 而安全机制实现了安全服务。<br>3. 网络安全模型<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/1.jpg"><br>4. 网络访问安全模型<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/2.jpg"><br><strong>解决有害访问的安全机制</strong></p><ul><li>看门人功能</li><li>屏蔽逻辑</li></ul><h2 id="对称加密和消息机密性"><a href="#对称加密和消息机密性" class="headerlink" title="对称加密和消息机密性"></a>对称加密和消息机密性</h2><ol><li>密码体制<br>密码体制：对称密码体制、公钥密码体制。<br>流密码是属于对称密码体制范畴。</li></ol><p><strong>对称加密方案组成</strong></p><ul><li>明文</li><li>加密算法</li><li>密钥</li><li>密文</li><li>解密算法</li></ul><ol start="2"><li>密码分析</li></ol><ul><li>唯密文（最难破解）</li><li>已知明文</li><li>选择明文</li><li>选择密文</li><li>选择文本（最容易破解）</li></ul><p>加密的两个基本模块是：代替和置换。<br>为了抵抗统计分析破译法，香农给出了设计分组密码体制的两个一般原则: 扩散与混淆。<br>3. Feistel密码结构<br>分组越大表示越高的安全性。<br><strong>DES</strong></p><ul><li>DES属于Feistel结构，明文长度64比特，密钥长度56比特。其中最重要的部分为非线性替换S盒。</li></ul><p><strong>三重DES</strong><br>使用了3次DES算法，过程按照加密-解密-加密的顺序。<br><strong>加密</strong><br>C=E(K3,D(K2,E(K1,P)))<br><strong>解密</strong><br>P=D(K1,E(K2,D(K3,C)))<br>知道过程是反过来的就行。<br>4. AES<br>明文长度是128比特，密钥长度可以是128、192、256比特。<br><strong>每1轮4个不同的步骤</strong></p><ul><li>字节替换（使用S盒，分组逐一替换）</li><li>行移位</li><li>列混淆</li><li>轮密钥加</li></ul><ol start="5"><li>随机数与伪随机数<br>随机数</li></ol><ul><li>随机性、不可预测性。</li></ul><p><strong>伪随机数生成方法</strong></p><ul><li>真随机数发生器</li><li>伪随机数生成器</li><li>伪随机函数</li></ul><p>常用密码算法创造伪随机函数</p><ul><li>对称的分组密码</li><li>不对称的密码</li><li>散列函数和消息认证码</li></ul><ol start="6"><li>流密码和RC4</li></ol><p><strong>设计流密码考虑因素</strong></p><ul><li>加密序列有长周期</li><li>密钥流尽可能接近真随机数的性质</li><li>伪随机数生成器的输出受输入密钥值控制</li></ul><p><strong>RC4算法</strong><br>用1–256个字节(8-2048位)的可变长度密钥初始化一个256个字节的状态向量S，S的元素记为[1],S[2],…,S[255]，从始至终置换后的S包含从0到255的所有8位数。对于加密和解密，字节k是从S的255个元素中按一种系统化的方式选出的一个元素生成的。每生成一个k的值，S中的元素个体就被重新置换一次。<br>7. 分组密码工作模式<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/3.jpg"><br>问：若各中工作模式传输出现错误（错误1个比特），则会影响整体多长？<br>问：5种分组密码的工作模式中，哪几种适合用于流密码中？</p><h2 id="公钥密码和消息认证"><a href="#公钥密码和消息认证" class="headerlink" title="公钥密码和消息认证"></a>公钥密码和消息认证</h2><ol><li>MAC的定义</li></ol><p>一种认证技术利用私钥产生一小块数据，称之为消息认证码。保证了数据的完整性和真实性。还可能保证时效性。<br>很多算法都可以生成MAC，比如DES。<br>MAC的一种替代方法是使用单向散列函数，可接受变长的消息M作为输入，生成定长的消息摘要H（M）作为输出。消息摘要随消息一起以可信的形式传送。<br>2. 安全散列函数<br><strong>要求</strong></p><ul><li>输入长度可变</li><li>输出长度固定</li><li>效率高</li><li>抗原像攻击（单向性）</li><li>抗第二原像攻击（抗弱碰撞性）</li><li>抗碰撞攻击（抗强碰撞性）</li><li>伪随机性</li></ul><ol start="3"><li>SHA安全散列函数</li></ol><p>SHA-1产生160位的Hash值。SHA-2包括SHA-224、SHA-256、SHA-384、SHA-512。SHA基于散列函数MD4。<br>SHA-512的输入消息以1024位的分组为单位进行处理。<br>4. 消息认证码</p><ul><li>HMAC（基于嵌入式散列函数，如SHA-1）</li><li>CMAC（基于分组密码算法）</li></ul><ol start="5"><li>公钥密码原理</li></ol><p><strong>公钥密码方案组成部分</strong></p><ul><li>明文</li><li>密文</li><li>加密算法</li><li>解密算法</li><li>公钥和私钥</li></ul><ol start="6"><li>公钥密码系统的应用</li></ol><ul><li>加密/解密（加解密消息）</li><li>数字签名（用私钥签名，公钥验证签名）</li><li>密钥交换（例如会话密钥）</li></ul><ol start="7"><li>公钥密码RSA和DH</li></ol><p><strong>RSA</strong><br>RSA 的安全基础是大整数分解的困难性，公钥密码体制的安全基础是单向陷门函数。</p><ul><li>密钥生成阶段</li></ul><p>n=p*q（p，q是两个互素的大数）<br>不需要使用到n，需要用到n的欧拉函数t，自己设定的与欧拉函数t互素的数d作为公钥，生成的与此设定的数d互逆的数e为私钥。<br>公钥为（d，n）<br>私钥为（e，n）<br>将p和q销毁</p><ul><li>消息加密和解密阶段</li></ul><p>消息M<br>加密后得到C=M^d(mod n)<br>解密后得到M=C^e(mod n)</p><ul><li>手动计算难点</li></ul><p>大数的模幂运算、求模逆运算。<br><strong>DH</strong><br>存在中间人攻击。第三者分别与两方进行密钥共享，注意这个密钥共享共享的密钥是对称钥。即计算出来的密钥是同一个密钥。之后两方加密和解密都用这个密钥。</p><ul><li>前提</li></ul><p>双方共享一个素数q和a，a &lt; q，q是一个本原根。（a是q的本原根）</p><ul><li>过程</li></ul><p>利用了求离散对数难的原理，素数a作为底，双方用私钥利用模（q）指数生成公钥，传输公钥。<br>双方再用公钥作为底，指数为各自的私钥，计算得到的是双方协商出来的对称钥。</p><ul><li>中间人攻击</li></ul><p>中间人攻击相当于两步DH过程，与A协商一个密钥m，与B协商一个密钥n。同时与A、B交流，达到攻击的效果。<br>8. 数字签名标准DSS</p><h2 id="密钥分配和用户认证"><a href="#密钥分配和用户认证" class="headerlink" title="密钥分配和用户认证"></a>密钥分配和用户认证</h2><ol><li>密钥类型</li></ol><p><strong>基本密钥 Base Key</strong><br>又称初始密钥、用户密钥，是由用户选定或由系统分配给用户，在较长时间（相对于会话密钥）内由一对用户所专用的密钥。<br><strong>会话密钥 Session Key</strong><br>两个通信终端用户在一次通话或交换数据时使用的密钥。<br><strong>密钥加密密钥 Key Encrypting Key</strong><br>用于对会话密钥或文件密钥进行加密时采用的密钥，又称辅助二级密钥(Secondary Key)或密钥传送密钥(key Transport key)。<br><strong>主机主密钥 Host Master Key</strong><br>是对密钥加密密钥进行加密的密钥，存于主机处理器中。<br>在公钥体制下还有公开密钥、秘密密钥、签名密钥之分。<br>2. Kerberos<br>KDC—-密钥分发中心<br><strong>两种票据</strong></p><ul><li>票据授权票据 （Ticket granting ticket）</li></ul><p>票据授权票据由AS发放<br>Tickettgs 在用户登录时向AS申请一次，可多次重复使用</p><ul><li>服务授权票据（Service granting ticket）</li></ul><p>是客户访问应用服务器时需要提供的票据<br>用TicketV表示访问应用服务器V的票据<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/4.jpg"></p><ol start="3"><li>公钥证书X.509</li></ol><p>X.509的核心是与每个用户相关的公钥证书。这些用户证书由一些可行的签证机构（CA）创建并被CA或用户放入目录服务器中。目录服务器本身不创建公钥和证书，仅为用户获得证书提供一种简单的存取方式。<br><strong>证书链</strong><br><strong>证书撤销列表CRL</strong><br><strong>PKIX模型</strong></p><ul><li>端实体</li><li>认证中心</li><li>注册中心</li><li>CRL发放者</li><li>存储库</li></ul><h2 id="网络访问控制和云安全"><a href="#网络访问控制和云安全" class="headerlink" title="网络访问控制和云安全"></a>网络访问控制和云安全</h2><ol><li>网络访问强制措施</li></ol><ul><li>IEEE 802.1X</li></ul><p>这是一个链接层协议，在一个端口被分配IP之前必须强制进行认证。IEEE 802.1X在认证过程中使用了可扩展认证协议。</p><ul><li>虚拟局域网(VLAN)</li></ul><p>由互连的局域网组成的企业网络被逻辑划分为许多VLAN，NAC系统根据安全需求，决定将网络中的哪一个虚拟局域网分配给用户。</p><ul><li>防火墙</li></ul><p>防火墙允许或者拒绝主机与外部的网络数据流，提供一种基于安全策略的网络访问控制。</p><ul><li>动态主机配置协议(DHCP)管理</li></ul><p>DHCP为主机动态分配IP地址，通过IP地址的控制分配，实现网络的访问控制。</p><ul><li>PPPoE认证</li><li>Web portal认证</li></ul><ol start="2"><li>可扩展认证协议结构(EAP)<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/5.jpg"></li><li>基于端口的网络访问控制<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/6.jpg"></li></ol><h2 id="传输层安全"><a href="#传输层安全" class="headerlink" title="传输层安全"></a>传输层安全</h2><ol><li>SSL体系结构<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/7.jpg"><br>SSL协议中重要概念：SSL会话、SSL连接。<br>SSL中定义的3个较高层协议分别是：握手协议、修改密码规范协议、警报协议。</li></ol><ul><li>SSL记录协议</li></ul><p>对各种更高层协议提供基本的安全服务。<br>保证了机密性和完整性。<br>步骤：数据分块、压缩、加MAC、加密、添加SSL记录头、作为1个TCP分组发送。</p><ul><li>SSL握手协议</li></ul><p><strong>4步握手</strong></p><ul><li>客户端请求并且相互协商协议版本和随机数等信息</li><li>服务器发送证书</li><li>客户端发送证书</li><li>更改密码套件生成主密钥</li></ul><ol start="2"><li>HTTPS</li></ol><p><strong>通信为以下元素加密</strong></p><ul><li>要求文件的URL</li><li>文件的内容</li><li>浏览器表单的内容</li><li>浏览器与服务器的Cookie</li><li>HTTP报头的内容</li></ul><p><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/8.jpg"></p><h2 id="无线网络安全"><a href="#无线网络安全" class="headerlink" title="无线网络安全"></a>无线网络安全</h2><ol><li>无线网络安全常见威胁<br>偶然连接、恶意连接、身份盗窃、中间人攻击、拒绝服务、网络注入、Ad hoc网络。</li><li>802.11网络组成与架构模型<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/9.jpg"></li><li>IEEE 802.11i操作阶段</li></ol><p><strong>分为5个阶段</strong></p><ul><li>发现</li><li>认证</li><li>密钥管理</li><li>数据传输</li><li>终止连接</li></ul><p><strong>所有阶段</strong><br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/10.jpg"><br><strong>发现和认证阶段</strong><br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/11.jpg"><br><strong>密钥管理阶段</strong><br>在密钥管理阶段期间，各种加密密钥被生成并分发给各个STA。<br>有两种类型的密钥</p><ul><li>用于STA和AP间通信的成对密钥</li><li>用于组播通信的群组密钥</li></ul><p><strong>各种密钥</strong></p><ul><li>AAAK，根密钥，最初始的密钥，认证、计数、授权并且生成其他密钥功能。</li><li>PSK，预分享密钥，生成PMK。</li><li>PMK，成对主密钥，生成PTK。</li><li>GMK，群组主密钥，生成GTK。</li><li>PTK，成对临时密钥，加密。</li><li>GTK，群组成对密钥，加密。</li><li>TK，临时密钥，单播用户信息加密。</li><li>MIC，消息完整码密钥，保证完整性。</li><li>WEP，有线等效保密密钥，交换密钥。</li></ul><p><strong>成对密钥发布阶段</strong><br>被称为4次握手，4个组成部分如下。<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/12.jpg"></p><ul><li>访问接入点—-&gt;站点，发送MAC地址和1个随机数</li><li>站点—-&gt;访问接入点，站点用2个随机数和MAC地址和成对组密钥生成成对临时密钥，包含消息完整性字段。令访问接入点也生成此承兑临时密钥。</li><li>访问接入点—-&gt;站点，访问接入点使用密钥重发第一次相同内容，包含消息完整性字段。</li><li>站点—-&gt;访问接入点，确认消息，包含消息完整性字段。</li></ul><h2 id="电子邮件安全"><a href="#电子邮件安全" class="headerlink" title="电子邮件安全"></a>电子邮件安全</h2><ol><li>PGP的操作<br>认证（数字签名）、保密（消息加密）、压缩和电子邮件兼容性。</li><li>S/MIME<br>基于RSA的安全性基础。</li><li>PGP为什么在压缩前生成签名？<br>顺序：签名—-压缩—-加密<br>压缩对邮件传输或存储都有节省空间的好处。</li></ol><p><strong>签名后压缩的原因</strong><br>不需要为检验签名而保留压缩版本的消息。<br>为了检验而再做压缩不能保证一致性，压缩算法的不同实现版本可能会产生不同的结果。<br><strong>压缩之后再做加密的原因</strong><br>压缩后的消息其冗余小，增加密码分析的难度<br>若先加密，则压缩难以见效<br><strong>E-mail兼容性</strong><br>PGP处理后的消息，部分或者全部是加密后的消息流，为任意的8位字节。某些邮件系统只允许ASC字符，所以PGP提供了转换到ASC格式的功能。采用了Radix-64转换方案。</p><h2 id="IP安全"><a href="#IP安全" class="headerlink" title="IP安全"></a>IP安全</h2><ol><li>IP协议<br>IP是TCP/IP协议族中至关重要的组成部分, 但它提供的是一种不可靠、无连接的的数据报传输服务。</li></ol><ul><li>不可靠（unreliable)</li></ul><p>不能保证一个IP数据报成功地到达其目的地。错误处理办法：扔掉该数据报，向其发送着传送一个ICMP消息。</p><ul><li>无连接（connectionless）</li></ul><p>IP并不维护关于连续发送的数据报的任何状态信息。每个数据报单独处理，在传送过程中可能出现错序。<br>2. IPsec的原理<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/13.jpg"><br>3. IPSec的规范<br>IPSec包括三种功能：认证、机密性和密钥管理。<br><strong>包含以下多种规范（未详细列出）</strong></p><ul><li>认证报头(AH) RFC4302：用于提供消息认证的扩展头。 </li><li>封装安全载荷(ESP) RFC4303 ：ESP包含了一个封装的用来提供加密或者机密和认证的结合。</li><li>因特网密钥交换(IKE) RFC4306：用于IPSec的密钥交换方案。</li></ul><ol start="4"><li>传输模式和隧道模式</li></ol><ul><li>传输模式Transport Mode</li></ul><p>用于两个主机之间的端到端通信，传输模式为上层协议提供保护，保护扩充到IP分组的有效载荷，用于两个主机之间的端到端通信。传输方式ESP对有效载荷加密并可选认证；AH认证IP有效载荷和IP首部的选中部分。</p><ul><li>隧道模式Tunnel Mode</li></ul><p>适用于当SA的一端或两端是安全网关，隧道模式对整个IP分组提供保护。原始的分组加安全域被当做一个新IP分组的载荷，并拥有一个新的外部IP报头, 通过“隧道”从IP网络的一端传输到另一端。适用于当SA的一端或两端是安全网关, 例如实现了IPSec的防火墙或路由器的情况，防火墙之后的网络主机可以不用实现IPSec而参加安全通信。<br>隧道模式中, ESP加密和认证(可选)整个内部IP包, AH认证整个内部IP包和外部IP报头中的选中部分。<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/14.jpg"><br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/15.jpg"><br>5. 安全关联<br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/16.jpg"><br>安全关联SA是在发送者和的接收者之间的一种单向关系，如果需要一个对等的关系用于双向的安全交换，就要用两个安全关联。提供给一个SA的安全服务用于AH或ESP，但不能同时用于两者。<br><strong>安全关联由三个参数标识</strong></p><ul><li>安全参数索引SPI：SPI加载在AH和ESP的首部，使接收系统能够选择SA来处理接收的分组。</li><li>IP目的地址：SA的目的地址，端用户或网络。</li><li>安全协议标识符：标识该关联是否AH或ESP安全关联。</li></ul><ol start="6"><li>IPSec ESP Header格式</li></ol><p><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/17.jpg"><br><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/18.jpg"><br><strong>填充域有如下几个作用</strong></p><ul><li>填充域用于把明文(包括载荷数据、填充、填充长度、邻接报头域)扩展到需要的长度 (如分组加密要求明文是分组长度的整数倍) 。</li><li>ESP格式要求填充长度和邻接报头域为32比特的字，密文也是32比特的整数倍，填充域用来保证这样的排列。</li><li>增加额外的填充能隐藏载荷的实际长度，从而提供部分流量的保密。</li></ul><ol start="7"><li>窗口与重放攻击检测</li></ol><ul><li>重复的接收经过认证的IP包可能会以某种方式中断服务或产生一些不希望出现的结果。</li><li>序列号能阻止重放攻击。每建立一个新的SA，发送方把序列号计数器的初始值设为0，每次在SA上发送一个包，则发送方增加计数器的值。</li><li>IP提供无连接且不可靠的分组投递服务，不能保证分组能按照顺序传输，也不能保证无丢失。IPSec规定接收方应该实现一个大小为W的窗口(W的默认值为64)。</li></ul><p><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/19.jpg"><br>8. 密钥确定协议<br>基于DH交换<br>DH交换的缺陷</p><ul><li>没有身份标识和认证</li><li>易受中间人攻击</li><li>算法的模指运算代价高，易受阻塞Clogging攻击（Clogging攻击是一类面对公钥密码系统的DoS攻击）。</li></ul><p><strong>IKE密钥确定的特性</strong></p><ul><li>使用Cookie机制来抵御阻塞Clogging攻击</li><li>允许协商公共参数，即DH中的公共参数</li><li>使用随机数防止重放攻击</li><li>可以交换DH的公钥值</li><li>对DH交换进行认证，防止中间人攻击</li></ul><p><img src="../%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/20.jpg"><br>9. IPSec的优点和路由应用<br><strong>IPSec的优点</strong></p><ul><li>提供强大的安全性，应用于防火墙和路由器。</li><li>IPSec在传输层以下，对所有的应用透明。</li><li>IPSec对终端用户透明。</li><li>必要时可以为单个用户提供安全性。</li></ul><p><strong>路由选择应用，IPSec保证</strong></p><ul><li>路由器的通告(新的路由器通告它的存在)来自被认可的路由器。</li><li>邻站通告(一个路由器尝试与另一个路由选择域的一台路由器建立或维护邻站关系)来自被认可的路由器。</li><li>重定向报文来自于发送包的初始路由器。</li><li>路由选择更新不会被假造。</li></ul><h2 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h2><ol><li>病毒</li></ol><p><strong>组成部分（1或多或重复包含）</strong></p><ul><li>感染机制</li><li>触发</li><li>载荷</li></ul><p><strong>生命周期</strong></p><ul><li>休眠阶段</li><li>传播阶段</li><li>触发阶段</li><li>执行阶段</li></ul><p><strong>按目标分类</strong></p><ul><li>引导扇区感染病毒</li><li>文件感染病毒</li><li>宏病毒</li><li>混合体病毒</li></ul><p><strong>按隐藏策略分类</strong></p><ul><li>加密病毒</li><li>隐形飞机式病毒</li><li>多态病毒</li><li>变形病毒</li></ul><p><strong>分布式拒绝服务攻击DDoS</strong></p><h2 id="入侵者"><a href="#入侵者" class="headerlink" title="入侵者"></a>入侵者</h2><ol><li>常用的入侵检测方法</li></ol><p>统计异常检测，定义通常的或期望的行为。</p><ul><li>阈值检测</li><li>基于行为曲线</li></ul><p>基于规则的检测，定义合适的行为。</p><ul><li>异常检测</li><li>渗透检测</li></ul><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><ol><li>防火墙类型</li></ol><ul><li>包过滤防火墙</li><li>状态检测防火墙</li><li>链路层网关</li><li>应用层网关</li></ul><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>考试还行，不算难，有一些细节方面真的得看书，看课本，不过这是对于考高分比如九十加要把课本研读一遍。其他的同学把老师划的重点部分仔细理解！比如IPSec的结构等等。一般般难度，不过每个人对自己要求不一样，尽量学好吧杨超老师经典话语：这是你吃饭的本事！</p>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全高级内存访问漏洞</title>
      <link href="/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/"/>
      <url>/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>主体结构是这样的</strong></p><ul><li>高级堆内存访问漏洞<ul><li>双重释放（double-free）</li><li>释放重引用（use-after-free）</li></ul></li><li>一些其他的Web安全漏洞<ul><li>跨站脚本（XSS）</li><li>跨站请求伪造（CSFR）</li></ul></li></ul><h2 id="回顾堆块的分配与释放机制"><a href="#回顾堆块的分配与释放机制" class="headerlink" title="回顾堆块的分配与释放机制"></a>回顾堆块的分配与释放机制</h2><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/1.jpg"></p><ul><li>堆空间的管理本质上是对bin链表的维护。</li><li>堆块释放后，原本指向它的指针并不自动销毁。</li><li>结果：指针悬空（指向未使用的内存，但仍然可以引用该空间）。</li></ul><blockquote><p>堆空间由用户而不是系统管理，所以指针不自动销毁。所以c 指针是不安全的。</p></blockquote><h2 id="双重释放漏洞"><a href="#双重释放漏洞" class="headerlink" title="双重释放漏洞"></a>双重释放漏洞</h2><p><strong>那么，如果尝试释放一个悬空指针所引用的内存，会如何？</strong><br>free()函数中对此的规定：“undefined behavior”。<br>问题的爆发点：堆块合并和unlink。<br><strong>示例</strong></p><ol><li>一个空的bin表项与一个对应尺寸的堆块P（已分配）看上去就像这样。</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/2.jpg"></p><ol start="2"><li>当堆块P被释放，bin表项变成了这样。表示指针悬空，堆块的前向指针和后向指针都已经指向bin中。</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/3.jpg"><br>3. 如果再次释放P，则free()的原理使得bin表项发生了下面的情况。</p><p>释放P对应合并和unlink，目前看来不是向后合并，而是向前合并，即将P的next chunk（P-&gt;FD）从链中摘除。被摘除的自己指针不动，前后块的指针修改。<br>P-&gt;FD-&gt;FD-&gt;BK = P-&gt;FD-&gt;BK 即 <strong>P-&gt;BK = P</strong><br>P-&gt;FD-&gt;BK-&gt;FD = P-&gt;FD-&gt;FD 即 <strong>P-&gt;FD = P</strong></p><blockquote><p>分配P就是要把P前后块链起来，也就是要让P-&gt;fd-&gt;bk = P-&gt;bk, P-&gt;bk-&gt;fd = P-&gt;fd</p></blockquote><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/4.jpg"></p><ol start="4"><li>此时，如果系统试图将堆块P分配出去，就可能导致分配后fd和bk会被用户数据覆盖。</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/5.jpg"></p><ol start="5"><li>如果系统再次试图分配一个与P同样大小的块。就要把P的指针再改，此时P的fd和bk会影响到前后块中的地址信息。类似于前向合并漏洞，可以用来修改特定函数的入口地址。</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/6.jpg"></p><ol start="6"><li>代码解释</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/7.jpg"></p><p>第22行意思是把fd里面放 strcpy()地址-12。</p><p>第23行意思是bk里面放shellcode地址,一个指针长度4字节。fd指针地址+4字节是bk指针地址。</p><p>第24行再分配这个chunk，此时因为chunk被unlink，调用unlink函数。分配就是要把P前后块链起来，也就是要让, P-&gt;fd-&gt;bk = P-&gt;bk, P-&gt;bk-&gt;fd = P-&gt;fd。</p><p>先是：shellcode地址赋给strcpy()地址-12+12，然后：strcpy()地址-12写入到shellcode地址-4。</p><p>第25行strcpy()被调用时，调用shellcode。</p><h2 id="双重释放重引用"><a href="#双重释放重引用" class="headerlink" title="双重释放重引用"></a>双重释放重引用</h2><p>双重释放可以认为是释放重引用漏洞的一个特例<br><strong>释放重引用漏洞的一般流程</strong></p><ul><li>申请一段空间，将其释放但并不将指针置为空（这个悬空指针记为p1）。</li><li>申请空间p2，由于malloc分配的过程使得p2指向的空间为刚刚释放的p1指针的空间。</li><li>构造恶意的数据将p2指向的内存空间布局好（即覆盖了p1中的数据）利用p1。</li></ul><ol><li>释放冲引用与缓冲区溢出的结合<br>通过操作溢出后的指针形成释放重引用，代码本身并未出现释放重引用漏洞。</li></ol><p><strong>合法指针在溢出后越界指向空闲块，在此块被分配后就有两个指针指向它。</strong><br>2. 释放重引用的潜在后果<br>一般地，攻击会尝试<strong>劫持函数指针</strong>，造成<strong>不同指针引用同一内存区域</strong>。<br><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/8.jpg"></p><h2 id="跨站脚本"><a href="#跨站脚本" class="headerlink" title="跨站脚本"></a>跨站脚本</h2><ol><li>原理：即由畸形输入的构造，使攻击方得以以访问者的身份在站点执行HTML代码。</li><li>本质：是对HTML的注入攻击。</li><li>主要分类</li></ol><ul><li>反射型XSS</li></ul><p>它通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数被HTML解析、执行。它的特点是非持久化，必须用户点击带有特定参数的链接才能引起。非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。</p><ul><li>存储型XSS</li></ul><p>持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie等。</p><ul><li>基于DOM的XSS</li></ul><h2 id="跨站请求伪造"><a href="#跨站请求伪造" class="headerlink" title="跨站请求伪造"></a>跨站请求伪造</h2><ol><li>示例</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/9.jpg"></p><ol start="2"><li>针对跨站脚本/请求伪造的防御措施</li></ol><ul><li>浏览器/站点增加针对性的过滤机制<ul><li>标签</li><li>关键字</li><li>特殊符号</li></ul></li><li>在URL请求中引入伪随机数<ul><li>类似SQL请求的随机化</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉学习过程是一个了解的阶段，并没有深入一个层次去知晓它，不过慢慢接受知识也是一个良性的过程。</p>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全SQL注入</title>
      <link href="/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入和数组越界访问漏洞"><a href="#SQL注入和数组越界访问漏洞" class="headerlink" title="SQL注入和数组越界访问漏洞"></a>SQL注入和数组越界访问漏洞</h2><p><strong>大致内容</strong></p><ul><li>SQL注入漏洞<ul><li>实现原理及后果</li><li>现有的相关应对措施</li></ul></li><li>数组越界访问漏洞</li></ul><h3 id="实现原理及后果"><a href="#实现原理及后果" class="headerlink" title="实现原理及后果"></a>实现原理及后果</h3><p><strong>B/S（浏览器和服务器）架构</strong></p><p>B/S是WEB兴起后的一种网络架构模式</p><ul><li>采用浏览器统一了客户端，将系统功能实现的核心部分集中到服务器上。</li><li>客户端使用浏览器，通过Web Server与数据库进行数据交互。</li></ul><p>B/S架构优势—-瘦客户端，胖服务端</p><ul><li>将系统实现的核心部分集中在服务端，简化系统的开发。</li><li>客户端载荷降低，减轻系统维护和升级成本。</li></ul><p><strong>数据库与SQL简介</strong></p><p>数据库：大型软件系统的关键基础设施。</p><ol><li>有结构的、有组织（集成）的、可共享的统一管理的数据集合。</li><li>具有尽可能小的冗余度、较高的数据独立性和易扩展性。</li><li>应用场景 — Web后台数据、企业级联机事务处理。</li></ol><p>结构化查询语言(Structured Query Language, SQL)，用户存取数据、查询、更新和管理关系数据库系统。注意：独立于数据库本身、硬件、网络以及操作系统。</p><ol><li>特殊目的编程语言。</li><li>数据库查询+程序设计语言。</li><li>屏蔽底层细节的高级数据库操作语言。</li></ol><p>SQL语言核心结构。</p><ul><li>做什么事情。</li><li>要找哪个对象做。</li><li>怎么做这件事情。</li><li>怎么找到这个对象（约束条件）。</li></ul><p>SQL注入出现原因：程序员的水平及经验也参差不齐，相当大一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。</p><p>SQL注入过程：把SQL命令插入到web表单递交或输入域名或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。<strong>SQL命令伪装成数据。</strong></p><p><strong>SQL注入原理</strong><br><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8SQL%E6%B3%A8%E5%85%A5/1.jpg"></p><p><strong>SQL注入过程</strong></p><ol><li>寻找可能存在SQL注入漏洞的链接</li><li>测试该网站是否有SQL注入漏洞</li><li>猜管理员帐号表</li><li>猜测管理员表中的字段</li><li>猜测用户名和密码的长度</li><li>猜测用户名</li><li>猜测密码</li></ol><p><strong>初级的注入</strong></p><ul><li>判断是否存在注入</li></ul><p>对于可能存在SQL注入的动态网页，只要该网页带有参数且此网页访问了数据库，则有可能存在注入<br><code>http://xxx.xxx.xxx/abcd.php?id=XX</code><br>给参数赋值单引号，查看页面变化（单引号不匹配而报错，则表示执行了SQL）<br><code>http://xxx.xxx.xxx/abcd.php?id=XX’</code><br>若未报错，可能做了单引号过滤，使用判断语句进行注入测试（SQL注入漏洞分为数字型和字符型）</p><ul><li>数字型漏洞</li></ul><p><code>http://xxx.xxx.xxx/abcd.php?id=XX</code><br>若XX为数字类型，例如页码、ID等，存在注入时则为数字类型的注入。<br>给参数赋值为and 1=1，页面正常。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX and 1=1</code><br>接着给参数赋值为and 1=2，页面报错。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX and 1=2</code></p><ul><li>字符型漏洞</li></ul><p><code>http://xxx.xxx.xxx/abcd.php?id=XX</code><br>若XX为字符串，注入测试需使用单引号来闭合。<br>给参数赋值为and 1=1，页面正常。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX ‘and ’1‘=’1</code><br>接着给参数赋值为and 1=2，页面报错。<br><code>http://xxx.xxx.xxx/abcd.php?id=XX ‘and ’1‘=’2</code></p><ul><li>猜管理员账号表</li></ul><p>在末尾加上：<code>and exists (select * from admin)</code><br>我们的意思是猜测他有个admin表段。页面返回正常，我们猜对了。当然也可能错误返回，这时就要看猜测的本事了。</p><ul><li>猜测管理员表表中的字段</li></ul><p>我们再来猜他的管理员表中是否有一个ID段，在末尾加上：<code>and exists (select id from admin)</code><br>页面返回正常,说明他的admin表中有个id的字段。<br>我们继续： <code>and exists (select username from admin)</code>。这里的意思是看看他的admin表中是否有username字段，页面返回正常,说明在admin中有一个username字段<br>我们继续猜他放密码的字段： <code>and exists (select password from admin)</code>。返回正常的页面,说明他的admin表中有个password字段。<br>到此可以知道admin表中至少有如下三个字段：id,username,password，这种命名方式与普通程序员的命名方法一致。</p><ul><li>猜测用户名和密码的长度</li></ul><p>首先猜他的管理员的id值： <code>and exists (select id from admin where id=1)</code>，意思是看看他的admin表中是否有一个id=1的值。<br>返回了正常的页面,说明我们猜对了。<br>接着猜ID为1的用户名长度： <code>and exists (select id from admin where len(username)&lt;6 and id=1)</code><br>这里我们猜他的管理员长度小于6,返回了正常的页面,还好,名字不是太长,我们一个个来实验好了。<br><code>and exists (select id from admin where len(username)=5 and id=1)</code>，返回了正常的页面,说明用户名的长度我们已经猜出了为5。<br>用同样的方法，我们猜出了密码的长度是10，要添加的语句是：<code> and exists (select id from admin where len(password)=10 and id=1)</code><br>到此，用户名和密码的长度都已经猜出来了，下面要做的是猜出它们的每一位分别是多少。<br>方法是在后面加上： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,1,1))&lt;100)</code><br>我们这里做的意思是，猜测他的用户名的第一个字的ascii码值小于100。</p><blockquote><p>其中，asc函数的功能是将字符转换成ASCII码，mid函数的功能是截取username字段值的字串，从第1位开始，截取的长度是1</p></blockquote><p>返回了正常页面，说明的确如我们所料，接着： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,1,1))&lt;50)</code><br>返回错误信息，说明：50&lt;=第一个字的ascii码值&lt;100。接下来，我们用折半查找的思想： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,1,1))&lt;75)</code><br>接下来我们猜测第二位： <code>and 1=(select id from (select * from admin where id=1) where asc(mid(username,2,1))&lt;100)</code><br>用折半查找的思想，采取上述方式，很快就能找到密码。</p><blockquote><p>注意：网站上密码多是以杂凑值处理，需要专用的哈希函数破解。尽管哈希函数是单向的，然而用户的密码是有限长度的，可以预先存储计算匹配，而非反向破解。</p></blockquote><p><strong>高级的注入</strong></p><ol><li>大小写绕过。</li><li>双写绕过。</li><li>等效语言表达绕过。</li><li>科学计数法、括号绕过。</li><li>浮点数、括号绕过。</li><li>内联注释绕过。</li><li>子查询、join联合绕过。</li></ol><h3 id="现有相关应对措施"><a href="#现有相关应对措施" class="headerlink" title="现有相关应对措施"></a>现有相关应对措施</h3><ol><li>对SQL请求的动态解析树，采用SQL引擎预先对SQL语法进行分析，生成该SQL语句的语法树。对客户端输入的参数中的SQL命令解析为字符串字面值参数，进而不会执行。</li><li>对用户输入的参数进行严格的匹配以及过滤。</li><li>设置用户操作数据库的权限。</li></ol><h2 id="数组越界访问漏洞"><a href="#数组越界访问漏洞" class="headerlink" title="数组越界访问漏洞"></a>数组越界访问漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>溢出与越界不完全相等</p><ul><li>数组越界分为读/写两种情况，而溢出漏洞属于越界写入。</li><li>一些溢出漏洞的本质是数组越界。</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#123;      int x[10];        cout &lt;&lt; x[10]; &#125;&#x2F;&#x2F;直观的数组越界可以在编译时较容易地检查出来，但是……&#123;      int i, x[10];        &#x2F;&#x2F;对i进行算术运算      cout &lt;&lt; x[i]; &#125;&#x2F;&#x2F;用法是允许的，存在越界的可能，但编译器无法指出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="举例与分析"><a href="#举例与分析" class="headerlink" title="举例与分析"></a>举例与分析</h3><p>CVE-2014-0160“OpenSSL数组越界访问漏洞”(Heartbleed心脏滴血) 。</p><p>成因–处理heartbeat response时没有检查包长度的合法性，直接分配相应大小的内存。</p><p>TLS和DTLS在处理心跳请求包逻辑中，从堆空间上申请的内存大小由type、length、request的数据长度和payload四个部分组成，其中type,length,payload字段分为占1byte，2byte，16byte，所以response的数据总是比request的多出来19byte。</p><p>length（心跳包的长度）是用户可控的，而payload（也是储存长度）是也是用户可控的，那么当payload长度大于心跳包的长度，那么就可以读取内存中心跳包后面的数据了。</p><p><strong>C语言的数组越界为何难以检查？</strong></p><ul><li>性能⟺安全。</li><li>指向数组元素的指针和数组本身是完全独立的。</li><li>指针运算的可行性。</li><li>用指针表示范围，不仅需要指针本身存在且可用，还需要指针指向的内存可用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全其他溢出漏洞</title>
      <link href="/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/06/23/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="本文大致内容"><a href="#本文大致内容" class="headerlink" title="本文大致内容"></a>本文大致内容</h2><ul><li>整数溢出<ul><li>数值计算的基本原理</li><li>整数溢出及其可能的后果</li></ul></li><li>格式化字符串漏洞<ul><li>类printf函数簇实现原理</li><li>格式化字符串攻击原理及潜在后果</li></ul></li></ul><p>在这一章节似乎只是在计算机中实现，更偏向于怎么将漏洞在计算机上实现，对于一些常见的编程中出现的漏洞，也似乎不能叫出现的漏洞吧，应该是编译器的漏洞。对一些边界问题的规定是否规范，还是任由编译器自己决定，决定着这个漏洞是否可以被实现。通过打印出一些内存中具体的值，为后来的其他溢出做了铺垫。</p><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><h3 id="数值计算的基本原理"><a href="#数值计算的基本原理" class="headerlink" title="数值计算的基本原理"></a>数值计算的基本原理</h3><ul><li>整数的表示</li></ul><p><strong>64位</strong><br>类型：short（16bit）、int（32bit）、long（64bit），8字节<br>带符号：-2^（n-1)-2^（n-1）-1、不带符号：0-2^n-1<br><strong>32位</strong><br>long（32bit），4字节</p><ul><li>带符号整数格式中的补码</li></ul><ol><li>带符号的正护士统一用补码表示（正整数和负整数都是）。</li><li>意义：符号位和数值域统一，加法和减法统一。</li></ol><blockquote><p>对于正数原码、反码以及补码是其本身。负数的原码是其本身，反码是对原码除符号位之外的各位取反，补码则是反码加1。</p></blockquote><ul><li>整数的加减法</li></ul><p><strong>CF是无符号数溢出标志，OF是有符号数溢出标志。</strong></p><p>CF/OF=1，则表示计算结果溢出。</p><ol><li>CF的判断<ul><li>加法<br>十进制角度，如果两个无符号数相加，结果大于阈值，则CF=1，否则CF=0。<br>二进制角度，如果两无符号数相加，最高位向前进位，则CF=1，否则CF=0。</li><li>减法<br>十进制角度，两无符号数相减，减数大于被减数，则CF=1，否则CF=0。<br>二进制角度，如果两无符号数相减，最高位向前有借位，则CF=1，否则CF=0。</li></ul></li><li>OF判断<ul><li>加法<br>十进制角度，两有符号数相加，结果不在范围内，则OF=1，否则OF=0。<br>二进制角度，如果两有符号数同号，得到的结果异号，则OF=1，否则OF=0。</li><li>减法<br>十进制角度，两有符号数相减，结果不在范围内，则OF=1，否则OF=0。<br>二进制角度，如果两有符号数异号，得到的结果与被减数符号相反，则OF=1，否则OF=0。</li></ul></li></ol><p>整数溢出的例子中需要注意</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int atoi(const char *nptr);&#x2F;&#x2F;用法：将字符串里的数字字符转化为整形数。返回整形值。&#x2F;&#x2F;注意：转化时跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(&#39;&#x2F;0&#39;)才结束转换，并将结果返回。void *memcpy(void *destin, const void *src, size_t n);&#x2F;*由src指向地址为起始地址的连续n个字节的数据复制到以destin指向地址为起始地址的空间内。　　函数返回一个指向destin的指针。说明    1. source和destin所指内存区域不能重叠，函数返回指向destin的指针。    2. 与strcpy相比，memcpy并不是遇到&#39;\0&#39;就结束，而是一定会拷贝完n个字节。    3. 如果目标数组destin本身已有数据，执行memcpy（）后，将覆盖原有数据（最多覆盖n）。如果要追加数据，则每次执行memcpy后，要将目标数组地址增加到你要追加数据的地址。注意，source和destin都不一定是数组，任意的可读写的空间均可。*&#x2F;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在C语言中的表示</li></ul><p>在C/C++语言中，char变量为一个字节，8位，signed char表示的范围：-128-127【-128在内存中的二进制表示为1000 0000，127在内存中的表示为0111 1111】；unsign char表示的范围：0000 0000-1111 1111，即0-255；<br>默认是signed还是unsigned取决于编译器。</p><p>因为size是字节数，所以要*8，这样unsigned取模刚好是对它的表示范围取模。<br>左边是无符号型全1，是最大值+1=0<br>右边是0111 1111 = 127，也是最大值，+1=128，实际上溢出了，超出了表示范围。1 000 0000=-128</p><blockquote><p>C语言中的表示不是很一样，如果取无符号，则只表示之前范围的非负数的那部分。</p></blockquote><h3 id="整数溢出及其可能的后果"><a href="#整数溢出及其可能的后果" class="headerlink" title="整数溢出及其可能的后果"></a>整数溢出及其可能的后果</h3><p><strong>例如</strong></p><ol><li>举例1</li></ol><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/1.jpg"></p><p>若将MAX_LEN设置为32767，同时，假设buf的值总为2，实际结果：当len==32766时，line 6 造成len的值变为-32768，程序死循环</p><p>32767是signed short上限，len=32766时，+2溢出，如果不规定处理方式则变为最小值-32768。程序无法跳出循环。</p><ol start="2"><li>举例2</li></ol><p>又如：abs(-2147483648) &lt; 0</p><p>函数abs的功能 — 对于输入参数为正，返回其本身，否则返回其相反数。<br>然而，对于-2147483648（int类型的最大负数值），函数abs返回的是其本身。</p><p>可见，整数溢出至少可能产生以下一些后果</p><ul><li>产生逻辑谬误，造成程序在执行中卡死或者出错</li><li>为后续的缓冲区溢出充当引信</li></ul><p>一些防范整数溢出的编程习惯</p><ul><li>对整数溢出的检查必须出现在可能溢出的位置之前，否则就有可能不起作用</li><li>注意类型强制转换（或者说，注意指针的使用）</li><li>同等地重视上溢和下溢，两者都需要预先检查</li></ul><p><strong>整数溢出的防护</strong></p><ol><li>IntScope — 检测整数溢出本身</li></ol><p>利用符号执行、动态污点跟踪等分析运行时数据流，寻找异常。</p><ol start="2"><li>IntPatch — 检测并修复后续的缓冲区溢出漏洞</li></ol><p>针对：整数溢出到缓冲区溢出（IO2BO）</p><h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><h3 id="类printf函数簇实现原理"><a href="#类printf函数簇实现原理" class="headerlink" title="类printf函数簇实现原理"></a>类printf函数簇实现原理</h3><ul><li>类printf函数簇的第一个可利用点：参数不匹配时难以发现。<ul><li>printf()是一个参数长度可变函数，仅仅看参数数量无法发现问题。</li><li>为了查出不匹配，编译器需要了解printf()的运行机制，然而编译器通常不做这类分析。</li><li>若格式字符串在程序运行期间生成(如用户输入)，则编译器无法发现不匹配。</li></ul></li></ul><h3 id="格式化字符串攻击原理及潜在后果"><a href="#格式化字符串攻击原理及潜在后果" class="headerlink" title="格式化字符串攻击原理及潜在后果"></a>格式化字符串攻击原理及潜在后果</h3><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2.jpg"></p><blockquote><p>当printf在输出格式化字符串的时候，会维护一个内部指针，当printf逐步将格式化字符串的字符打印到屏幕，当遇到%的时候，printf会期望它后面跟着一个格式字符串，因此会递增内部字符串以抓取格式控制符的输入值。这就是问题所在，printf无法知道栈上是否放置了正确数量的变量供它操作，如果没有足够的变量可供操作，而指针按正常情况下递增，就会产生越界访问。甚至由于%n的问题，可导致任意地址读写。</p></blockquote><ol><li>举例1</li></ol><p>如果让str=“%x”，则会发生什么？<br>%x是printf规定的一种输出类型，unsigned int，输出无符号16进制数。<br>结果：通过构造异常字符串，可以实现对程序栈结构的任意读取。</p><p><strong>为什么程序员写的是错误的呢？</strong></p><p>他传入了一个他想要逐字打印的字符串。实际上该字符串被printf函数解释为一个格式化字符（formatstring），printf就会根据该字符串来决定printf函数中省略号参数表中参数的格式和类型，如果这个程序员想要打印的字符串中刚好有“%d”,“%x”之类的格式化字符，那么一个变量的参数值就从堆栈中取出。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char* argv[])&#123;    if(argc !&#x3D; 2)        return 0;    printf(argv[1]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当./a.out “hello world”时一切正常，但是当./a.out “%x”时，就会有莫名其妙的数字被打印出来了。因为后面没跟参数，但printf以为后面有个参数，就会把当前堆栈对应的4字节（应该是高地址）以%x打印。通过特定设计，可以打印特定位置内存信息。<br>很明显，攻击者至少可以通过打印出堆栈中的这些值来偷看程序的内存。但是有些事情就不那么明显了，这个简单的错误允许向运行中程序的内存里写入任意值。</p><ol start="2"><li>举例2</li></ol><p><strong>更进一步</strong><br>%s，printf规定的另一种输出类型，char <em>/wchar_t</em>，输出字符串。</p><p>结果：通过构造异常字符串，还有可能实现对任意内存的（大面积）读取。</p><ol start="3"><li>举例3</li></ol><p><strong>再进一步</strong><br>%n，特殊printf输出类型，int*，将此前已输出的串长度写入指针所指位置。</p><p>结果：通过构造异常字符串，可以实现对任意内存的任意改写。</p><blockquote><p>%n:该符号前输入的字符数量会被存储到对应的参数中去。<br>int i; printf (“12345%n”, &amp;i);<br>数字5（%n前的字符数量）将会被写入i中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对晨晨说的话</title>
      <link href="/2021/06/22/%E5%AF%B9%E6%99%A8%E6%99%A8%E8%AF%B4%E7%9A%84%E8%AF%9D/"/>
      <url>/2021/06/22/%E5%AF%B9%E6%99%A8%E6%99%A8%E8%AF%B4%E7%9A%84%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="对晨晨说的话"><a href="#对晨晨说的话" class="headerlink" title="对晨晨说的话"></a>对晨晨说的话</h2><p><img src="../%E5%AF%B9%E6%99%A8%E6%99%A8%E8%AF%B4%E7%9A%84%E8%AF%9D/1.JPG"></p><p>今天是星期三，我很想知道什么事情，这件事情在我的心里憋了很久，我一直提醒自己不要忘记，不要记起，不要回想。不要去追寻。在多少年前，我是过着什么样的生活，在大概十年前，我知道自己在做什么吗，十年前的这个时候，我可能现在早已经进入梦乡，或者是在做其他的事，具体什么事，也是在幻想生活的改变。</p><p>我期待明天，我期待每天的早晨，现在不是如此吗？现在也是，在早上我是不会有任何烦心的事情，我总能想起梦里的事情，梦里我怎么做，怎么说，我梦到了谁，昨晚梦到了谁，今晚我要梦到谁，做怎么样的梦。我的生活是由无数人的生活促就的，他们做的改变，他们的呼吸，他们的欢笑和哭泣，让远方的我有了如此的生活。</p><p>在这一天，我遇到了这个人。我很认定我自己是对的，因为我心动了，在自己经历过如此多的事情之后，我发现自己喜欢的是什么，讨厌的是什么，不屑的是什么，甚至追求的是什么都已经模糊。在我遇到她之前，我早上是八点十分起床的，我早上吃肉夹馍，中午吃快餐，晚上吃烩面。我有时还会打游戏，在虚拟世界里沉迷一小刻，我便开始幻想，为什么我自己不能有自己的幸福。为什么爱情要如此令我受折磨，在一个孤独的冰冷的世界遨游，我要归往的是哪里，我是会要做一个没有经历过青春的人吗？还是要在无数个不愿意睁开眼，知道世界上的某个角落的某个人仍旧孤孤零零寻找我的味道呢？</p><p>我遇到你，我想要对你说过许多话，但有很多是不足够表达我的心的。我想，我听，我思考。我最爱这样子，这样就可以慢慢规划以后的事情，我拒绝做一个精英，我想不断陪伴一个人成长。不是要面谈生意，我不愿牺牲爱情，我不愿在自己的心中磨灭对爱情的美妙的想象。你喜欢什么颜色，爱吃什么食物，喜欢冬天还是夏天，今天的天气如何，你的心情如何，有没有不舒服，有没有饿到肚子，有没有吃了不对胃口的饮食。这些问题困扰着我，我也不会知道，我不知道今天你在一棵树前停留许久，是在想，是在听，还是在发呆。想要一个人的依靠，想要一个人的照顾。</p><p>我不希望自己成为他人的迷茫点，在无数个夜晚，我都是怎么在想你，想你做什么，我怕失去你，也怕错过你。我总该想，要多和你说几句话，说有趣的事，吃可口的食物，吹凉飒的晚风，走在平常的街道，听夏日的蝉鸣。我又想在午后，吃完最后一口米饭，一起将碗筷收进厨房，看到时间还早，我不过是想靠你近一点，用纸巾擦去你嘴巴上的油。</p><p>生活如此，我梦想，幻想，还是想象。你存在吗？我不敢相信自己，我从来不会觉得自己有着足够的幸运遇到你，我知道过无数的人，无数的事。知道他们过着怎么样的生活，却没曾想终于愿意沉下心来为自己做打算，为我们的之后做安排。</p><p>夜没深，我也没有醒，希望我在梦里不会醒，你也不会从梦里走出来，在梦里，我很喜欢。喜欢你的发梢，你的脸庞，你的呼吸，你的心跳，最喜欢你无处不在的可爱。</p><p>你要吃掉我的心吗，晨晨，生活是美好的，就算眼前困惑。你要相信我。</p><p>–SS</p>]]></content>
      
      
      <categories>
          
          <category> 胜胜的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胜胜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全堆溢出</title>
      <link href="/2021/06/22/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/"/>
      <url>/2021/06/22/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/</url>
      
        <content type="html"><![CDATA[<p>这篇文章也是花了很久的时间才能说半抄半理解结束，其中有一些内容到现在还是不清楚，但愿自己慢慢思考。</p><span id="more"></span><ul><li><p>堆的构造与维护原理</p><ul><li>堆的场地和块</li><li>隐式/显示链表与堆的维护</li></ul></li><li><p>堆溢出</p><ul><li>linux系统典型堆溢出原理</li><li>现有应对策略和技术</li></ul></li></ul><h2 id="堆的工作原理"><a href="#堆的工作原理" class="headerlink" title="堆的工作原理"></a>堆的工作原理</h2><ul><li>堆与栈的区别<ul><li>栈：硬件支持；存储数据+控制流信息。</li><li>堆：操作系统的库函数支持；存储数据。</li></ul></li></ul><p>堆的创建和维护通过malloc实现。</p><p>堆内存是移动[Program Break]的位置产生的（通过brk中断），实际产生的堆比申请的堆还要大，这个连续的堆区域被称为[arena]。被主进程创建的，因此称为[main arena]。接下来申请会分配到这个arena的多余申请空间的部分。分配完毕后，它可以通过继续移动Program Break的位置扩容。扩容后，top chunk的大小也随之调整，将这块新增的空间圈进去。相应地，arena也可以在top chunk过大时缩小。top chunk是一个 arena位于最顶层的chunk。</p><blockquote><p>注意：非直接返还给系统，由malloc库函数管理，将其添加到bin。当用户再次调用，首先从bins查找是否有满足的，若没有才向操作系统申请新的堆空间，以提高整个效率。</p></blockquote><p>堆在栈创造之前便存在了，是程序运行便开始调用栈，而堆需要使用malloc函数才行。</p><h3 id="堆内存的建立"><a href="#堆内存的建立" class="headerlink" title="堆内存的建立"></a>堆内存的建立</h3><p>堆内存是使用mmap系统调用产生的，而非同主线程一样使用sbrk系统调用。用户请求的空间中略大（申请100kb，但实际映射到地址空间的有1Mb），只有132kb空间有读写权限，并成为该线程的堆内存。称之为[thread areana]。</p><p>当用户请求超过128kb，并且arena中没有足够的空间来满足用户的请求，内存将通过mmap系统调用分配（不再是sbrk），而不论请求是发自main arena还是thread arena。</p><h3 id="堆的工作原理-1"><a href="#堆的工作原理-1" class="headerlink" title="堆的工作原理"></a>堆的工作原理</h3><p>arena数量</p><ul><li>32位系统=2*内核数+1</li><li>64位系统=8*内核数+1</li></ul><p>单核32位系统，运行多线程程序—-1个主线程+3个用户线程，malloc如何令4个线程共享3个arena？</p><p>主线程分配主arena,线程1、2分别分配arena，那么线程3需要重复使用已分配好的arena.glibc malloc循环遍历所有可用的场地，如果lock成功（该 场地当前对应的线程并未使用堆内存），则将该场地供线程3使用。</p><p>如果没有找到可用的area，则将线程3的malloc操作阻塞，直到找到可用的为止。</p><ul><li><p>在[glibc malloc]中主要有3种数据结构：</p><ul><li><p>heap_info ——Heap Header—— 一个 thread arena 可以维护多个堆。每个堆都有自己的堆 Header（注：也即头部元数据）。什么时候 Thread Arena 会维护多个堆呢？ 一般情况下，每个 thread arena 都只维护一个堆，但是当这个堆的空间耗尽时，新的堆（而非连续内存区域）就会被 mmap 到这个 aerna 里；</p></li><li><p>malloc_state ——Arena header—— 一个 thread arena 可以维护多个堆，这些堆另外共享同一个 arena header。Arena header 描述的信息包括：bins、top chunk、last remainder chunk 等；</p></li><li><p>malloc_chunk ——Chunk header—— 根据用户请求，每个堆被分为若干 chunk。每个 chunk 都有自己的 chunk header；</p></li></ul></li></ul><p>Main arena 无需维护多个堆，因此也无需heap_info。当空间耗尽时，与 thread arena 不同，main arena 可以通过 sbrk 拓展堆段，直至堆段[碰]到内存映射段；</p><p>与 thread arena 不同，main arena 的 arena header 不是保存在通过 sbrk 申请的堆段里，而是作为一个全局变量，可以在 libc.so 的数据段中找到。</p><p>thread arena只含有一个malloc_state(即arena header)，却有两个heap_info(即heap header)。由于两个heap segments是通过mmap分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，libc malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了malloc_state，这样就构成了一个单链表，方便后续管理。</p><p><strong>堆块进化史</strong></p><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/1.jpg"></p><p>左上是allocated chunk格式，左下是free chunk格式，右边是整个堆内存组织成一个连续的已分配或未分配chunk序列。</p><p>堆内存中要求每个chunk的大小必须为8的整数倍，因此chunk size的后3位是无效的，为了充分利用内存，堆管理器将这3个比特位用作chunk的标志位，典型的就是将第0比特位用于标记该chunk是否已经被分配。</p><blockquote><p>这样的设计很巧妙，因为我们只要获取了一个指向chunk size的指针，就能知道该chunk的大小，即确定了此chunk的边界，且利用chunk size的第0比特位还能知道该chunk是否已经分配，这样就成功地将各个chunk区分开来。注意在allocated chunk中padding部分主要是用于地址对齐的(也可用于对付外部碎片)，即让整个chunk的大小为8的整数倍。</p></blockquote><p>上面的这种结构就叫做<strong>隐式链表</strong>。该链表隐式地由每个chunk的size字段链接起来，在进行分配操作的时候，堆内存管理器可以通过遍历整个堆内存的chunk，分析每个chunk的size字段，进而找到合适的chunk。</p><p>缺点：这种隐式链表效率其实是相当低的，特别是在内存回收方面，它难以进行相邻多个free chunk的合并操作。我们知道，如果只对free chunk进行分割，而不进行合并的话，就会产生大量小的、无法继续使用的内部碎片，直至整个内存消耗殆尽。因此堆内存管理器设计了带边界标记的chunk合并技术。</p><p><strong>出现问题</strong></p><ol><li>向前合并</li></ol><p>假设我们要释放的chunk为P，它紧邻的前一个chunk为FD，紧邻的后一个chunk为BK，且BK与FD都为free chunk。将P于BK合并在一起是很容易的，因为可以通过P的size字段轻松定位到BK的开始位置，进而获取BK的size等等，但是将P于FD合并却很难，我们必须从头遍历整个堆，找到FD，然后加以合并，这就意味着每次进行chunk释放操作消耗的时间与堆的大小成线性关系。</p><p>为了解决这个问题，Knuth提出了一种聪明而通用的技术——边界标记。</p><p>Knuth在每个chunk的最后添加了一个脚部(Footer)，它就是该chunk 头部(header)的一个副本，我们称之为边界标记。显然每个chunk的脚部都在其相邻的下一个chunk的头部的前4个字节处。通过这个脚部，堆内存管理器就可以很容易地得到前一个chunk的起始位置和分配状态，进而加以合并了。</p><p>但是，边界标记同时带来了一个问题：它要求每个块都包含一个头部和脚部，如果应用程序频繁地进行小内存的申请和释放操作的话(比如1，2个字节)，就会造成很大的性能损耗。</p><p>同时，考虑到只有在对free chunk进行合并的时候才需要脚部，也就是说对于allocated chunk而言它并不需要脚部，因此我们可以对这个脚部加以优化——将前一个chunk的已分配/空闲标记位存储在当前chunk的size字段的第1，或2比特位上，这样如果我们通过当前chunk的size字段知道了前一个chunk为free chunk，<em>那么就可得出结论</em>：当前chunk地址之前的4个字节为前一个free chunk的脚部，我们可以通过该脚部获取前一个chunk的起始位置；如果当前chunk的size字段的标记位表明前一个chunk是allocated chunk的话，<em>那么就可得出另一个结论</em>：前一个chunk没有脚部，即当前chunk地址之前的4个字节为前一个allocated chunk的payload或padding的最后部分。</p><ol start="2"><li>多线程时标志位不够</li></ol><p>随着技术的发展，特别是堆内存管理器添加对多线程的支持，前述的chunk格式已经难以满足需求，比如，我们需要标志位来标记当前chunk是否属于非主线程即thread arena，以及该chunk由mmap得来还是通过brk实现等等。但此时chunk size只剩下一个比特位未使用了，怎么办呢？这需要对chunk格式进行大手术！</p><p>首先思考：是否有必要同时保存当前chunk和前一个chunk的已分配/空闲标记位？</p><p>答案是否定的，因为我们只需要保存前一个chunk的分配标志位就可以了，至于当前chunk的分配标志位，可以通过查询下一个chunk的size字段得到。那么size字段中剩下的两个比特位就可以用于满足多线程的标志需求了。</p><p>PREV_INUSE(P): 表示前一个chunk是否为allocated。<br>IS_MMAPPED(M)：表示当前chunk是否是通过mmap系统调用产生的。  NON_MAIN_ARENA(N)：表示当前chunk是否是thread arena。</p><p><strong>当前的堆块的形态</strong></p><p>没必要保存chunk size的副本，也就是说Footer的作用并不大，但是如果前一个chunk是free的话，在合并的时候我们又需要知道前一个chunk的大小，怎么办呢？</p><p>将Footer从尾部移到首部，同时其不再保存当前chunk的size，而是前一个free chunk的size不就行了。同样的，为了提高内存利用率，如果前一个chunk是allocated chunk的话，这个Footer就作为allocated chunk的payload或padding的一部分。</p><p><strong>隐式/显式（bin）链表结构</strong></p><p>该结构体通过每个chunk的prev_size和size构成了隐式链表，而后续的fd, bk等指针并不是作用于隐式链表的，而是用于加快内存分配和释放效率的显示链表bin(还记得bin么？用于记录同一类型free chunk的链表)，并且这些指针跟prev_size一样只在free chunk中存在。</p><p><strong>bin的分类</strong></p><ul><li>fastbinsY，16-80字节，记录所有fastbins的数组。</li><li>bins，记录除了fastbins之外所有的bins。<ul><li>unsorted bin。</li><li>small bin。</li><li>large bin。</li></ul></li></ul><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/2.jpg"></p><p>在所有的 bins 中，fast bins 路径享有最快的内存分配及释放速度。</p><p><strong>堆的工作原理</strong></p><p>每个 fast bin 都维护着一条 free chunk 的单链表，采用单链表是因为链表中所有 chunk 的大小相等，增删 chunk 发生在链表顶端即可；—— LIFO。添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。需要注意的是，为了实现LIFO算法，fastbinsY数组中每个fastbin元素均指向了该链表的rear end（尾结点），而尾结点通过其fd指针指向前一个结点，依次类推。<br>chunk 大小：8 字节递增。 fast bins 由一系列所维护 chunk 大小以 8 字节递增的 bins 组成。也即，fast bin[0] 维护大小为 16 字节的 chunk、fast bin[1] 维护大小为 24 字节的 chunk。依此类推……  指定 fast bin 中所有 chunk 大小相同；</p><p>在 malloc 初始化过程中，最大的 fast bin 的大小被设置为 64 而非 80 字节。因为默认情况下只有大小 16 ~ 64 的 chunk 被归为 fast chunk 。</p><p>无需合并 —— 两个相邻 chunk 不会被合并。虽然这可能会加剧内存碎片化，但也大大加速了内存释放的速度！</p><p>malloc(fast chunk) ：初始情况下 fast chunck 最大尺寸以及 fast bin 相应数据结构均未初始化，因此即使用户请求内存大小落在 fast chunk 相应区间，服务用户请求的也将是 small bin 路径而非 fast bin 路径；初始化后，将在计算 fast bin 索引后检索相应 bin；</p><p>相应 bin 中被检索的第一个 chunk 将被摘除并返回给用户。<br>free(fast chunk) ：计算 fast bin 索引以索引相应 bin；free 掉的 chunk 将被添加到上述 bin 的顶端。  </p><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中(为什么，在什么情况下会发生这种事情呢？详情见后文)，系统就将这些chunk添加到unsorted bin中。为什么要这么做呢？这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。</p><p><strong>Unsorted bin的特性如下</strong></p><ul><li><p>unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。</p></li><li><p>Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。这就是前言说的特例了，不过特例并非仅仅这一个，后文会介绍。</p></li><li><p>小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。每个small bin也是一个由对应free chunk组成的循环双链表。第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 61*8 = 508字节。</p></li><li><p>大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。</p></li><li><p>鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行从大到小的排列：最大的chunk放在链表的front end，最小的chunk放在rear end。</p></li></ul><p><strong>top chunk</strong></p><p>当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。该chunk并不属于任何bin，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。</p><p>如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：</p><ol><li>用户请求的chunk；</li><li>剩余的部分成为新的top chunk。<br>否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</li></ol><p><strong>顶块的作用：救火队员</strong></p><ol><li>不属于任何bin</li><li>当前所有空闲块(无论那种bin)全都尺寸不合时，由顶块应急</li><li>顶块比请求尺寸大 — 分割供给使用，剩余部分为新顶块</li><li>顶块比请求尺寸小 — 全堆无适合块，扩展堆/分配新堆</li></ol><p>对于Last remainder chunk，我们主要有两个问题：<br>1)它是怎么产生的；<br>2)它的作用是什么？</p><ul><li><p>当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。</p></li><li><p>此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</p></li></ul><h4 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h4><p><strong>与栈溢出的区别</strong></p><ol><li>堆溢出方向=堆增长方向。</li><li>首先破坏（虚拟地址意义上的）下一个堆块的构造。</li></ol><p><strong>linux典型的堆溢出利用方式</strong></p><ol><li>攻击fast bin。</li><li>攻击unlink。</li></ol><p><strong>攻击fastbin</strong></p><p>攻击原理是在chunk被分配时，从队尾删除，并将当前chunk的fd写入到fastbin。下次分配就分配这个fd对应地址的chunk。<br>具体用法是chunk0写入溢出，覆盖相邻的chunk1的fd。当chunk1被分配时，被篡改的chunk1中的fd被写入fastbin。在chunk2被分配时就分配攻击者想攻击的内存地址。因为被分配的内存空间可写，攻击者因此实现对指定地址写入数据的目的。</p><p>可能是在内存有连续空间时，快速分配释放，使得buf0 buf1空间连续，这样在写入溢出时，就可以覆盖到相邻的未分配的buf1里面的fd地址。</p><p><strong>攻击unlink</strong></p><p>一旦涉及到free内存（非mmaped的chunks的回收机制），那么就意味着有新的chunk由allocated状态变成了free状态，此时glibc malloc就需要进行合并操作——向前以及(或)向后合并。</p><p>将previous free chunk合并到当前free chunk，叫做向后合并；将后面的free chunk合并到当前free chunk，叫做向前合并</p><p><strong>向后合并操作</strong></p><p>首先检测previous chunk是否为free，这可以通过检测当前free chunk的PREV_INUSE(P)比特位获得。</p><p><strong>如果为free的话，那么就进行向后合并</strong></p><p>将前一个chunk占用的内存合并到当前chunk。<br>修改指向当前chunk的指针，改为指向前一个chunk。<br>使用unlink宏，将前一个free chunk从双向循环链表中移除。</p><p><strong>向前合并操作</strong></p><p>首先检测next chunk是否为free。那么如何检测呢？通过查询next chunk之后的chunk的PREV_INUSE (P)。</p><p><strong>即可如果为free的话，那么就进行向前合并</strong></p><p>本质是将next chunk从双向链表中移除，合并到当前chunk。<br>在glibc malloc中，会将合并后的chunk(或因为不满足合并条件而没合并的chunk) ，放到unsorted bin中。</p><p><img src="../%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB/3.jpg"></p><ol><li><p>在代码3中存在一个堆溢出漏洞：如果用户输入的argv1的大小比first变量的666字节更大的话，那么输入的数据就有可能覆盖掉下一个chunk的chunk header——这可以导致任意代码执行。而攻击的核心思路就是利用glibc malloc的unlink机制。</p></li><li><p>程序在[4]处调用free(first)后，执行：</p><ul><li><p>向后合并：鉴于first的前一个chunk非free的，所以不会发生向后合并操作。</p></li><li><p>向前合并：先判断后一个chunk是否为free，若free则合并。</p></li></ul></li><li><p>prev_size =一个偶数，这样其PREV_INUSE位就是0了，即表示前一个chunk为free。</p><ul><li>size = -4</li><li>fd = free函数的got表地址address – 12；(简称为“free addr – 12”)。</li><li>bk = shellcode的地址Bitmap Flipping攻击。</li></ul></li><li><p>  nextchunk + nextsize计算得到指向下下一个chunk的指针，然后判断下下个chunk的size的PREV_INUSE标记位（判断是否为free）。    + nextsize=-4,进而导致next chunk的prev_size字段看做是next-next chunk的size字段。    + next chunk的prev_size字段设置为了一个偶数，低位为0进而判断next chunk为free。</p></li></ol><p><strong>注意</strong></p><p>既然next chunk为free，那么就需要进行向前合并，所以就会调用unlink(nextchunk, bck, fwd)函数。真正的重点就是这个unlink函数！</p><p><strong>上一段中描述的”前一个“与”后一个“chunk，是指的由chunk的prev_size与size字段隐式连接的chunk，即它们在内存中是连续、相邻的！而不是通过chunk中的fd与bk字段组成的bin(双向链表)中的前一个与后一个chunk，切记！</strong></p><p>fd = free函数的got表地址address – 12；(简称为“free addr – 12”)<br>bk = shellcode的地址。</p><p>调用unlink(nextchunk, bck, fwd)合并。</p><p>FD = nextchunk-&gt;fd = free addr– 12;<br>BK = nextchunk-&gt;bk = shellcode起始地址;<br>BK赋值给FD-&gt;bk，即（free add– 12）-&gt;bk = shellcode起始地址；<br>FD赋值给BK-&gt;fd，即(shellcode起始地址)-&gt;fd = free addr– 12;</p><p>最终，free add指向shellcode add,当程序在代码[5]处再次执行free的时候，就会转而执行shellcode。达到攻击效果</p><p><strong>Windows堆溢出攻击的主要形式</strong></p><ul><li>利用向量化异常处理（VEH）</li><li>利用系统默认异常处理函数（UEF）</li><li>Heap spray</li><li>Bitmap Flipping攻击</li><li>Bitmap XOR攻击</li><li>Heap Cache攻击</li></ul><h4 id="堆溢出的防御"><a href="#堆溢出的防御" class="headerlink" title="堆溢出的防御"></a>堆溢出的防御</h4><p>相比栈溢出，针对堆溢出的防御措施更易实用化<br>堆依靠系统库实现其维护，故堆保护=系统库升级</p><p><strong>针对unlink的保护</strong></p><ol><li><p>Double Free检测:该机制不允许释放已经处于free状态的chunk。因此，当攻击者将second chunk的size设置为-4的时候，就意味着该size的PREV_INUSE位为0，也就是说second chunk之前的first chunk(我们需要free的chunk)已经处于free状态，那么再free就报出double free错误。</p></li><li><p>next size非法检测: 检测next size是否在8到当前arena的整个系统内存大小之间。因此当检测到next size为-4的时候，就会报出invalid next size错误。</p></li><li><p>双链表冲突检测:执行unlink操作的时候检测链表中前一个chunk的fd与后一个chunk的bk是否都指向当前需要unlink的chunk。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大三下期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们沉浸爱情</title>
      <link href="/2021/06/20/CC%E7%9A%84%E5%BF%AB%E4%B9%90/"/>
      <url>/2021/06/20/CC%E7%9A%84%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<h2 id="晨晨的周记一"><a href="#晨晨的周记一" class="headerlink" title="晨晨的周记一"></a>晨晨的周记一</h2><p><img src="../CC%E7%9A%84%E5%BF%AB%E4%B9%90/0.JPG"></p><p> 这一周和弟弟的联系感觉没有上一周多了，原因呢大概就是我忙着找工作弟弟忙着准备期末考试呢，不知道为什么每次到这种环节我的心底就会泛起涟漪，想着我们的联系变少了以后会不会更少了，想着我们的联系变少了感情会不会没有之前热烈了，想着我们的联系变少了会不会没有以前那么亲密无间了，这些想法一直在我脑海中徘徊挥之不去，一空闲下来就会在想他在干嘛呢，不知道是不是在忙，早上是在背单词吗，背完有记得吃早饭再去学习吗。中午想的是他要不要休息会不然等会子下午学习会想打瞌睡的等等。</p><p>有时候看我这边的天气的时候，也会点开他那边的天气看一下，想知道和我的是否一样，想知道那个他有没有受凉或者中暑，晚上睡觉时想和他说完晚安一起睡，还有挂电话想等他挂这都是我的小心思呢，觉得这样会很甜！</p><p>再说回自己我这个人其实对要什么不是很清楚，但是等事情来了我就知道我要的是不是他，我的第一天工作总体来说说不上满意也说不上不满意，只要是第一天没啥事情可做我有点闲不住，其次就是这个岗位据我观察目前就是一个话务员的职位，我想做的是资料员所以目前不是特别满意之后跟那个负责人沟通一下叭，但是这不是一个长久的岗位只是一个过度而已，我的志愿目前是考公务员，虽然不知道我能不能考的上但是我会尽自己的努力加油的！</p><p>想安安稳稳的和弟弟生活下去，希望一切顺遂。</p><p>–LC</p>]]></content>
      
      
      <categories>
          
          <category> 晨晨的周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 晨晨 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个小实验</title>
      <link href="/2021/06/18/python%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/18/python%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>犯了一个错误，以后慢慢改吧！</p><pre class="line-numbers language-none"><code class="language-none">from torch.utils.data import DataLoader, random_splitfrom torchvision import transforms, datasets, modelsimport torch.nn as nnfrom torch.optim import SGDimport torchimport os#print(torch.cuda.is_available())#使用GPUdevice &#x3D; torch.device(&#39;cuda:0&#39;)#自定义数据集data_transform &#x3D; transforms.Compose([    transforms.Resize((224, 224)),    transforms.RandomHorizontalFlip(),    transforms.ToTensor(),    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])full_datasets &#x3D; datasets.ImageFolder(root &#x3D; &#39;.&#x2F;dataset&#39;, transform &#x3D; data_transform)#分为训练集和测试集train_size &#x3D; 1000test_size &#x3D; len(full_datasets) - train_sizetrain_datasets, test_datasets &#x3D; random_split(full_datasets, [train_size, test_size])#载入训练集和测试集batch_size_num &#x3D; 16load_train_datasets &#x3D; DataLoader(dataset &#x3D; train_datasets, batch_size&#x3D; batch_size_num, shuffle &#x3D; True)load_test_datasets &#x3D; DataLoader(dataset &#x3D; test_datasets, batch_size &#x3D; batch_size_num, shuffle &#x3D; True)#使用googlenet算法cnn &#x3D; models.googlenet(pretrained &#x3D; True)#将分类层的参数改为2features &#x3D; cnn.fc.in_featurescnn.fc &#x3D; nn.Linear(features, 2)#模型放入GPU中cnn &#x3D; cnn.to(device)#loss设置和梯度下降法lr_num &#x3D; 0.001loss_function &#x3D; nn.CrossEntropyLoss()optimizer &#x3D; SGD(cnn.parameters(), lr &#x3D; lr_num, momentum &#x3D; 0.9)#scheduler &#x3D; lr_scheduler.StepLR(optimizer &#x3D; optimizer, step_size &#x3D; 100, gamma &#x3D; 0.5)epochs &#x3D; 5for epoch in range(epochs):    loss_value &#x3D; 0.0    #scheduler.step()    #启用 BatchNormalization 和 Dropout    cnn.train()    for i, (datas_train, labels_train) in enumerate(load_train_datasets):        datas_train &#x3D; datas_train.to(device)        labels_train &#x3D; labels_train.to(device)                #优化器优化        optimizer.zero_grad()        outputs &#x3D; cnn(datas_train)        loss &#x3D; loss_function(outputs, labels_train)        loss.backward()        optimizer.step()        loss_value +&#x3D; loss.cpu().item()        correct &#x3D; 0    #每一个batch的loss求和除以batch的数量，就是该次epoch的平均loss    loss_value &#x3D; loss_value * batch_size_num &#x2F; train_size    cnn.eval()    #预测    acc &#x3D; 0    for datas_test, labels_test in load_test_datasets:        datas_test &#x3D; datas_test.to(device)        labels_test &#x3D; labels_test.to(device)            outputs_test &#x3D; cnn(datas_test)        prediction &#x3D; torch.max(outputs_test, 1)[1]        #同样的计算该次epoch的acc        acc +&#x3D; (torch.sum((prediction &#x3D;&#x3D; labels_test))).cpu().to(torch.float32)    print(&#39;epochs: &#123;&#125; |loss &#x3D; &#123;:.5f&#125; |accurcay &#x3D; &#123;:.5f&#125;&#39;.format(epoch + 1, loss_value, acc &#x2F; test_size))print(&#39;学习率:&#39;, lr_num, &#39;|Epochs:&#39;, epochs, &#39;|batch_size:&#39;, batch_size_num)os.system(&quot;pause&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 进步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的规划</title>
      <link href="/2021/06/18/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92/"/>
      <url>/2021/06/18/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="大学生职业与发展规划书"><a href="#大学生职业与发展规划书" class="headerlink" title="大学生职业与发展规划书"></a>大学生职业与发展规划书</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从我们出生到现在，面临重大的选择的时候我们都要借助他人的帮助进行选择，尤其是一些人生选择时刻，例如中考，选文理科，高考报考专业和自己将要进入的学校，很大一部分都是参照父母或者老师的意见。在进入人生的又一个选择的时候，转身，发现已经没有人在身后要求我们要怎么做，这时候我们只能根据自己的初心，自己的本性来做决定，就业或者是读研都是我们自己的选择，今天借此契机得以认真思考老师为我们所讲授的知识，并且能够为了我职业做一份大致的构画，以此激励自己成为自己想要成为的人。</p><p>以下分为四个部分来介绍我的职业生涯规划，分别是：</p><ul><li><strong>自我分析</strong></li><li><strong>确定职业生涯规划目标</strong></li><li><strong>成功标准</strong></li><li><strong>职业生涯规划书结束语</strong></li></ul><h3 id="一、自我分析"><a href="#一、自我分析" class="headerlink" title="一、自我分析"></a><strong>一、自我分析</strong></h3><h4 id="（一）认识自己的职业性格"><a href="#（一）认识自己的职业性格" class="headerlink" title="（一）认识自己的职业性格"></a>（一）认识自己的职业性格</h4><p>我是一个热情、活泼的男孩，自信而不张扬，正直而不呆板。在个人交流的圈子里，我用真诚对待每一个人，因为我相信那些爱别人的人会得到回报。我很乐意交朋友，希望能从我的朋友那里学到我所没有的东西。坚强的毅力,持之以恒的态度是我的特征,虽有些倔强,但是如果认为自己实在没能力完成任务,我会适时放弃。因为我认为适时放弃也是人生的一大智慧。冲动是我的主要缺点。我缺乏细致和冲动。我做事的时候从不用水拖泥带水，但有时我缺乏考虑。</p><p>我是一个完美主义者，我总是希望我能完美地完成它，尽管知道这是不可能的，但是我会朝着这个方向去做。</p><h4 id="（二）自己的兴趣爱好"><a href="#（二）自己的兴趣爱好" class="headerlink" title="（二）自己的兴趣爱好"></a>（二）自己的兴趣爱好</h4><p>总的来说我的兴趣和爱好还算比较广泛，喜欢读书、听音乐、听音乐、旅行、编程等。我善于表达自己的想法，表达我的意见和看法，我希望我能得到别人的认可。在学习的过程中，我会创造工作和休息相结合的条件，这样我就能更有效率地做事。我爱看传记与诗歌，喜欢与别人分享我在书中看到的知识，有时也会激烈的进行讨论，对于各种不同的价值观，我接受和而不同的思想方式，我认为这样才是一个真实的世界。尽管有时会因为生活的忙碌让自己无法有足够的事件来做自己喜欢的事情，我还是依旧对日子保持尽可能多的新鲜感。</p><h4 id="（三）自己的职业能力"><a href="#（三）自己的职业能力" class="headerlink" title="（三）自己的职业能力"></a>（三）自己的职业能力</h4><p>从某方面来讲，自己的感性能力和理性能力对半来分，只是在不同的场合而已，在做一些重要的事情时，我不会纵容任何一位熟悉的人偷懒或者逃避责任，面对不公正的行为都会坚定的保持自己的立场。在一些个人问题上，我始终保持开放的思想，认为不应该老古董对待变化中的世界，这样是不公平的。相反同时完成任务的时候，我甚至会选择更加具有挑战性的工作，用来提升自己的实力。</p><p>对于工作中的事情，比如自己的专业内的能力，保持中立的评价，只能维持在中等水平，对于一些困难的问题，自己无法得到答案，因为一些其他因素，可能自己也会失败和沮丧，而且面对未来，曾经有过小短时间的彷徨，时而转换了自己的目标，不知道如何发展，但也不至于停滞不前，到了如今，终于明确了自己的目标。</p><h4 id="（四）自我潜能"><a href="#（四）自我潜能" class="headerlink" title="（四）自我潜能"></a>（四）自我潜能</h4><ol><li><p>在自我潜能方面，由于参加了学生会和团委的工作，我发现我的社交能力与组织领导能力均有所提高，也具有一定的吃苦能力；</p></li><li><p>我的相关经历高中时的我曾担任过班长。也帮学校老师完成工作上的事情，在工作能力和勇气方面还有基础，所以面对上台演讲这类任务，只要准备的充分，个人不存在怯场或者过度紧张的表现；</p></li><li><p>个人品质 ：在个人品质方面，我拥有中国人最传统的道德底线与指标，具有不屈不挠的品质，并且对待老人和儿童保持礼貌，公共场合不喧哗，乐于帮助陌生人，尤其是在车站附近或者公交车地铁上帮助他人指引方向；</p></li><li><p>人生格言:幸福生活是留给奋斗过的人。</p></li></ol><p>综上所述，只要我选择了适合自己的，我就会是最好的。我明白我无法决定生命的长短，但我可以控制它的宽度，我无法控制天气，但我可以改变我的心情，明天我无法预测，但我今天可以用，我不能顺利，但我可以做任何事情。努力工作。</p><h3 id="二、确定职业生涯规划目标："><a href="#二、确定职业生涯规划目标：" class="headerlink" title="二、确定职业生涯规划目标："></a><strong>二、确定职业生涯规划目标：</strong></h3><p>通过前面的自我评估，我认为自己是外向并且内敛型的人。善于思考问题不仅是我的爱好，更是我的优势。在未来的学习和生活中，我相信在一次又一次的学习和生活中，我会不断地提高自己，并尽我最大的努力去保留知识。因为机会通常只有几秒钟，而且只对那些有准备的人，我计划我的生活。只要自己能够实现自己的规划，那就能够为自己的生活作保障，并且不后悔自己所做的选择。</p><h4 id="（一）大学期间"><a href="#（一）大学期间" class="headerlink" title="（一）大学期间"></a>（一）大学期间</h4><p>大学即将结束，但并不影响我加强对自己的进一步要求，在这一过程中，积极做好学生的本职工作，并且不偷懒，不懦弱，工作认真，学习努力。</p><ol><li><p>思想政治及道德素质方面：以马列主义、毛泽东思想、邓小平理论、”三个代表”重要思想为指导，树立正确的人生观、价值观、道德观、奋斗观、创业观，坚持正确的人生价值取向。定期提交对党的章程的学习、理解和实践，以及自己的言行和感受，争取通过审查，尽快加入中国共产党，积极参加党的活动。</p></li><li><p>社会实践与志愿服务方面： 适时参加社会调查活动。及时参与安全自愿献血、植树活动、青年志愿服务活动等公益事业。</p></li><li><p>科技学术创新创业方面:扎实学习专业技能,同时,充分利用校内图书馆、校外图书城及网络信息,开拓视野和知识范围,以此,激发、开拓思路,尝试设计开展学术创新、科技创新。</p></li><li><p>文体艺术、社团活动与身心发展方面：积极参加校内外文体艺术活动、校内社团活动、演讲赛、辩论赛、书画比赛等，以此充分锻炼胆量、能力，展示个人风采。积极参加身体锻炼，每周平均锻炼四次。</p></li><li><p>学业方面：平时，无非常特殊情况绝不迟到、请假，更不准旷课，保证好学习听讲时间及学习质量。除了上课时间，我们还应该充分利用课后时间。除去必要适可的身体锻炼、娱乐活动及休闲时间外，均应安心、踏实、专注地攻读职业方向类、专业类书籍和其它类别的实用书籍。学习时要注意预习、听课、复习、综合分析比较、用时比例。知识积累不仅要博大精深，还要专业化、精练，力求毕业时获得优秀毕业生的称号。</p></li><li><p>考研任务繁重，加紧有效的时间做好考研工作的安排，对于自己的前途和理想不迷路，积极实现自己的感兴趣的目标，通识课，数学和英语的学习人中而道远，同时加强自己在专业课方面的技能，不再在懒散中浪费时光。</p></li></ol><h4 id="（二）毕业后的职业生涯规划"><a href="#（二）毕业后的职业生涯规划" class="headerlink" title="（二）毕业后的职业生涯规划"></a>（二）毕业后的职业生涯规划</h4><p>在之前的考研前期准备过程中，我发现自己的目标不在于本专业，或者如果之后读研深造，继续完成本专业的学习会给我带来困扰，于是决定在考研的过程中进行一些小的方向性调整，这些小调整也是经过我个人的认真思考，由本科学习信息安全专业转向研究生的大数据应用技术。这可能是以此小跨考，均属于计算机相关专业，只是在纯粹计算机技术方面，自己有着极大的学科空白，这也源于自己在本科学习过程中的懒惰行为。不过在我的学习过程中发现自己对于计算机硬件的极大抵触性，而且由于d之后的选择的未知性导致我做出了此次选择。并且考研院校也由自己的学校变成了中部地区的中南大学，任重而道远。</p><p>有了明确的目标就应该加紧时间足够努力去冲刺，我会每周给自己制定学习计划，深知学习非一朝一夕之事，但是会是一朝一夕积累得来的经验，面对一些无法解决的难题，我会花费足够多的是时间去增强自己的能力。去中部地区读研首要原因是日后可能在中部地区发展，并且在中部生活。那很大程度需要自己积累人脉，如果报考本校之后极大可能会因为地域的原因导致自己在中部的发展滞后他人。加上在职业招聘平台的定向搜索，发现目前所学专业信息安全虽然有很大的空缺，但在定向搜索的区域，发现人才需要并不很大，这导致了自己之后的求职之路可能艰辛且漫漫。况且由于本人的兴趣问题，在本科学习过程中发现自己对于大数据的兴趣不断提升，在一次课堂上对于老师布置的作业有着格外的兴趣，觉得日后可能会专研此方向。</p><p>以上是短暂的几年的规划，长期的规划是，短期培养能力，进入公司不断提升自己，再在人才的管理方面花费少许精力，使得之后的转型更加便捷，后来便可以进入慢慢晋升的道路。希望漫漫长路，自己能够不辞辛苦得到的果实能有心爱的人一起分享。</p><h3 id="三、成功标准"><a href="#三、成功标准" class="headerlink" title="三、成功标准"></a><strong>三、成功标准</strong></h3><p>我的成功标准：一个人设定一个积极的目标，经过努力，有一个积极的收获，就是成功。每个阶段中只要自己尽心尽力能力也得到了发挥都会自我的提高即使目标没有实现做的事至少自己努力过拼搏过我不会给自己后悔的理由。</p><p>成功之路有许多条，成功的定义也有许多种，只要在理想的指引下，真正做了自己想做的事情，真正实现了自己的人生的价值，就是一种成功，一种超越，就应该为此感到自豪和快乐。</p><h3 id="职业生涯规划书结束语"><a href="#职业生涯规划书结束语" class="headerlink" title="职业生涯规划书结束语"></a><strong>职业生涯规划书结束语</strong></h3><p>身为大学生的我们，应该珍惜这来之不易的学习机会。不是每个人都可以在大学里度过他一生中最美好的日子。人的大学时光一生中也就有一次,不把握好,将来自己一定回追悔莫及。</p><p>有了目标，才有动力。这份大学生职业生涯规划书给了我一个明确的学习目标和职业规划。我将按照上述内容完成自己的学习任务和工作任务，使我的生活更有意义。</p><p>这是我自己的职业生涯规划。有一个好的计划，就有了一个好的开端，其实这不是一件简单的事情，但只要有努力工作，就会有成就。现实是变化的，计划也应要跟着有所改变。我们务必保持清醒的头脑，及时处理我们碰到的困难。每个人都有自己的理想，不过要实现自己的这个理想还是得依靠自己的努力付出才行，无论你的理想有多美好，没有辛勤的汗水都是不可能实现的。天下没有免费的午餐，一个人，要想有所作为，必须拿出勇气，必须付出努力，必须学会去为自己的梦想拼搏，奋斗。成功,不相信眼泪成功,不相信颓废成功不相信幻影,未来,要靠自己去打拼!</p>]]></content>
      
      
      <categories>
          
          <category> 要成功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生涯规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
